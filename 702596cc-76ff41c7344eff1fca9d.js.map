{"version":3,"file":"702596cc-76ff41c7344eff1fca9d.js","mappings":"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","sources":["webpack://@react-babylonjs/docs/../../node_modules/@babylonjs/core/scene.js"],"sourcesContent":["import { Tools } from \"./Misc/tools.js\";\nimport { PrecisionDate } from \"./Misc/precisionDate.js\";\nimport { Observable } from \"./Misc/observable.js\";\nimport { SmartArrayNoDuplicate, SmartArray } from \"./Misc/smartArray.js\";\nimport { StringDictionary } from \"./Misc/stringDictionary.js\";\nimport { Tags } from \"./Misc/tags.js\";\nimport { Vector3, Matrix, TmpVectors } from \"./Maths/math.vector.js\";\nimport { AbstractScene } from \"./abstractScene.js\";\nimport { ImageProcessingConfiguration } from \"./Materials/imageProcessingConfiguration.js\";\nimport { UniformBuffer } from \"./Materials/uniformBuffer.js\";\nimport { PickingInfo } from \"./Collisions/pickingInfo.js\";\nimport { ActionEvent } from \"./Actions/actionEvent.js\";\nimport { PostProcessManager } from \"./PostProcesses/postProcessManager.js\";\nimport { RenderingManager } from \"./Rendering/renderingManager.js\";\nimport { Stage } from \"./sceneComponent.js\";\nimport { IsWindowObjectExist } from \"./Misc/domManagement.js\";\nimport { EngineStore } from \"./Engines/engineStore.js\";\nimport { _WarnImport } from \"./Misc/devTools.js\";\nimport { InputManager } from \"./Inputs/scene.inputManager.js\";\nimport { PerfCounter } from \"./Misc/perfCounter.js\";\nimport { Color4, Color3 } from \"./Maths/math.color.js\";\nimport { Frustum } from \"./Maths/math.frustum.js\";\nimport { UniqueIdGenerator } from \"./Misc/uniqueIdGenerator.js\";\nimport { ReadFile, RequestFile, LoadFile } from \"./Misc/fileTools.js\";\nimport { LightConstants } from \"./Lights/lightConstants.js\";\nimport { _ObserveArray } from \"./Misc/arrayTools.js\";\nimport { PointerPickingConfiguration } from \"./Inputs/pointerPickingConfiguration.js\";\n/**\n * Define how the scene should favor performance over ease of use\n */\nexport var ScenePerformancePriority;\n(function (ScenePerformancePriority) {\n  /** Default mode. No change. Performance will be treated as less important than backward compatibility */\n  ScenePerformancePriority[ScenePerformancePriority[\"BackwardCompatible\"] = 0] = \"BackwardCompatible\";\n  /** Some performance options will be turned on trying to strike a balance between perf and ease of use */\n  ScenePerformancePriority[ScenePerformancePriority[\"Intermediate\"] = 1] = \"Intermediate\";\n  /** Performance will be top priority */\n  ScenePerformancePriority[ScenePerformancePriority[\"Aggressive\"] = 2] = \"Aggressive\";\n})(ScenePerformancePriority || (ScenePerformancePriority = {}));\n/**\n * Represents a scene to be rendered by the engine.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene\n */\nexport class Scene extends AbstractScene {\n  /**\n   * Factory used to create the default material.\n   * @param scene The scene to create the material for\n   * @returns The default material\n   */\n  static DefaultMaterialFactory(scene) {\n    throw _WarnImport(\"StandardMaterial\");\n  }\n  /**\n   * Factory used to create the a collision coordinator.\n   * @returns The collision coordinator\n   */\n  static CollisionCoordinatorFactory() {\n    throw _WarnImport(\"DefaultCollisionCoordinator\");\n  }\n  /**\n   * Texture used in all pbr material as the reflection texture.\n   * As in the majority of the scene they are the same (exception for multi room and so on),\n   * this is easier to reference from here than from all the materials.\n   */\n  get environmentTexture() {\n    return this._environmentTexture;\n  }\n  /**\n   * Texture used in all pbr material as the reflection texture.\n   * As in the majority of the scene they are the same (exception for multi room and so on),\n   * this is easier to set here than in all the materials.\n   */\n  set environmentTexture(value) {\n    if (this._environmentTexture === value) {\n      return;\n    }\n    this._environmentTexture = value;\n    this.markAllMaterialsAsDirty(1);\n  }\n  /**\n   * Default image processing configuration used either in the rendering\n   * Forward main pass or through the imageProcessingPostProcess if present.\n   * As in the majority of the scene they are the same (exception for multi camera),\n   * this is easier to reference from here than from all the materials and post process.\n   *\n   * No setter as we it is a shared configuration, you can set the values instead.\n   */\n  get imageProcessingConfiguration() {\n    return this._imageProcessingConfiguration;\n  }\n  /**\n   * Gets or sets a value indicating how to treat performance relatively to ease of use and backward compatibility\n   */\n  get performancePriority() {\n    return this._performancePriority;\n  }\n  set performancePriority(value) {\n    if (value === this._performancePriority) {\n      return;\n    }\n    this._performancePriority = value;\n    switch (value) {\n      case ScenePerformancePriority.BackwardCompatible:\n        this.skipFrustumClipping = false;\n        this._renderingManager.maintainStateBetweenFrames = false;\n        this.skipPointerMovePicking = false;\n        this.autoClear = true;\n        break;\n      case ScenePerformancePriority.Intermediate:\n        this.skipFrustumClipping = false;\n        this._renderingManager.maintainStateBetweenFrames = false;\n        this.skipPointerMovePicking = true;\n        this.autoClear = false;\n        break;\n      case ScenePerformancePriority.Aggressive:\n        this.skipFrustumClipping = true;\n        this._renderingManager.maintainStateBetweenFrames = true;\n        this.skipPointerMovePicking = true;\n        this.autoClear = false;\n        break;\n    }\n    this.onScenePerformancePriorityChangedObservable.notifyObservers(value);\n  }\n  /**\n   * Gets or sets a boolean indicating if all rendering must be done in wireframe\n   */\n  set forceWireframe(value) {\n    if (this._forceWireframe === value) {\n      return;\n    }\n    this._forceWireframe = value;\n    this.markAllMaterialsAsDirty(16);\n  }\n  get forceWireframe() {\n    return this._forceWireframe;\n  }\n  /**\n   * Gets or sets a boolean indicating if we should skip the frustum clipping part of the active meshes selection\n   */\n  set skipFrustumClipping(value) {\n    if (this._skipFrustumClipping === value) {\n      return;\n    }\n    this._skipFrustumClipping = value;\n  }\n  get skipFrustumClipping() {\n    return this._skipFrustumClipping;\n  }\n  /**\n   * Gets or sets a boolean indicating if all rendering must be done in point cloud\n   */\n  set forcePointsCloud(value) {\n    if (this._forcePointsCloud === value) {\n      return;\n    }\n    this._forcePointsCloud = value;\n    this.markAllMaterialsAsDirty(16);\n  }\n  get forcePointsCloud() {\n    return this._forcePointsCloud;\n  }\n  /**\n   * Gets or sets the animation properties override\n   */\n  get animationPropertiesOverride() {\n    return this._animationPropertiesOverride;\n  }\n  set animationPropertiesOverride(value) {\n    this._animationPropertiesOverride = value;\n  }\n  /** Sets a function to be executed when this scene is disposed. */\n  set onDispose(callback) {\n    if (this._onDisposeObserver) {\n      this.onDisposeObservable.remove(this._onDisposeObserver);\n    }\n    this._onDisposeObserver = this.onDisposeObservable.add(callback);\n  }\n  /** Sets a function to be executed before rendering this scene */\n  set beforeRender(callback) {\n    if (this._onBeforeRenderObserver) {\n      this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n    }\n    if (callback) {\n      this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n    }\n  }\n  /** Sets a function to be executed after rendering this scene */\n  set afterRender(callback) {\n    if (this._onAfterRenderObserver) {\n      this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n    }\n    if (callback) {\n      this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n    }\n  }\n  /** Sets a function to be executed before rendering a camera*/\n  set beforeCameraRender(callback) {\n    if (this._onBeforeCameraRenderObserver) {\n      this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n    }\n    this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);\n  }\n  /** Sets a function to be executed after rendering a camera*/\n  set afterCameraRender(callback) {\n    if (this._onAfterCameraRenderObserver) {\n      this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);\n    }\n    this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);\n  }\n  /**\n   * Gets or sets a predicate used to select candidate meshes for a pointer down event\n   */\n  get pointerDownPredicate() {\n    return this._pointerPickingConfiguration.pointerDownPredicate;\n  }\n  set pointerDownPredicate(value) {\n    this._pointerPickingConfiguration.pointerDownPredicate = value;\n  }\n  /**\n   * Gets or sets a predicate used to select candidate meshes for a pointer up event\n   */\n  get pointerUpPredicate() {\n    return this._pointerPickingConfiguration.pointerUpPredicate;\n  }\n  set pointerUpPredicate(value) {\n    this._pointerPickingConfiguration.pointerUpPredicate = value;\n  }\n  /**\n   * Gets or sets a predicate used to select candidate meshes for a pointer move event\n   */\n  get pointerMovePredicate() {\n    return this._pointerPickingConfiguration.pointerMovePredicate;\n  }\n  set pointerMovePredicate(value) {\n    this._pointerPickingConfiguration.pointerMovePredicate = value;\n  }\n  /**\n   * Gets or sets a predicate used to select candidate meshes for a pointer down event\n   */\n  get pointerDownFastCheck() {\n    return this._pointerPickingConfiguration.pointerDownFastCheck;\n  }\n  set pointerDownFastCheck(value) {\n    this._pointerPickingConfiguration.pointerDownFastCheck = value;\n  }\n  /**\n   * Gets or sets a predicate used to select candidate meshes for a pointer up event\n   */\n  get pointerUpFastCheck() {\n    return this._pointerPickingConfiguration.pointerUpFastCheck;\n  }\n  set pointerUpFastCheck(value) {\n    this._pointerPickingConfiguration.pointerUpFastCheck = value;\n  }\n  /**\n   * Gets or sets a predicate used to select candidate meshes for a pointer move event\n   */\n  get pointerMoveFastCheck() {\n    return this._pointerPickingConfiguration.pointerMoveFastCheck;\n  }\n  set pointerMoveFastCheck(value) {\n    this._pointerPickingConfiguration.pointerMoveFastCheck = value;\n  }\n  /**\n   * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer move event occurs.\n   */\n  get skipPointerMovePicking() {\n    return this._pointerPickingConfiguration.skipPointerMovePicking;\n  }\n  set skipPointerMovePicking(value) {\n    this._pointerPickingConfiguration.skipPointerMovePicking = value;\n  }\n  /**\n   * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer down event occurs.\n   */\n  get skipPointerDownPicking() {\n    return this._pointerPickingConfiguration.skipPointerDownPicking;\n  }\n  set skipPointerDownPicking(value) {\n    this._pointerPickingConfiguration.skipPointerDownPicking = value;\n  }\n  /**\n   * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer up event occurs.  Off by default.\n   */\n  get skipPointerUpPicking() {\n    return this._pointerPickingConfiguration.skipPointerUpPicking;\n  }\n  set skipPointerUpPicking(value) {\n    this._pointerPickingConfiguration.skipPointerUpPicking = value;\n  }\n  /**\n   * Gets the pointer coordinates without any translation (ie. straight out of the pointer event)\n   */\n  get unTranslatedPointer() {\n    return this._inputManager.unTranslatedPointer;\n  }\n  /**\n   * Gets or sets the distance in pixel that you have to move to prevent some events. Default is 10 pixels\n   */\n  static get DragMovementThreshold() {\n    return InputManager.DragMovementThreshold;\n  }\n  static set DragMovementThreshold(value) {\n    InputManager.DragMovementThreshold = value;\n  }\n  /**\n   * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 500 ms\n   */\n  static get LongPressDelay() {\n    return InputManager.LongPressDelay;\n  }\n  static set LongPressDelay(value) {\n    InputManager.LongPressDelay = value;\n  }\n  /**\n   * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 300 ms\n   */\n  static get DoubleClickDelay() {\n    return InputManager.DoubleClickDelay;\n  }\n  static set DoubleClickDelay(value) {\n    InputManager.DoubleClickDelay = value;\n  }\n  /** If you need to check double click without raising a single click at first click, enable this flag */\n  static get ExclusiveDoubleClickMode() {\n    return InputManager.ExclusiveDoubleClickMode;\n  }\n  static set ExclusiveDoubleClickMode(value) {\n    InputManager.ExclusiveDoubleClickMode = value;\n  }\n  /**\n   * Bind the current view position to an effect.\n   * @param effect The effect to be bound\n   * @param variableName name of the shader variable that will hold the eye position\n   * @param isVector3 true to indicates that variableName is a Vector3 and not a Vector4\n   * @returns the computed eye position\n   */\n  bindEyePosition(effect) {\n    let variableName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"vEyePosition\";\n    let isVector3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var _a;\n    const eyePosition = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : (_a = this.activeCamera.globalPosition) !== null && _a !== void 0 ? _a : this.activeCamera.devicePosition;\n    const invertNormal = this.useRightHandedSystem === (this._mirroredCameraPosition != null);\n    TmpVectors.Vector4[0].set(eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);\n    if (effect) {\n      if (isVector3) {\n        effect.setFloat3(variableName, TmpVectors.Vector4[0].x, TmpVectors.Vector4[0].y, TmpVectors.Vector4[0].z);\n      } else {\n        effect.setVector4(variableName, TmpVectors.Vector4[0]);\n      }\n    }\n    return TmpVectors.Vector4[0];\n  }\n  /**\n   * Update the scene ubo before it can be used in rendering processing\n   * @returns the scene UniformBuffer\n   */\n  finalizeSceneUbo() {\n    const ubo = this.getSceneUniformBuffer();\n    const eyePosition = this.bindEyePosition(null);\n    ubo.updateFloat4(\"vEyePosition\", eyePosition.x, eyePosition.y, eyePosition.z, eyePosition.w);\n    ubo.update();\n    return ubo;\n  }\n  /**\n   * Gets or sets a boolean indicating if the scene must use right-handed coordinates system\n   */\n  set useRightHandedSystem(value) {\n    if (this._useRightHandedSystem === value) {\n      return;\n    }\n    this._useRightHandedSystem = value;\n    this.markAllMaterialsAsDirty(16);\n  }\n  get useRightHandedSystem() {\n    return this._useRightHandedSystem;\n  }\n  /**\n   * Sets the step Id used by deterministic lock step\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n   * @param newStepId defines the step Id\n   */\n  setStepId(newStepId) {\n    this._currentStepId = newStepId;\n  }\n  /**\n   * Gets the step Id used by deterministic lock step\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n   * @returns the step Id\n   */\n  getStepId() {\n    return this._currentStepId;\n  }\n  /**\n   * Gets the internal step used by deterministic lock step\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n   * @returns the internal step\n   */\n  getInternalStep() {\n    return this._currentInternalStep;\n  }\n  /**\n   * Gets or sets a boolean indicating if fog is enabled on this scene\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n   * (Default is true)\n   */\n  set fogEnabled(value) {\n    if (this._fogEnabled === value) {\n      return;\n    }\n    this._fogEnabled = value;\n    this.markAllMaterialsAsDirty(16);\n  }\n  get fogEnabled() {\n    return this._fogEnabled;\n  }\n  /**\n   * Gets or sets the fog mode to use\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n   * | mode | value |\n   * | --- | --- |\n   * | FOGMODE_NONE | 0 |\n   * | FOGMODE_EXP | 1 |\n   * | FOGMODE_EXP2 | 2 |\n   * | FOGMODE_LINEAR | 3 |\n   */\n  set fogMode(value) {\n    if (this._fogMode === value) {\n      return;\n    }\n    this._fogMode = value;\n    this.markAllMaterialsAsDirty(16);\n  }\n  get fogMode() {\n    return this._fogMode;\n  }\n  /**\n   * Flag indicating that the frame buffer binding is handled by another component\n   */\n  get prePass() {\n    return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;\n  }\n  /**\n   * Gets or sets a boolean indicating if shadows are enabled on this scene\n   */\n  set shadowsEnabled(value) {\n    if (this._shadowsEnabled === value) {\n      return;\n    }\n    this._shadowsEnabled = value;\n    this.markAllMaterialsAsDirty(2);\n  }\n  get shadowsEnabled() {\n    return this._shadowsEnabled;\n  }\n  /**\n   * Gets or sets a boolean indicating if lights are enabled on this scene\n   */\n  set lightsEnabled(value) {\n    if (this._lightsEnabled === value) {\n      return;\n    }\n    this._lightsEnabled = value;\n    this.markAllMaterialsAsDirty(2);\n  }\n  get lightsEnabled() {\n    return this._lightsEnabled;\n  }\n  /** All of the active cameras added to this scene. */\n  get activeCameras() {\n    return this._activeCameras;\n  }\n  set activeCameras(cameras) {\n    if (this._unObserveActiveCameras) {\n      this._unObserveActiveCameras();\n      this._unObserveActiveCameras = null;\n    }\n    if (cameras) {\n      this._unObserveActiveCameras = _ObserveArray(cameras, () => {\n        this.onActiveCamerasChanged.notifyObservers(this);\n      });\n    }\n    this._activeCameras = cameras;\n  }\n  /** Gets or sets the current active camera */\n  get activeCamera() {\n    return this._activeCamera;\n  }\n  set activeCamera(value) {\n    if (value === this._activeCamera) {\n      return;\n    }\n    this._activeCamera = value;\n    this.onActiveCameraChanged.notifyObservers(this);\n  }\n  /** The default material used on meshes when no material is affected */\n  get defaultMaterial() {\n    if (!this._defaultMaterial) {\n      this._defaultMaterial = Scene.DefaultMaterialFactory(this);\n    }\n    return this._defaultMaterial;\n  }\n  /** The default material used on meshes when no material is affected */\n  set defaultMaterial(value) {\n    this._defaultMaterial = value;\n  }\n  /**\n   * Gets or sets a boolean indicating if textures are enabled on this scene\n   */\n  set texturesEnabled(value) {\n    if (this._texturesEnabled === value) {\n      return;\n    }\n    this._texturesEnabled = value;\n    this.markAllMaterialsAsDirty(1);\n  }\n  get texturesEnabled() {\n    return this._texturesEnabled;\n  }\n  /**\n   * Gets or sets a boolean indicating if skeletons are enabled on this scene\n   */\n  set skeletonsEnabled(value) {\n    if (this._skeletonsEnabled === value) {\n      return;\n    }\n    this._skeletonsEnabled = value;\n    this.markAllMaterialsAsDirty(8);\n  }\n  get skeletonsEnabled() {\n    return this._skeletonsEnabled;\n  }\n  /** @internal */\n  get collisionCoordinator() {\n    if (!this._collisionCoordinator) {\n      this._collisionCoordinator = Scene.CollisionCoordinatorFactory();\n      this._collisionCoordinator.init(this);\n    }\n    return this._collisionCoordinator;\n  }\n  /**\n   * Gets the scene's rendering manager\n   */\n  get renderingManager() {\n    return this._renderingManager;\n  }\n  /**\n   * Gets the list of frustum planes (built from the active camera)\n   */\n  get frustumPlanes() {\n    return this._frustumPlanes;\n  }\n  /**\n   * Registers the transient components if needed.\n   */\n  _registerTransientComponents() {\n    // Register components that have been associated lately to the scene.\n    if (this._transientComponents.length > 0) {\n      for (const component of this._transientComponents) {\n        component.register();\n      }\n      this._transientComponents.length = 0;\n    }\n  }\n  /**\n   * @internal\n   * Add a component to the scene.\n   * Note that the ccomponent could be registered on th next frame if this is called after\n   * the register component stage.\n   * @param component Defines the component to add to the scene\n   */\n  _addComponent(component) {\n    this._components.push(component);\n    this._transientComponents.push(component);\n    const serializableComponent = component;\n    if (serializableComponent.addFromContainer && serializableComponent.serialize) {\n      this._serializableComponents.push(serializableComponent);\n    }\n  }\n  /**\n   * @internal\n   * Gets a component from the scene.\n   * @param name defines the name of the component to retrieve\n   * @returns the component or null if not present\n   */\n  _getComponent(name) {\n    for (const component of this._components) {\n      if (component.name === name) {\n        return component;\n      }\n    }\n    return null;\n  }\n  /**\n   * Creates a new Scene\n   * @param engine defines the engine to use to render this scene\n   * @param options defines the scene options\n   */\n  constructor(engine, options) {\n    super();\n    // Members\n    /** @internal */\n    this._inputManager = new InputManager(this);\n    /** Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position */\n    this.cameraToUseForPointers = null;\n    /** @internal */\n    this._isScene = true;\n    /** @internal */\n    this._blockEntityCollection = false;\n    /**\n     * Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame\n     */\n    this.autoClear = true;\n    /**\n     * Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame\n     */\n    this.autoClearDepthAndStencil = true;\n    /**\n     * Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))\n     */\n    this.clearColor = new Color4(0.2, 0.2, 0.3, 1.0);\n    /**\n     * Defines the color used to simulate the ambient color (Default is (0, 0, 0))\n     */\n    this.ambientColor = new Color3(0, 0, 0);\n    /**\n     * Intensity of the environment in all pbr material.\n     * This dims or reinforces the IBL lighting overall (reflection and diffuse).\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to reference from here than from all the materials.\n     */\n    this.environmentIntensity = 1;\n    this._performancePriority = ScenePerformancePriority.BackwardCompatible;\n    /**\n     * Observable triggered when the performance priority is changed\n     */\n    this.onScenePerformancePriorityChangedObservable = new Observable();\n    this._forceWireframe = false;\n    this._skipFrustumClipping = false;\n    this._forcePointsCloud = false;\n    /**\n     * Gets or sets a boolean indicating if animations are enabled\n     */\n    this.animationsEnabled = true;\n    this._animationPropertiesOverride = null;\n    /**\n     * Gets or sets a boolean indicating if a constant deltatime has to be used\n     * This is mostly useful for testing purposes when you do not want the animations to scale with the framerate\n     */\n    this.useConstantAnimationDeltaTime = false;\n    /**\n     * Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated\n     * Please note that it requires to run a ray cast through the scene on every frame\n     */\n    this.constantlyUpdateMeshUnderPointer = false;\n    /**\n     * Defines the HTML cursor to use when hovering over interactive elements\n     */\n    this.hoverCursor = \"pointer\";\n    /**\n     * Defines the HTML default cursor to use (empty by default)\n     */\n    this.defaultCursor = \"\";\n    /**\n     * Defines whether cursors are handled by the scene.\n     */\n    this.doNotHandleCursors = false;\n    /**\n     * This is used to call preventDefault() on pointer down\n     * in order to block unwanted artifacts like system double clicks\n     */\n    this.preventDefaultOnPointerDown = true;\n    /**\n     * This is used to call preventDefault() on pointer up\n     * in order to block unwanted artifacts like system double clicks\n     */\n    this.preventDefaultOnPointerUp = true;\n    // Metadata\n    /**\n     * Gets or sets user defined metadata\n     */\n    this.metadata = null;\n    /**\n     * For internal use only. Please do not use.\n     */\n    this.reservedDataStore = null;\n    /**\n     * Use this array to add regular expressions used to disable offline support for specific urls\n     */\n    this.disableOfflineSupportExceptionRules = new Array();\n    /**\n     * An event triggered when the scene is disposed.\n     */\n    this.onDisposeObservable = new Observable();\n    this._onDisposeObserver = null;\n    /**\n     * An event triggered before rendering the scene (right after animations and physics)\n     */\n    this.onBeforeRenderObservable = new Observable();\n    this._onBeforeRenderObserver = null;\n    /**\n     * An event triggered after rendering the scene\n     */\n    this.onAfterRenderObservable = new Observable();\n    /**\n     * An event triggered after rendering the scene for an active camera (When scene.render is called this will be called after each camera)\n     * This is triggered for each \"sub\" camera in a Camera Rig unlike onAfterCameraRenderObservable\n     */\n    this.onAfterRenderCameraObservable = new Observable();\n    this._onAfterRenderObserver = null;\n    /**\n     * An event triggered before animating the scene\n     */\n    this.onBeforeAnimationsObservable = new Observable();\n    /**\n     * An event triggered after animations processing\n     */\n    this.onAfterAnimationsObservable = new Observable();\n    /**\n     * An event triggered before draw calls are ready to be sent\n     */\n    this.onBeforeDrawPhaseObservable = new Observable();\n    /**\n     * An event triggered after draw calls have been sent\n     */\n    this.onAfterDrawPhaseObservable = new Observable();\n    /**\n     * An event triggered when the scene is ready\n     */\n    this.onReadyObservable = new Observable();\n    /**\n     * An event triggered before rendering a camera\n     */\n    this.onBeforeCameraRenderObservable = new Observable();\n    this._onBeforeCameraRenderObserver = null;\n    /**\n     * An event triggered after rendering a camera\n     * This is triggered for the full rig Camera only unlike onAfterRenderCameraObservable\n     */\n    this.onAfterCameraRenderObservable = new Observable();\n    this._onAfterCameraRenderObserver = null;\n    /**\n     * An event triggered when active meshes evaluation is about to start\n     */\n    this.onBeforeActiveMeshesEvaluationObservable = new Observable();\n    /**\n     * An event triggered when active meshes evaluation is done\n     */\n    this.onAfterActiveMeshesEvaluationObservable = new Observable();\n    /**\n     * An event triggered when particles rendering is about to start\n     * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\n     */\n    this.onBeforeParticlesRenderingObservable = new Observable();\n    /**\n     * An event triggered when particles rendering is done\n     * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\n     */\n    this.onAfterParticlesRenderingObservable = new Observable();\n    /**\n     * An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed\n     */\n    this.onDataLoadedObservable = new Observable();\n    /**\n     * An event triggered when a camera is created\n     */\n    this.onNewCameraAddedObservable = new Observable();\n    /**\n     * An event triggered when a camera is removed\n     */\n    this.onCameraRemovedObservable = new Observable();\n    /**\n     * An event triggered when a light is created\n     */\n    this.onNewLightAddedObservable = new Observable();\n    /**\n     * An event triggered when a light is removed\n     */\n    this.onLightRemovedObservable = new Observable();\n    /**\n     * An event triggered when a geometry is created\n     */\n    this.onNewGeometryAddedObservable = new Observable();\n    /**\n     * An event triggered when a geometry is removed\n     */\n    this.onGeometryRemovedObservable = new Observable();\n    /**\n     * An event triggered when a transform node is created\n     */\n    this.onNewTransformNodeAddedObservable = new Observable();\n    /**\n     * An event triggered when a transform node is removed\n     */\n    this.onTransformNodeRemovedObservable = new Observable();\n    /**\n     * An event triggered when a mesh is created\n     */\n    this.onNewMeshAddedObservable = new Observable();\n    /**\n     * An event triggered when a mesh is removed\n     */\n    this.onMeshRemovedObservable = new Observable();\n    /**\n     * An event triggered when a skeleton is created\n     */\n    this.onNewSkeletonAddedObservable = new Observable();\n    /**\n     * An event triggered when a skeleton is removed\n     */\n    this.onSkeletonRemovedObservable = new Observable();\n    /**\n     * An event triggered when a material is created\n     */\n    this.onNewMaterialAddedObservable = new Observable();\n    /**\n     * An event triggered when a multi material is created\n     */\n    this.onNewMultiMaterialAddedObservable = new Observable();\n    /**\n     * An event triggered when a material is removed\n     */\n    this.onMaterialRemovedObservable = new Observable();\n    /**\n     * An event triggered when a multi material is removed\n     */\n    this.onMultiMaterialRemovedObservable = new Observable();\n    /**\n     * An event triggered when a texture is created\n     */\n    this.onNewTextureAddedObservable = new Observable();\n    /**\n     * An event triggered when a texture is removed\n     */\n    this.onTextureRemovedObservable = new Observable();\n    /**\n     * An event triggered when render targets are about to be rendered\n     * Can happen multiple times per frame.\n     */\n    this.onBeforeRenderTargetsRenderObservable = new Observable();\n    /**\n     * An event triggered when render targets were rendered.\n     * Can happen multiple times per frame.\n     */\n    this.onAfterRenderTargetsRenderObservable = new Observable();\n    /**\n     * An event triggered before calculating deterministic simulation step\n     */\n    this.onBeforeStepObservable = new Observable();\n    /**\n     * An event triggered after calculating deterministic simulation step\n     */\n    this.onAfterStepObservable = new Observable();\n    /**\n     * An event triggered when the activeCamera property is updated\n     */\n    this.onActiveCameraChanged = new Observable();\n    /**\n     * An event triggered when the activeCameras property is updated\n     */\n    this.onActiveCamerasChanged = new Observable();\n    /**\n     * This Observable will be triggered before rendering each renderingGroup of each rendered camera.\n     * The RenderingGroupInfo class contains all the information about the context in which the observable is called\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n     */\n    this.onBeforeRenderingGroupObservable = new Observable();\n    /**\n     * This Observable will be triggered after rendering each renderingGroup of each rendered camera.\n     * The RenderingGroupInfo class contains all the information about the context in which the observable is called\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n     */\n    this.onAfterRenderingGroupObservable = new Observable();\n    /**\n     * This Observable will when a mesh has been imported into the scene.\n     */\n    this.onMeshImportedObservable = new Observable();\n    /**\n     * This Observable will when an animation file has been imported into the scene.\n     */\n    this.onAnimationFileImportedObservable = new Observable();\n    // Animations\n    /** @internal */\n    this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);\n    // Pointers\n    this._pointerPickingConfiguration = new PointerPickingConfiguration();\n    /**\n     * This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).\n     * You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true\n     */\n    this.onPrePointerObservable = new Observable();\n    /**\n     * Observable event triggered each time an input event is received from the rendering canvas\n     */\n    this.onPointerObservable = new Observable();\n    // Keyboard\n    /**\n     * This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()\n     * You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true\n     */\n    this.onPreKeyboardObservable = new Observable();\n    /**\n     * Observable event triggered each time an keyboard event is received from the hosting window\n     */\n    this.onKeyboardObservable = new Observable();\n    // Coordinates system\n    this._useRightHandedSystem = false;\n    // Deterministic lockstep\n    this._timeAccumulator = 0;\n    this._currentStepId = 0;\n    this._currentInternalStep = 0;\n    // Fog\n    this._fogEnabled = true;\n    this._fogMode = Scene.FOGMODE_NONE;\n    /**\n     * Gets or sets the fog color to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * (Default is Color3(0.2, 0.2, 0.3))\n     */\n    this.fogColor = new Color3(0.2, 0.2, 0.3);\n    /**\n     * Gets or sets the fog density to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * (Default is 0.1)\n     */\n    this.fogDensity = 0.1;\n    /**\n     * Gets or sets the fog start distance to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * (Default is 0)\n     */\n    this.fogStart = 0;\n    /**\n     * Gets or sets the fog end distance to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * (Default is 1000)\n     */\n    this.fogEnd = 1000.0;\n    /**\n     * Flag indicating if we need to store previous matrices when rendering\n     */\n    this.needsPreviousWorldMatrices = false;\n    // Lights\n    this._shadowsEnabled = true;\n    this._lightsEnabled = true;\n    this._unObserveActiveCameras = null;\n    // Textures\n    this._texturesEnabled = true;\n    // Physics\n    /**\n     * Gets or sets a boolean indicating if physic engines are enabled on this scene\n     */\n    this.physicsEnabled = true;\n    // Particles\n    /**\n     * Gets or sets a boolean indicating if particles are enabled on this scene\n     */\n    this.particlesEnabled = true;\n    // Sprites\n    /**\n     * Gets or sets a boolean indicating if sprites are enabled on this scene\n     */\n    this.spritesEnabled = true;\n    // Skeletons\n    this._skeletonsEnabled = true;\n    // Lens flares\n    /**\n     * Gets or sets a boolean indicating if lens flares are enabled on this scene\n     */\n    this.lensFlaresEnabled = true;\n    // Collisions\n    /**\n     * Gets or sets a boolean indicating if collisions are enabled on this scene\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\n     */\n    this.collisionsEnabled = true;\n    /**\n     * Defines the gravity applied to this scene (used only for collisions)\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\n     */\n    this.gravity = new Vector3(0, -9.807, 0);\n    // Postprocesses\n    /**\n     * Gets or sets a boolean indicating if postprocesses are enabled on this scene\n     */\n    this.postProcessesEnabled = true;\n    // Customs render targets\n    /**\n     * Gets or sets a boolean indicating if render targets are enabled on this scene\n     */\n    this.renderTargetsEnabled = true;\n    /**\n     * Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes\n     * We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com\n     */\n    this.dumpNextRenderTargets = false;\n    /**\n     * The list of user defined render targets added to the scene\n     */\n    this.customRenderTargets = new Array();\n    /**\n     * Gets the list of meshes imported to the scene through SceneLoader\n     */\n    this.importedMeshesFiles = new Array();\n    // Probes\n    /**\n     * Gets or sets a boolean indicating if probes are enabled on this scene\n     */\n    this.probesEnabled = true;\n    this._meshesForIntersections = new SmartArrayNoDuplicate(256);\n    // Procedural textures\n    /**\n     * Gets or sets a boolean indicating if procedural textures are enabled on this scene\n     */\n    this.proceduralTexturesEnabled = true;\n    // Performance counters\n    this._totalVertices = new PerfCounter();\n    /** @internal */\n    this._activeIndices = new PerfCounter();\n    /** @internal */\n    this._activeParticles = new PerfCounter();\n    /** @internal */\n    this._activeBones = new PerfCounter();\n    /** @internal */\n    this._animationTime = 0;\n    /**\n     * Gets or sets a general scale for animation speed\n     * @see https://www.babylonjs-playground.com/#IBU2W7#3\n     */\n    this.animationTimeScale = 1;\n    this._renderId = 0;\n    this._frameId = 0;\n    this._executeWhenReadyTimeoutId = null;\n    this._intermediateRendering = false;\n    this._defaultFrameBufferCleared = false;\n    this._viewUpdateFlag = -1;\n    this._projectionUpdateFlag = -1;\n    /** @internal */\n    this._toBeDisposed = new Array(256);\n    this._activeRequests = new Array();\n    /** @internal */\n    this._pendingData = new Array();\n    this._isDisposed = false;\n    /**\n     * Gets or sets a boolean indicating that all submeshes of active meshes must be rendered\n     * Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)\n     */\n    this.dispatchAllSubMeshesOfActiveMeshes = false;\n    this._activeMeshes = new SmartArray(256);\n    this._processedMaterials = new SmartArray(256);\n    this._renderTargets = new SmartArrayNoDuplicate(256);\n    this._materialsRenderTargets = new SmartArrayNoDuplicate(256);\n    /** @internal */\n    this._activeParticleSystems = new SmartArray(256);\n    this._activeSkeletons = new SmartArrayNoDuplicate(32);\n    this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);\n    /** @internal */\n    this._activeAnimatables = new Array();\n    this._transformMatrix = Matrix.Zero();\n    /**\n     * Gets or sets a boolean indicating if lights must be sorted by priority (off by default)\n     * This is useful if there are more lights that the maximum simulteanous authorized\n     */\n    this.requireLightSorting = false;\n    /**\n     * @internal\n     * Backing store of defined scene components.\n     */\n    this._components = [];\n    /**\n     * @internal\n     * Backing store of defined scene components.\n     */\n    this._serializableComponents = [];\n    /**\n     * List of components to register on the next registration step.\n     */\n    this._transientComponents = [];\n    /**\n     * @internal\n     * Defines the actions happening before camera updates.\n     */\n    this._beforeCameraUpdateStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening before clear the canvas.\n     */\n    this._beforeClearStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening before clear the canvas.\n     */\n    this._beforeRenderTargetClearStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions when collecting render targets for the frame.\n     */\n    this._gatherRenderTargetsStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening for one camera in the frame.\n     */\n    this._gatherActiveCameraRenderTargetsStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening during the per mesh ready checks.\n     */\n    this._isReadyForMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening before evaluate active mesh checks.\n     */\n    this._beforeEvaluateActiveMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening during the evaluate sub mesh checks.\n     */\n    this._evaluateSubMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening during the active mesh stage.\n     */\n    this._preActiveMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening during the per camera render target step.\n     */\n    this._cameraDrawRenderTargetStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just before the active camera is drawing.\n     */\n    this._beforeCameraDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just before a render target is drawing.\n     */\n    this._beforeRenderTargetDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just before a rendering group is drawing.\n     */\n    this._beforeRenderingGroupDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just before a mesh is drawing.\n     */\n    this._beforeRenderingMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after a mesh has been drawn.\n     */\n    this._afterRenderingMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after a rendering group has been drawn.\n     */\n    this._afterRenderingGroupDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after the active camera has been drawn.\n     */\n    this._afterCameraDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after the post processing\n     */\n    this._afterCameraPostProcessStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after a render target has been drawn.\n     */\n    this._afterRenderTargetDrawStage = Stage.Create();\n    /**\n     * Defines the actions happening just after the post processing on a render target\n     */\n    this._afterRenderTargetPostProcessStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after rendering all cameras and computing intersections.\n     */\n    this._afterRenderStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening when a pointer move event happens.\n     */\n    this._pointerMoveStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening when a pointer down event happens.\n     */\n    this._pointerDownStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening when a pointer up event happens.\n     */\n    this._pointerUpStage = Stage.Create();\n    /**\n     * an optional map from Geometry Id to Geometry index in the 'geometries' array\n     */\n    this._geometriesByUniqueId = null;\n    this._defaultMeshCandidates = {\n      data: [],\n      length: 0\n    };\n    this._defaultSubMeshCandidates = {\n      data: [],\n      length: 0\n    };\n    this._preventFreeActiveMeshesAndRenderingGroups = false;\n    /** @internal */\n    this._activeMeshesFrozen = false;\n    /** @internal */\n    this._activeMeshesFrozenButKeepClipping = false;\n    this._skipEvaluateActiveMeshesCompletely = false;\n    /** @internal */\n    this._allowPostProcessClearColor = true;\n    /**\n     * User updatable function that will return a deterministic frame time when engine is in deterministic lock step mode\n     */\n    this.getDeterministicFrameTime = () => {\n      return this._engine.getTimeStep();\n    };\n    /** @internal */\n    this._registeredActions = 0;\n    this._blockMaterialDirtyMechanism = false;\n    /**\n     * Internal perfCollector instance used for sharing between inspector and playground.\n     * Marked as protected to allow sharing between prototype extensions, but disallow access at toplevel.\n     */\n    this._perfCollector = null;\n    this.activeCameras = new Array();\n    const fullOptions = Object.assign({\n      useGeometryUniqueIdsMap: true,\n      useMaterialMeshMap: true,\n      useClonedMeshMap: true,\n      virtual: false\n    }, options);\n    this._engine = engine || EngineStore.LastCreatedEngine;\n    if (!fullOptions.virtual) {\n      EngineStore._LastCreatedScene = this;\n      this._engine.scenes.push(this);\n    } else {\n      this._engine._virtualScenes.push(this);\n    }\n    this._uid = null;\n    this._renderingManager = new RenderingManager(this);\n    if (PostProcessManager) {\n      this.postProcessManager = new PostProcessManager(this);\n    }\n    if (IsWindowObjectExist()) {\n      this.attachControl();\n    }\n    // Uniform Buffer\n    this._createUbo();\n    // Default Image processing definition\n    if (ImageProcessingConfiguration) {\n      this._imageProcessingConfiguration = new ImageProcessingConfiguration();\n    }\n    this.setDefaultCandidateProviders();\n    if (fullOptions.useGeometryUniqueIdsMap) {\n      this._geometriesByUniqueId = {};\n    }\n    this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;\n    this.useClonedMeshMap = fullOptions.useClonedMeshMap;\n    if (!options || !options.virtual) {\n      this._engine.onNewSceneAddedObservable.notifyObservers(this);\n    }\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"Scene\" string\n   */\n  getClassName() {\n    return \"Scene\";\n  }\n  /**\n   * @internal\n   */\n  _getDefaultMeshCandidates() {\n    this._defaultMeshCandidates.data = this.meshes;\n    this._defaultMeshCandidates.length = this.meshes.length;\n    return this._defaultMeshCandidates;\n  }\n  /**\n   * @internal\n   */\n  _getDefaultSubMeshCandidates(mesh) {\n    this._defaultSubMeshCandidates.data = mesh.subMeshes;\n    this._defaultSubMeshCandidates.length = mesh.subMeshes.length;\n    return this._defaultSubMeshCandidates;\n  }\n  /**\n   * Sets the default candidate providers for the scene.\n   * This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates\n   * and getCollidingSubMeshCandidates to their default function\n   */\n  setDefaultCandidateProviders() {\n    this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this);\n    this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n    this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n    this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n  }\n  /**\n   * Gets the mesh that is currently under the pointer\n   */\n  get meshUnderPointer() {\n    return this._inputManager.meshUnderPointer;\n  }\n  /**\n   * Gets or sets the current on-screen X position of the pointer\n   */\n  get pointerX() {\n    return this._inputManager.pointerX;\n  }\n  set pointerX(value) {\n    this._inputManager.pointerX = value;\n  }\n  /**\n   * Gets or sets the current on-screen Y position of the pointer\n   */\n  get pointerY() {\n    return this._inputManager.pointerY;\n  }\n  set pointerY(value) {\n    this._inputManager.pointerY = value;\n  }\n  /**\n   * Gets the cached material (ie. the latest rendered one)\n   * @returns the cached material\n   */\n  getCachedMaterial() {\n    return this._cachedMaterial;\n  }\n  /**\n   * Gets the cached effect (ie. the latest rendered one)\n   * @returns the cached effect\n   */\n  getCachedEffect() {\n    return this._cachedEffect;\n  }\n  /**\n   * Gets the cached visibility state (ie. the latest rendered one)\n   * @returns the cached visibility state\n   */\n  getCachedVisibility() {\n    return this._cachedVisibility;\n  }\n  /**\n   * Gets a boolean indicating if the current material / effect / visibility must be bind again\n   * @param material defines the current material\n   * @param effect defines the current effect\n   * @param visibility defines the current visibility state\n   * @returns true if one parameter is not cached\n   */\n  isCachedMaterialInvalid(material, effect) {\n    let visibility = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;\n  }\n  /**\n   * Gets the engine associated with the scene\n   * @returns an Engine\n   */\n  getEngine() {\n    return this._engine;\n  }\n  /**\n   * Gets the total number of vertices rendered per frame\n   * @returns the total number of vertices rendered per frame\n   */\n  getTotalVertices() {\n    return this._totalVertices.current;\n  }\n  /**\n   * Gets the performance counter for total vertices\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n   */\n  get totalVerticesPerfCounter() {\n    return this._totalVertices;\n  }\n  /**\n   * Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)\n   * @returns the total number of active indices rendered per frame\n   */\n  getActiveIndices() {\n    return this._activeIndices.current;\n  }\n  /**\n   * Gets the performance counter for active indices\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n   */\n  get totalActiveIndicesPerfCounter() {\n    return this._activeIndices;\n  }\n  /**\n   * Gets the total number of active particles rendered per frame\n   * @returns the total number of active particles rendered per frame\n   */\n  getActiveParticles() {\n    return this._activeParticles.current;\n  }\n  /**\n   * Gets the performance counter for active particles\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n   */\n  get activeParticlesPerfCounter() {\n    return this._activeParticles;\n  }\n  /**\n   * Gets the total number of active bones rendered per frame\n   * @returns the total number of active bones rendered per frame\n   */\n  getActiveBones() {\n    return this._activeBones.current;\n  }\n  /**\n   * Gets the performance counter for active bones\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n   */\n  get activeBonesPerfCounter() {\n    return this._activeBones;\n  }\n  /**\n   * Gets the array of active meshes\n   * @returns an array of AbstractMesh\n   */\n  getActiveMeshes() {\n    return this._activeMeshes;\n  }\n  /**\n   * Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)\n   * @returns a number\n   */\n  getAnimationRatio() {\n    return this._animationRatio !== undefined ? this._animationRatio : 1;\n  }\n  /**\n   * Gets an unique Id for the current render phase\n   * @returns a number\n   */\n  getRenderId() {\n    return this._renderId;\n  }\n  /**\n   * Gets an unique Id for the current frame\n   * @returns a number\n   */\n  getFrameId() {\n    return this._frameId;\n  }\n  /** Call this function if you want to manually increment the render Id*/\n  incrementRenderId() {\n    this._renderId++;\n  }\n  _createUbo() {\n    this.setSceneUniformBuffer(this.createSceneUniformBuffer());\n  }\n  /**\n   * Use this method to simulate a pointer move on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   * @returns the current scene\n   */\n  simulatePointerMove(pickResult, pointerEventInit) {\n    this._inputManager.simulatePointerMove(pickResult, pointerEventInit);\n    return this;\n  }\n  /**\n   * Use this method to simulate a pointer down on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   * @returns the current scene\n   */\n  simulatePointerDown(pickResult, pointerEventInit) {\n    this._inputManager.simulatePointerDown(pickResult, pointerEventInit);\n    return this;\n  }\n  /**\n   * Use this method to simulate a pointer up on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)\n   * @returns the current scene\n   */\n  simulatePointerUp(pickResult, pointerEventInit, doubleTap) {\n    this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);\n    return this;\n  }\n  /**\n   * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\n   * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)\n   * @returns true if the pointer was captured\n   */\n  isPointerCaptured() {\n    let pointerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this._inputManager.isPointerCaptured(pointerId);\n  }\n  /**\n   * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\n   * @param attachUp defines if you want to attach events to pointerup\n   * @param attachDown defines if you want to attach events to pointerdown\n   * @param attachMove defines if you want to attach events to pointermove\n   */\n  attachControl() {\n    let attachUp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let attachDown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let attachMove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    this._inputManager.attachControl(attachUp, attachDown, attachMove);\n  }\n  /** Detaches all event handlers*/\n  detachControl() {\n    this._inputManager.detachControl();\n  }\n  /**\n   * This function will check if the scene can be rendered (textures are loaded, shaders are compiled)\n   * Delay loaded resources are not taking in account\n   * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: true)\n   * @returns true if all required resources are ready\n   */\n  isReady() {\n    let checkRenderTargets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var _a, _b, _c;\n    if (this._isDisposed) {\n      return false;\n    }\n    let index;\n    const engine = this.getEngine();\n    const currentRenderPassId = engine.currentRenderPassId;\n    engine.currentRenderPassId = (_b = (_a = this.activeCamera) === null || _a === void 0 ? void 0 : _a.renderPassId) !== null && _b !== void 0 ? _b : currentRenderPassId;\n    let isReady = true;\n    // Pending data\n    if (this._pendingData.length > 0) {\n      isReady = false;\n    }\n    // Ensures that the pre-pass renderer is enabled if it is to be enabled.\n    (_c = this.prePassRenderer) === null || _c === void 0 ? void 0 : _c.update();\n    // Meshes\n    if (checkRenderTargets) {\n      this._processedMaterials.reset();\n      this._materialsRenderTargets.reset();\n    }\n    for (index = 0; index < this.meshes.length; index++) {\n      const mesh = this.meshes[index];\n      if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n        continue;\n      }\n      // Do not stop at the first encountered \"unready\" object as we want to ensure\n      // all materials are starting off their compilation in parallel.\n      if (!mesh.isReady(true)) {\n        isReady = false;\n        continue;\n      }\n      const hardwareInstancedRendering = mesh.hasThinInstances || mesh.getClassName() === \"InstancedMesh\" || mesh.getClassName() === \"InstancedLinesMesh\" || engine.getCaps().instancedArrays && mesh.instances.length > 0;\n      // Is Ready For Mesh\n      for (const step of this._isReadyForMeshStage) {\n        if (!step.action(mesh, hardwareInstancedRendering)) {\n          isReady = false;\n        }\n      }\n      if (!checkRenderTargets) {\n        continue;\n      }\n      const mat = mesh.material || this.defaultMaterial;\n      if (mat) {\n        if (mat._storeEffectOnSubMeshes) {\n          for (const subMesh of mesh.subMeshes) {\n            const material = subMesh.getMaterial();\n            if (material && material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n              if (this._processedMaterials.indexOf(material) === -1) {\n                this._processedMaterials.push(material);\n                this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n              }\n            }\n          }\n        } else {\n          if (mat.hasRenderTargetTextures && mat.getRenderTargetTextures != null) {\n            if (this._processedMaterials.indexOf(mat) === -1) {\n              this._processedMaterials.push(mat);\n              this._materialsRenderTargets.concatWithNoDuplicate(mat.getRenderTargetTextures());\n            }\n          }\n        }\n      }\n    }\n    // Render targets\n    if (checkRenderTargets) {\n      for (index = 0; index < this._materialsRenderTargets.length; ++index) {\n        const rtt = this._materialsRenderTargets.data[index];\n        if (!rtt.isReadyForRendering()) {\n          isReady = false;\n        }\n      }\n    }\n    // Geometries\n    for (index = 0; index < this.geometries.length; index++) {\n      const geometry = this.geometries[index];\n      if (geometry.delayLoadState === 2) {\n        isReady = false;\n      }\n    }\n    // Post-processes\n    if (this.activeCameras && this.activeCameras.length > 0) {\n      for (const camera of this.activeCameras) {\n        if (!camera.isReady(true)) {\n          isReady = false;\n        }\n      }\n    } else if (this.activeCamera) {\n      if (!this.activeCamera.isReady(true)) {\n        isReady = false;\n      }\n    }\n    // Particles\n    for (const particleSystem of this.particleSystems) {\n      if (!particleSystem.isReady()) {\n        isReady = false;\n      }\n    }\n    // Layers\n    if (this.layers) {\n      for (const layer of this.layers) {\n        if (!layer.isReady()) {\n          isReady = false;\n        }\n      }\n    }\n    // Effects\n    if (!engine.areAllEffectsReady()) {\n      isReady = false;\n    }\n    engine.currentRenderPassId = currentRenderPassId;\n    return isReady;\n  }\n  /** Resets all cached information relative to material (including effect and visibility) */\n  resetCachedMaterial() {\n    this._cachedMaterial = null;\n    this._cachedEffect = null;\n    this._cachedVisibility = null;\n  }\n  /**\n   * Registers a function to be called before every frame render\n   * @param func defines the function to register\n   */\n  registerBeforeRender(func) {\n    this.onBeforeRenderObservable.add(func);\n  }\n  /**\n   * Unregisters a function called before every frame render\n   * @param func defines the function to unregister\n   */\n  unregisterBeforeRender(func) {\n    this.onBeforeRenderObservable.removeCallback(func);\n  }\n  /**\n   * Registers a function to be called after every frame render\n   * @param func defines the function to register\n   */\n  registerAfterRender(func) {\n    this.onAfterRenderObservable.add(func);\n  }\n  /**\n   * Unregisters a function called after every frame render\n   * @param func defines the function to unregister\n   */\n  unregisterAfterRender(func) {\n    this.onAfterRenderObservable.removeCallback(func);\n  }\n  _executeOnceBeforeRender(func) {\n    const execFunc = () => {\n      func();\n      setTimeout(() => {\n        this.unregisterBeforeRender(execFunc);\n      });\n    };\n    this.registerBeforeRender(execFunc);\n  }\n  /**\n   * The provided function will run before render once and will be disposed afterwards.\n   * A timeout delay can be provided so that the function will be executed in N ms.\n   * The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.\n   * @param func The function to be executed.\n   * @param timeout optional delay in ms\n   */\n  executeOnceBeforeRender(func, timeout) {\n    if (timeout !== undefined) {\n      setTimeout(() => {\n        this._executeOnceBeforeRender(func);\n      }, timeout);\n    } else {\n      this._executeOnceBeforeRender(func);\n    }\n  }\n  /**\n   * This function can help adding any object to the list of data awaited to be ready in order to check for a complete scene loading.\n   * @param data defines the object to wait for\n   */\n  addPendingData(data) {\n    this._pendingData.push(data);\n  }\n  /**\n   * Remove a pending data from the loading list which has previously been added with addPendingData.\n   * @param data defines the object to remove from the pending list\n   */\n  removePendingData(data) {\n    const wasLoading = this.isLoading;\n    const index = this._pendingData.indexOf(data);\n    if (index !== -1) {\n      this._pendingData.splice(index, 1);\n    }\n    if (wasLoading && !this.isLoading) {\n      this.onDataLoadedObservable.notifyObservers(this);\n    }\n  }\n  /**\n   * Returns the number of items waiting to be loaded\n   * @returns the number of items waiting to be loaded\n   */\n  getWaitingItemsCount() {\n    return this._pendingData.length;\n  }\n  /**\n   * Returns a boolean indicating if the scene is still loading data\n   */\n  get isLoading() {\n    return this._pendingData.length > 0;\n  }\n  /**\n   * Registers a function to be executed when the scene is ready\n   * @param func - the function to be executed\n   * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\n   */\n  executeWhenReady(func) {\n    let checkRenderTargets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.onReadyObservable.addOnce(func);\n    if (this._executeWhenReadyTimeoutId !== null) {\n      return;\n    }\n    this._checkIsReady(checkRenderTargets);\n  }\n  /**\n   * Returns a promise that resolves when the scene is ready\n   * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\n   * @returns A promise that resolves when the scene is ready\n   */\n  whenReadyAsync() {\n    let checkRenderTargets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return new Promise(resolve => {\n      this.executeWhenReady(() => {\n        resolve();\n      }, checkRenderTargets);\n    });\n  }\n  /**\n   * @internal\n   */\n  _checkIsReady() {\n    let checkRenderTargets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this._registerTransientComponents();\n    if (this.isReady(checkRenderTargets)) {\n      this.onReadyObservable.notifyObservers(this);\n      this.onReadyObservable.clear();\n      this._executeWhenReadyTimeoutId = null;\n      return;\n    }\n    if (this._isDisposed) {\n      this.onReadyObservable.clear();\n      this._executeWhenReadyTimeoutId = null;\n      return;\n    }\n    this._executeWhenReadyTimeoutId = setTimeout(() => {\n      // Ensure materials effects are checked outside render loops\n      this.incrementRenderId();\n      this._checkIsReady(checkRenderTargets);\n    }, 100);\n  }\n  /**\n   * Gets all animatable attached to the scene\n   */\n  get animatables() {\n    return this._activeAnimatables;\n  }\n  /**\n   * Resets the last animation time frame.\n   * Useful to override when animations start running when loading a scene for the first time.\n   */\n  resetLastAnimationTimeFrame() {\n    this._animationTimeLast = PrecisionDate.Now;\n  }\n  // Matrix\n  /**\n   * Gets the current view matrix\n   * @returns a Matrix\n   */\n  getViewMatrix() {\n    return this._viewMatrix;\n  }\n  /**\n   * Gets the current projection matrix\n   * @returns a Matrix\n   */\n  getProjectionMatrix() {\n    return this._projectionMatrix;\n  }\n  /**\n   * Gets the current transform matrix\n   * @returns a Matrix made of View * Projection\n   */\n  getTransformMatrix() {\n    return this._transformMatrix;\n  }\n  /**\n   * Sets the current transform matrix\n   * @param viewL defines the View matrix to use\n   * @param projectionL defines the Projection matrix to use\n   * @param viewR defines the right View matrix to use (if provided)\n   * @param projectionR defines the right Projection matrix to use (if provided)\n   */\n  setTransformMatrix(viewL, projectionL, viewR, projectionR) {\n    // clear the multiviewSceneUbo if no viewR and projectionR are defined\n    if (!viewR && !projectionR && this._multiviewSceneUbo) {\n      this._multiviewSceneUbo.dispose();\n      this._multiviewSceneUbo = null;\n    }\n    if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {\n      return;\n    }\n    this._viewUpdateFlag = viewL.updateFlag;\n    this._projectionUpdateFlag = projectionL.updateFlag;\n    this._viewMatrix = viewL;\n    this._projectionMatrix = projectionL;\n    this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\n    // Update frustum\n    if (!this._frustumPlanes) {\n      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);\n    } else {\n      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\n    }\n    if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {\n      this._updateMultiviewUbo(viewR, projectionR);\n    } else if (this._sceneUbo.useUbo) {\n      this._sceneUbo.updateMatrix(\"viewProjection\", this._transformMatrix);\n      this._sceneUbo.updateMatrix(\"view\", this._viewMatrix);\n      this._sceneUbo.updateMatrix(\"projection\", this._projectionMatrix);\n    }\n  }\n  /**\n   * Gets the uniform buffer used to store scene data\n   * @returns a UniformBuffer\n   */\n  getSceneUniformBuffer() {\n    return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;\n  }\n  /**\n   * Creates a scene UBO\n   * @param name name of the uniform buffer (optional, for debugging purpose only)\n   * @returns a new ubo\n   */\n  createSceneUniformBuffer(name) {\n    const sceneUbo = new UniformBuffer(this._engine, undefined, false, name !== null && name !== void 0 ? name : \"scene\");\n    sceneUbo.addUniform(\"viewProjection\", 16);\n    sceneUbo.addUniform(\"view\", 16);\n    sceneUbo.addUniform(\"projection\", 16);\n    sceneUbo.addUniform(\"vEyePosition\", 4);\n    return sceneUbo;\n  }\n  /**\n   * Sets the scene ubo\n   * @param ubo the ubo to set for the scene\n   */\n  setSceneUniformBuffer(ubo) {\n    this._sceneUbo = ubo;\n    this._viewUpdateFlag = -1;\n    this._projectionUpdateFlag = -1;\n  }\n  /**\n   * Gets an unique (relatively to the current scene) Id\n   * @returns an unique number for the scene\n   */\n  getUniqueId() {\n    return UniqueIdGenerator.UniqueId;\n  }\n  /**\n   * Add a mesh to the list of scene's meshes\n   * @param newMesh defines the mesh to add\n   * @param recursive if all child meshes should also be added to the scene\n   */\n  addMesh(newMesh) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.meshes.push(newMesh);\n    newMesh._resyncLightSources();\n    if (!newMesh.parent) {\n      newMesh._addToSceneRootNodes();\n    }\n    this.onNewMeshAddedObservable.notifyObservers(newMesh);\n    if (recursive) {\n      newMesh.getChildMeshes().forEach(m => {\n        this.addMesh(m);\n      });\n    }\n  }\n  /**\n   * Remove a mesh for the list of scene's meshes\n   * @param toRemove defines the mesh to remove\n   * @param recursive if all child meshes should also be removed from the scene\n   * @returns the index where the mesh was in the mesh list\n   */\n  removeMesh(toRemove) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const index = this.meshes.indexOf(toRemove);\n    if (index !== -1) {\n      // Remove from the scene if mesh found\n      this.meshes[index] = this.meshes[this.meshes.length - 1];\n      this.meshes.pop();\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n    this._inputManager._invalidateMesh(toRemove);\n    this.onMeshRemovedObservable.notifyObservers(toRemove);\n    if (recursive) {\n      toRemove.getChildMeshes().forEach(m => {\n        this.removeMesh(m);\n      });\n    }\n    return index;\n  }\n  /**\n   * Add a transform node to the list of scene's transform nodes\n   * @param newTransformNode defines the transform node to add\n   */\n  addTransformNode(newTransformNode) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    if (newTransformNode.getScene() === this && newTransformNode._indexInSceneTransformNodesArray !== -1) {\n      // Already there?\n      return;\n    }\n    newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;\n    this.transformNodes.push(newTransformNode);\n    if (!newTransformNode.parent) {\n      newTransformNode._addToSceneRootNodes();\n    }\n    this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);\n  }\n  /**\n   * Remove a transform node for the list of scene's transform nodes\n   * @param toRemove defines the transform node to remove\n   * @returns the index where the transform node was in the transform node list\n   */\n  removeTransformNode(toRemove) {\n    const index = toRemove._indexInSceneTransformNodesArray;\n    if (index !== -1) {\n      if (index !== this.transformNodes.length - 1) {\n        const lastNode = this.transformNodes[this.transformNodes.length - 1];\n        this.transformNodes[index] = lastNode;\n        lastNode._indexInSceneTransformNodesArray = index;\n      }\n      toRemove._indexInSceneTransformNodesArray = -1;\n      this.transformNodes.pop();\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n    this.onTransformNodeRemovedObservable.notifyObservers(toRemove);\n    return index;\n  }\n  /**\n   * Remove a skeleton for the list of scene's skeletons\n   * @param toRemove defines the skeleton to remove\n   * @returns the index where the skeleton was in the skeleton list\n   */\n  removeSkeleton(toRemove) {\n    const index = this.skeletons.indexOf(toRemove);\n    if (index !== -1) {\n      // Remove from the scene if found\n      this.skeletons.splice(index, 1);\n      this.onSkeletonRemovedObservable.notifyObservers(toRemove);\n      // Clean active container\n      this._executeActiveContainerCleanup(this._activeSkeletons);\n    }\n    return index;\n  }\n  /**\n   * Remove a morph target for the list of scene's morph targets\n   * @param toRemove defines the morph target to remove\n   * @returns the index where the morph target was in the morph target list\n   */\n  removeMorphTargetManager(toRemove) {\n    const index = this.morphTargetManagers.indexOf(toRemove);\n    if (index !== -1) {\n      // Remove from the scene if found\n      this.morphTargetManagers.splice(index, 1);\n    }\n    return index;\n  }\n  /**\n   * Remove a light for the list of scene's lights\n   * @param toRemove defines the light to remove\n   * @returns the index where the light was in the light list\n   */\n  removeLight(toRemove) {\n    const index = this.lights.indexOf(toRemove);\n    if (index !== -1) {\n      // Remove from meshes\n      for (const mesh of this.meshes) {\n        mesh._removeLightSource(toRemove, false);\n      }\n      // Remove from the scene if mesh found\n      this.lights.splice(index, 1);\n      this.sortLightsByPriority();\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n    this.onLightRemovedObservable.notifyObservers(toRemove);\n    return index;\n  }\n  /**\n   * Remove a camera for the list of scene's cameras\n   * @param toRemove defines the camera to remove\n   * @returns the index where the camera was in the camera list\n   */\n  removeCamera(toRemove) {\n    const index = this.cameras.indexOf(toRemove);\n    if (index !== -1) {\n      // Remove from the scene if mesh found\n      this.cameras.splice(index, 1);\n      if (!toRemove.parent) {\n        toRemove._removeFromSceneRootNodes();\n      }\n    }\n    // Remove from activeCameras\n    if (this.activeCameras) {\n      const index2 = this.activeCameras.indexOf(toRemove);\n      if (index2 !== -1) {\n        // Remove from the scene if mesh found\n        this.activeCameras.splice(index2, 1);\n      }\n    }\n    // Reset the activeCamera\n    if (this.activeCamera === toRemove) {\n      if (this.cameras.length > 0) {\n        this.activeCamera = this.cameras[0];\n      } else {\n        this.activeCamera = null;\n      }\n    }\n    this.onCameraRemovedObservable.notifyObservers(toRemove);\n    return index;\n  }\n  /**\n   * Remove a particle system for the list of scene's particle systems\n   * @param toRemove defines the particle system to remove\n   * @returns the index where the particle system was in the particle system list\n   */\n  removeParticleSystem(toRemove) {\n    const index = this.particleSystems.indexOf(toRemove);\n    if (index !== -1) {\n      this.particleSystems.splice(index, 1);\n      // Clean active container\n      this._executeActiveContainerCleanup(this._activeParticleSystems);\n    }\n    return index;\n  }\n  /**\n   * Remove a animation for the list of scene's animations\n   * @param toRemove defines the animation to remove\n   * @returns the index where the animation was in the animation list\n   */\n  removeAnimation(toRemove) {\n    const index = this.animations.indexOf(toRemove);\n    if (index !== -1) {\n      this.animations.splice(index, 1);\n    }\n    return index;\n  }\n  /**\n   * Will stop the animation of the given target\n   * @param target - the target\n   * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\n   * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n   */\n  stopAnimation(target, animationName, targetMask) {\n    // Do nothing as code will be provided by animation component\n  }\n  /**\n   * Removes the given animation group from this scene.\n   * @param toRemove The animation group to remove\n   * @returns The index of the removed animation group\n   */\n  removeAnimationGroup(toRemove) {\n    const index = this.animationGroups.indexOf(toRemove);\n    if (index !== -1) {\n      this.animationGroups.splice(index, 1);\n    }\n    return index;\n  }\n  /**\n   * Removes the given multi-material from this scene.\n   * @param toRemove The multi-material to remove\n   * @returns The index of the removed multi-material\n   */\n  removeMultiMaterial(toRemove) {\n    const index = this.multiMaterials.indexOf(toRemove);\n    if (index !== -1) {\n      this.multiMaterials.splice(index, 1);\n    }\n    this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);\n    return index;\n  }\n  /**\n   * Removes the given material from this scene.\n   * @param toRemove The material to remove\n   * @returns The index of the removed material\n   */\n  removeMaterial(toRemove) {\n    const index = toRemove._indexInSceneMaterialArray;\n    if (index !== -1 && index < this.materials.length) {\n      if (index !== this.materials.length - 1) {\n        const lastMaterial = this.materials[this.materials.length - 1];\n        this.materials[index] = lastMaterial;\n        lastMaterial._indexInSceneMaterialArray = index;\n      }\n      toRemove._indexInSceneMaterialArray = -1;\n      this.materials.pop();\n    }\n    this.onMaterialRemovedObservable.notifyObservers(toRemove);\n    return index;\n  }\n  /**\n   * Removes the given action manager from this scene.\n   * @deprecated\n   * @param toRemove The action manager to remove\n   * @returns The index of the removed action manager\n   */\n  removeActionManager(toRemove) {\n    const index = this.actionManagers.indexOf(toRemove);\n    if (index !== -1) {\n      this.actionManagers.splice(index, 1);\n    }\n    return index;\n  }\n  /**\n   * Removes the given texture from this scene.\n   * @param toRemove The texture to remove\n   * @returns The index of the removed texture\n   */\n  removeTexture(toRemove) {\n    const index = this.textures.indexOf(toRemove);\n    if (index !== -1) {\n      this.textures.splice(index, 1);\n    }\n    this.onTextureRemovedObservable.notifyObservers(toRemove);\n    return index;\n  }\n  /**\n   * Adds the given light to this scene\n   * @param newLight The light to add\n   */\n  addLight(newLight) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.lights.push(newLight);\n    this.sortLightsByPriority();\n    if (!newLight.parent) {\n      newLight._addToSceneRootNodes();\n    }\n    // Add light to all meshes (To support if the light is removed and then re-added)\n    for (const mesh of this.meshes) {\n      if (mesh.lightSources.indexOf(newLight) === -1) {\n        mesh.lightSources.push(newLight);\n        mesh._resyncLightSources();\n      }\n    }\n    this.onNewLightAddedObservable.notifyObservers(newLight);\n  }\n  /**\n   * Sorts the list list based on light priorities\n   */\n  sortLightsByPriority() {\n    if (this.requireLightSorting) {\n      this.lights.sort(LightConstants.CompareLightsPriority);\n    }\n  }\n  /**\n   * Adds the given camera to this scene\n   * @param newCamera The camera to add\n   */\n  addCamera(newCamera) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.cameras.push(newCamera);\n    this.onNewCameraAddedObservable.notifyObservers(newCamera);\n    if (!newCamera.parent) {\n      newCamera._addToSceneRootNodes();\n    }\n  }\n  /**\n   * Adds the given skeleton to this scene\n   * @param newSkeleton The skeleton to add\n   */\n  addSkeleton(newSkeleton) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.skeletons.push(newSkeleton);\n    this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);\n  }\n  /**\n   * Adds the given particle system to this scene\n   * @param newParticleSystem The particle system to add\n   */\n  addParticleSystem(newParticleSystem) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.particleSystems.push(newParticleSystem);\n  }\n  /**\n   * Adds the given animation to this scene\n   * @param newAnimation The animation to add\n   */\n  addAnimation(newAnimation) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.animations.push(newAnimation);\n  }\n  /**\n   * Adds the given animation group to this scene.\n   * @param newAnimationGroup The animation group to add\n   */\n  addAnimationGroup(newAnimationGroup) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.animationGroups.push(newAnimationGroup);\n  }\n  /**\n   * Adds the given multi-material to this scene\n   * @param newMultiMaterial The multi-material to add\n   */\n  addMultiMaterial(newMultiMaterial) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.multiMaterials.push(newMultiMaterial);\n    this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);\n  }\n  /**\n   * Adds the given material to this scene\n   * @param newMaterial The material to add\n   */\n  addMaterial(newMaterial) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    if (newMaterial.getScene() === this && newMaterial._indexInSceneMaterialArray !== -1) {\n      // Already there??\n      return;\n    }\n    newMaterial._indexInSceneMaterialArray = this.materials.length;\n    this.materials.push(newMaterial);\n    this.onNewMaterialAddedObservable.notifyObservers(newMaterial);\n  }\n  /**\n   * Adds the given morph target to this scene\n   * @param newMorphTargetManager The morph target to add\n   */\n  addMorphTargetManager(newMorphTargetManager) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.morphTargetManagers.push(newMorphTargetManager);\n  }\n  /**\n   * Adds the given geometry to this scene\n   * @param newGeometry The geometry to add\n   */\n  addGeometry(newGeometry) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    if (this._geometriesByUniqueId) {\n      this._geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;\n    }\n    this.geometries.push(newGeometry);\n  }\n  /**\n   * Adds the given action manager to this scene\n   * @deprecated\n   * @param newActionManager The action manager to add\n   */\n  addActionManager(newActionManager) {\n    this.actionManagers.push(newActionManager);\n  }\n  /**\n   * Adds the given texture to this scene.\n   * @param newTexture The texture to add\n   */\n  addTexture(newTexture) {\n    if (this._blockEntityCollection) {\n      return;\n    }\n    this.textures.push(newTexture);\n    this.onNewTextureAddedObservable.notifyObservers(newTexture);\n  }\n  /**\n   * Switch active camera\n   * @param newCamera defines the new active camera\n   * @param attachControl defines if attachControl must be called for the new active camera (default: true)\n   */\n  switchActiveCamera(newCamera) {\n    let attachControl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const canvas = this._engine.getInputElement();\n    if (!canvas) {\n      return;\n    }\n    if (this.activeCamera) {\n      this.activeCamera.detachControl();\n    }\n    this.activeCamera = newCamera;\n    if (attachControl) {\n      newCamera.attachControl();\n    }\n  }\n  /**\n   * sets the active camera of the scene using its Id\n   * @param id defines the camera's Id\n   * @returns the new active camera or null if none found.\n   */\n  setActiveCameraById(id) {\n    const camera = this.getCameraById(id);\n    if (camera) {\n      this.activeCamera = camera;\n      return camera;\n    }\n    return null;\n  }\n  /**\n   * sets the active camera of the scene using its name\n   * @param name defines the camera's name\n   * @returns the new active camera or null if none found.\n   */\n  setActiveCameraByName(name) {\n    const camera = this.getCameraByName(name);\n    if (camera) {\n      this.activeCamera = camera;\n      return camera;\n    }\n    return null;\n  }\n  /**\n   * get an animation group using its name\n   * @param name defines the material's name\n   * @returns the animation group or null if none found.\n   */\n  getAnimationGroupByName(name) {\n    for (let index = 0; index < this.animationGroups.length; index++) {\n      if (this.animationGroups[index].name === name) {\n        return this.animationGroups[index];\n      }\n    }\n    return null;\n  }\n  _getMaterial(allowMultiMaterials, predicate) {\n    for (let index = 0; index < this.materials.length; index++) {\n      const material = this.materials[index];\n      if (predicate(material)) {\n        return material;\n      }\n    }\n    if (allowMultiMaterials) {\n      for (let index = 0; index < this.multiMaterials.length; index++) {\n        const material = this.multiMaterials[index];\n        if (predicate(material)) {\n          return material;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Get a material using its unique id\n   * @param uniqueId defines the material's unique id\n   * @param allowMultiMaterials determines whether multimaterials should be considered\n   * @returns the material or null if none found.\n   */\n  getMaterialByUniqueID(uniqueId) {\n    let allowMultiMaterials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return this._getMaterial(allowMultiMaterials, m => m.uniqueId === uniqueId);\n  }\n  /**\n   * get a material using its id\n   * @param id defines the material's Id\n   * @param allowMultiMaterials determines whether multimaterials should be considered\n   * @returns the material or null if none found.\n   */\n  getMaterialById(id) {\n    let allowMultiMaterials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return this._getMaterial(allowMultiMaterials, m => m.id === id);\n  }\n  /**\n   * Gets a material using its name\n   * @param name defines the material's name\n   * @param allowMultiMaterials determines whether multimaterials should be considered\n   * @returns the material or null if none found.\n   */\n  getMaterialByName(name) {\n    let allowMultiMaterials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return this._getMaterial(allowMultiMaterials, m => m.name === name);\n  }\n  /**\n   * Gets a last added material using a given id\n   * @param id defines the material's id\n   * @param allowMultiMaterials determines whether multimaterials should be considered\n   * @returns the last material with the given id or null if none found.\n   */\n  getLastMaterialById(id) {\n    let allowMultiMaterials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    for (let index = this.materials.length - 1; index >= 0; index--) {\n      if (this.materials[index].id === id) {\n        return this.materials[index];\n      }\n    }\n    if (allowMultiMaterials) {\n      for (let index = this.multiMaterials.length - 1; index >= 0; index--) {\n        if (this.multiMaterials[index].id === id) {\n          return this.multiMaterials[index];\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Get a texture using its unique id\n   * @param uniqueId defines the texture's unique id\n   * @returns the texture or null if none found.\n   */\n  getTextureByUniqueId(uniqueId) {\n    for (let index = 0; index < this.textures.length; index++) {\n      if (this.textures[index].uniqueId === uniqueId) {\n        return this.textures[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a texture using its name\n   * @param name defines the texture's name\n   * @returns the texture or null if none found.\n   */\n  getTextureByName(name) {\n    for (let index = 0; index < this.textures.length; index++) {\n      if (this.textures[index].name === name) {\n        return this.textures[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a camera using its Id\n   * @param id defines the Id to look for\n   * @returns the camera or null if not found\n   */\n  getCameraById(id) {\n    for (let index = 0; index < this.cameras.length; index++) {\n      if (this.cameras[index].id === id) {\n        return this.cameras[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a camera using its unique Id\n   * @param uniqueId defines the unique Id to look for\n   * @returns the camera or null if not found\n   */\n  getCameraByUniqueId(uniqueId) {\n    for (let index = 0; index < this.cameras.length; index++) {\n      if (this.cameras[index].uniqueId === uniqueId) {\n        return this.cameras[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a camera using its name\n   * @param name defines the camera's name\n   * @returns the camera or null if none found.\n   */\n  getCameraByName(name) {\n    for (let index = 0; index < this.cameras.length; index++) {\n      if (this.cameras[index].name === name) {\n        return this.cameras[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a bone using its Id\n   * @param id defines the bone's Id\n   * @returns the bone or null if not found\n   */\n  getBoneById(id) {\n    for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n      const skeleton = this.skeletons[skeletonIndex];\n      for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n        if (skeleton.bones[boneIndex].id === id) {\n          return skeleton.bones[boneIndex];\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a bone using its id\n   * @param name defines the bone's name\n   * @returns the bone or null if not found\n   */\n  getBoneByName(name) {\n    for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n      const skeleton = this.skeletons[skeletonIndex];\n      for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n        if (skeleton.bones[boneIndex].name === name) {\n          return skeleton.bones[boneIndex];\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a light node using its name\n   * @param name defines the the light's name\n   * @returns the light or null if none found.\n   */\n  getLightByName(name) {\n    for (let index = 0; index < this.lights.length; index++) {\n      if (this.lights[index].name === name) {\n        return this.lights[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a light node using its Id\n   * @param id defines the light's Id\n   * @returns the light or null if none found.\n   */\n  getLightById(id) {\n    for (let index = 0; index < this.lights.length; index++) {\n      if (this.lights[index].id === id) {\n        return this.lights[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a light node using its scene-generated unique Id\n   * @param uniqueId defines the light's unique Id\n   * @returns the light or null if none found.\n   */\n  getLightByUniqueId(uniqueId) {\n    for (let index = 0; index < this.lights.length; index++) {\n      if (this.lights[index].uniqueId === uniqueId) {\n        return this.lights[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a particle system by Id\n   * @param id defines the particle system Id\n   * @returns the corresponding system or null if none found\n   */\n  getParticleSystemById(id) {\n    for (let index = 0; index < this.particleSystems.length; index++) {\n      if (this.particleSystems[index].id === id) {\n        return this.particleSystems[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a geometry using its Id\n   * @param id defines the geometry's Id\n   * @returns the geometry or null if none found.\n   */\n  getGeometryById(id) {\n    for (let index = 0; index < this.geometries.length; index++) {\n      if (this.geometries[index].id === id) {\n        return this.geometries[index];\n      }\n    }\n    return null;\n  }\n  _getGeometryByUniqueId(uniqueId) {\n    if (this._geometriesByUniqueId) {\n      const index = this._geometriesByUniqueId[uniqueId];\n      if (index !== undefined) {\n        return this.geometries[index];\n      }\n    } else {\n      for (let index = 0; index < this.geometries.length; index++) {\n        if (this.geometries[index].uniqueId === uniqueId) {\n          return this.geometries[index];\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Add a new geometry to this scene\n   * @param geometry defines the geometry to be added to the scene.\n   * @param force defines if the geometry must be pushed even if a geometry with this id already exists\n   * @returns a boolean defining if the geometry was added or not\n   */\n  pushGeometry(geometry, force) {\n    if (!force && this._getGeometryByUniqueId(geometry.uniqueId)) {\n      return false;\n    }\n    this.addGeometry(geometry);\n    this.onNewGeometryAddedObservable.notifyObservers(geometry);\n    return true;\n  }\n  /**\n   * Removes an existing geometry\n   * @param geometry defines the geometry to be removed from the scene\n   * @returns a boolean defining if the geometry was removed or not\n   */\n  removeGeometry(geometry) {\n    let index;\n    if (this._geometriesByUniqueId) {\n      index = this._geometriesByUniqueId[geometry.uniqueId];\n      if (index === undefined) {\n        return false;\n      }\n    } else {\n      index = this.geometries.indexOf(geometry);\n      if (index < 0) {\n        return false;\n      }\n    }\n    if (index !== this.geometries.length - 1) {\n      const lastGeometry = this.geometries[this.geometries.length - 1];\n      if (lastGeometry) {\n        this.geometries[index] = lastGeometry;\n        if (this._geometriesByUniqueId) {\n          this._geometriesByUniqueId[lastGeometry.uniqueId] = index;\n        }\n      }\n    }\n    if (this._geometriesByUniqueId) {\n      this._geometriesByUniqueId[geometry.uniqueId] = undefined;\n    }\n    this.geometries.pop();\n    this.onGeometryRemovedObservable.notifyObservers(geometry);\n    return true;\n  }\n  /**\n   * Gets the list of geometries attached to the scene\n   * @returns an array of Geometry\n   */\n  getGeometries() {\n    return this.geometries;\n  }\n  /**\n   * Gets the first added mesh found of a given Id\n   * @param id defines the Id to search for\n   * @returns the mesh found or null if not found at all\n   */\n  getMeshById(id) {\n    for (let index = 0; index < this.meshes.length; index++) {\n      if (this.meshes[index].id === id) {\n        return this.meshes[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a list of meshes using their Id\n   * @param id defines the Id to search for\n   * @returns a list of meshes\n   */\n  getMeshesById(id) {\n    return this.meshes.filter(function (m) {\n      return m.id === id;\n    });\n  }\n  /**\n   * Gets the first added transform node found of a given Id\n   * @param id defines the Id to search for\n   * @returns the found transform node or null if not found at all.\n   */\n  getTransformNodeById(id) {\n    for (let index = 0; index < this.transformNodes.length; index++) {\n      if (this.transformNodes[index].id === id) {\n        return this.transformNodes[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a transform node with its auto-generated unique Id\n   * @param uniqueId defines the unique Id to search for\n   * @returns the found transform node or null if not found at all.\n   */\n  getTransformNodeByUniqueId(uniqueId) {\n    for (let index = 0; index < this.transformNodes.length; index++) {\n      if (this.transformNodes[index].uniqueId === uniqueId) {\n        return this.transformNodes[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a list of transform nodes using their Id\n   * @param id defines the Id to search for\n   * @returns a list of transform nodes\n   */\n  getTransformNodesById(id) {\n    return this.transformNodes.filter(function (m) {\n      return m.id === id;\n    });\n  }\n  /**\n   * Gets a mesh with its auto-generated unique Id\n   * @param uniqueId defines the unique Id to search for\n   * @returns the found mesh or null if not found at all.\n   */\n  getMeshByUniqueId(uniqueId) {\n    for (let index = 0; index < this.meshes.length; index++) {\n      if (this.meshes[index].uniqueId === uniqueId) {\n        return this.meshes[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a the last added mesh using a given Id\n   * @param id defines the Id to search for\n   * @returns the found mesh or null if not found at all.\n   */\n  getLastMeshById(id) {\n    for (let index = this.meshes.length - 1; index >= 0; index--) {\n      if (this.meshes[index].id === id) {\n        return this.meshes[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a the last transform node using a given Id\n   * @param id defines the Id to search for\n   * @returns the found mesh or null if not found at all.\n   */\n  getLastTransformNodeById(id) {\n    for (let index = this.transformNodes.length - 1; index >= 0; index--) {\n      if (this.transformNodes[index].id === id) {\n        return this.transformNodes[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a the last added node (Mesh, Camera, Light) using a given Id\n   * @param id defines the Id to search for\n   * @returns the found node or null if not found at all\n   */\n  getLastEntryById(id) {\n    let index;\n    for (index = this.meshes.length - 1; index >= 0; index--) {\n      if (this.meshes[index].id === id) {\n        return this.meshes[index];\n      }\n    }\n    for (index = this.transformNodes.length - 1; index >= 0; index--) {\n      if (this.transformNodes[index].id === id) {\n        return this.transformNodes[index];\n      }\n    }\n    for (index = this.cameras.length - 1; index >= 0; index--) {\n      if (this.cameras[index].id === id) {\n        return this.cameras[index];\n      }\n    }\n    for (index = this.lights.length - 1; index >= 0; index--) {\n      if (this.lights[index].id === id) {\n        return this.lights[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a node (Mesh, Camera, Light) using a given Id\n   * @param id defines the Id to search for\n   * @returns the found node or null if not found at all\n   */\n  getNodeById(id) {\n    const mesh = this.getMeshById(id);\n    if (mesh) {\n      return mesh;\n    }\n    const transformNode = this.getTransformNodeById(id);\n    if (transformNode) {\n      return transformNode;\n    }\n    const light = this.getLightById(id);\n    if (light) {\n      return light;\n    }\n    const camera = this.getCameraById(id);\n    if (camera) {\n      return camera;\n    }\n    const bone = this.getBoneById(id);\n    if (bone) {\n      return bone;\n    }\n    return null;\n  }\n  /**\n   * Gets a node (Mesh, Camera, Light) using a given name\n   * @param name defines the name to search for\n   * @returns the found node or null if not found at all.\n   */\n  getNodeByName(name) {\n    const mesh = this.getMeshByName(name);\n    if (mesh) {\n      return mesh;\n    }\n    const transformNode = this.getTransformNodeByName(name);\n    if (transformNode) {\n      return transformNode;\n    }\n    const light = this.getLightByName(name);\n    if (light) {\n      return light;\n    }\n    const camera = this.getCameraByName(name);\n    if (camera) {\n      return camera;\n    }\n    const bone = this.getBoneByName(name);\n    if (bone) {\n      return bone;\n    }\n    return null;\n  }\n  /**\n   * Gets a mesh using a given name\n   * @param name defines the name to search for\n   * @returns the found mesh or null if not found at all.\n   */\n  getMeshByName(name) {\n    for (let index = 0; index < this.meshes.length; index++) {\n      if (this.meshes[index].name === name) {\n        return this.meshes[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a transform node using a given name\n   * @param name defines the name to search for\n   * @returns the found transform node or null if not found at all.\n   */\n  getTransformNodeByName(name) {\n    for (let index = 0; index < this.transformNodes.length; index++) {\n      if (this.transformNodes[index].name === name) {\n        return this.transformNodes[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a skeleton using a given Id (if many are found, this function will pick the last one)\n   * @param id defines the Id to search for\n   * @returns the found skeleton or null if not found at all.\n   */\n  getLastSkeletonById(id) {\n    for (let index = this.skeletons.length - 1; index >= 0; index--) {\n      if (this.skeletons[index].id === id) {\n        return this.skeletons[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a skeleton using a given auto generated unique id\n   * @param  uniqueId defines the unique id to search for\n   * @returns the found skeleton or null if not found at all.\n   */\n  getSkeletonByUniqueId(uniqueId) {\n    for (let index = 0; index < this.skeletons.length; index++) {\n      if (this.skeletons[index].uniqueId === uniqueId) {\n        return this.skeletons[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a skeleton using a given id (if many are found, this function will pick the first one)\n   * @param id defines the id to search for\n   * @returns the found skeleton or null if not found at all.\n   */\n  getSkeletonById(id) {\n    for (let index = 0; index < this.skeletons.length; index++) {\n      if (this.skeletons[index].id === id) {\n        return this.skeletons[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a skeleton using a given name\n   * @param name defines the name to search for\n   * @returns the found skeleton or null if not found at all.\n   */\n  getSkeletonByName(name) {\n    for (let index = 0; index < this.skeletons.length; index++) {\n      if (this.skeletons[index].name === name) {\n        return this.skeletons[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a morph target manager  using a given id (if many are found, this function will pick the last one)\n   * @param id defines the id to search for\n   * @returns the found morph target manager or null if not found at all.\n   */\n  getMorphTargetManagerById(id) {\n    for (let index = 0; index < this.morphTargetManagers.length; index++) {\n      if (this.morphTargetManagers[index].uniqueId === id) {\n        return this.morphTargetManagers[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a morph target using a given id (if many are found, this function will pick the first one)\n   * @param id defines the id to search for\n   * @returns the found morph target or null if not found at all.\n   */\n  getMorphTargetById(id) {\n    for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n      const morphTargetManager = this.morphTargetManagers[managerIndex];\n      for (let index = 0; index < morphTargetManager.numTargets; ++index) {\n        const target = morphTargetManager.getTarget(index);\n        if (target.id === id) {\n          return target;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a morph target using a given name (if many are found, this function will pick the first one)\n   * @param name defines the name to search for\n   * @returns the found morph target or null if not found at all.\n   */\n  getMorphTargetByName(name) {\n    for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n      const morphTargetManager = this.morphTargetManagers[managerIndex];\n      for (let index = 0; index < morphTargetManager.numTargets; ++index) {\n        const target = morphTargetManager.getTarget(index);\n        if (target.name === name) {\n          return target;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a post process using a given name (if many are found, this function will pick the first one)\n   * @param name defines the name to search for\n   * @returns the found post process or null if not found at all.\n   */\n  getPostProcessByName(name) {\n    for (let postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {\n      const postProcess = this.postProcesses[postProcessIndex];\n      if (postProcess.name === name) {\n        return postProcess;\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets a boolean indicating if the given mesh is active\n   * @param mesh defines the mesh to look for\n   * @returns true if the mesh is in the active list\n   */\n  isActiveMesh(mesh) {\n    return this._activeMeshes.indexOf(mesh) !== -1;\n  }\n  /**\n   * Return a unique id as a string which can serve as an identifier for the scene\n   */\n  get uid() {\n    if (!this._uid) {\n      this._uid = Tools.RandomId();\n    }\n    return this._uid;\n  }\n  /**\n   * Add an externally attached data from its key.\n   * This method call will fail and return false, if such key already exists.\n   * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.\n   * @param key the unique key that identifies the data\n   * @param data the data object to associate to the key for this Engine instance\n   * @returns true if no such key were already present and the data was added successfully, false otherwise\n   */\n  addExternalData(key, data) {\n    if (!this._externalData) {\n      this._externalData = new StringDictionary();\n    }\n    return this._externalData.add(key, data);\n  }\n  /**\n   * Get an externally attached data from its key\n   * @param key the unique key that identifies the data\n   * @returns the associated data, if present (can be null), or undefined if not present\n   */\n  getExternalData(key) {\n    if (!this._externalData) {\n      return null;\n    }\n    return this._externalData.get(key);\n  }\n  /**\n   * Get an externally attached data from its key, create it using a factory if it's not already present\n   * @param key the unique key that identifies the data\n   * @param factory the factory that will be called to create the instance if and only if it doesn't exists\n   * @returns the associated data, can be null if the factory returned null.\n   */\n  getOrAddExternalDataWithFactory(key, factory) {\n    if (!this._externalData) {\n      this._externalData = new StringDictionary();\n    }\n    return this._externalData.getOrAddWithFactory(key, factory);\n  }\n  /**\n   * Remove an externally attached data from the Engine instance\n   * @param key the unique key that identifies the data\n   * @returns true if the data was successfully removed, false if it doesn't exist\n   */\n  removeExternalData(key) {\n    return this._externalData.remove(key);\n  }\n  _evaluateSubMesh(subMesh, mesh, initialMesh, forcePush) {\n    if (forcePush || subMesh.isInFrustum(this._frustumPlanes)) {\n      for (const step of this._evaluateSubMeshStage) {\n        step.action(mesh, subMesh);\n      }\n      const material = subMesh.getMaterial();\n      if (material !== null && material !== undefined) {\n        // Render targets\n        if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n          if (this._processedMaterials.indexOf(material) === -1) {\n            this._processedMaterials.push(material);\n            this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n          }\n        }\n        // Dispatch\n        this._renderingManager.dispatch(subMesh, mesh, material);\n      }\n    }\n  }\n  /**\n   * Clear the processed materials smart array preventing retention point in material dispose.\n   */\n  freeProcessedMaterials() {\n    this._processedMaterials.dispose();\n  }\n  /** Gets or sets a boolean blocking all the calls to freeActiveMeshes and freeRenderingGroups\n   * It can be used in order to prevent going through methods freeRenderingGroups and freeActiveMeshes several times to improve performance\n   * when disposing several meshes in a row or a hierarchy of meshes.\n   * When used, it is the responsibility of the user to blockfreeActiveMeshesAndRenderingGroups back to false.\n   */\n  get blockfreeActiveMeshesAndRenderingGroups() {\n    return this._preventFreeActiveMeshesAndRenderingGroups;\n  }\n  set blockfreeActiveMeshesAndRenderingGroups(value) {\n    if (this._preventFreeActiveMeshesAndRenderingGroups === value) {\n      return;\n    }\n    if (value) {\n      this.freeActiveMeshes();\n      this.freeRenderingGroups();\n    }\n    this._preventFreeActiveMeshesAndRenderingGroups = value;\n  }\n  /**\n   * Clear the active meshes smart array preventing retention point in mesh dispose.\n   */\n  freeActiveMeshes() {\n    if (this.blockfreeActiveMeshesAndRenderingGroups) {\n      return;\n    }\n    this._activeMeshes.dispose();\n    if (this.activeCamera && this.activeCamera._activeMeshes) {\n      this.activeCamera._activeMeshes.dispose();\n    }\n    if (this.activeCameras) {\n      for (let i = 0; i < this.activeCameras.length; i++) {\n        const activeCamera = this.activeCameras[i];\n        if (activeCamera && activeCamera._activeMeshes) {\n          activeCamera._activeMeshes.dispose();\n        }\n      }\n    }\n  }\n  /**\n   * Clear the info related to rendering groups preventing retention points during dispose.\n   */\n  freeRenderingGroups() {\n    if (this.blockfreeActiveMeshesAndRenderingGroups) {\n      return;\n    }\n    if (this._renderingManager) {\n      this._renderingManager.freeRenderingGroups();\n    }\n    if (this.textures) {\n      for (let i = 0; i < this.textures.length; i++) {\n        const texture = this.textures[i];\n        if (texture && texture.renderList) {\n          texture.freeRenderingGroups();\n        }\n      }\n    }\n  }\n  /** @internal */\n  _isInIntermediateRendering() {\n    return this._intermediateRendering;\n  }\n  /**\n   * Use this function to stop evaluating active meshes. The current list will be keep alive between frames\n   * @param skipEvaluateActiveMeshes defines an optional boolean indicating that the evaluate active meshes step must be completely skipped\n   * @param onSuccess optional success callback\n   * @param onError optional error callback\n   * @param freezeMeshes defines if meshes should be frozen (true by default)\n   * @param keepFrustumCulling defines if you want to keep running the frustum clipping (false by default)\n   * @returns the current scene\n   */\n  freezeActiveMeshes() {\n    let skipEvaluateActiveMeshes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let onSuccess = arguments.length > 1 ? arguments[1] : undefined;\n    let onError = arguments.length > 2 ? arguments[2] : undefined;\n    let freezeMeshes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let keepFrustumCulling = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    this.executeWhenReady(() => {\n      if (!this.activeCamera) {\n        onError && onError(\"No active camera found\");\n        return;\n      }\n      if (!this._frustumPlanes) {\n        this.updateTransformMatrix();\n      }\n      this._evaluateActiveMeshes();\n      this._activeMeshesFrozen = true;\n      this._activeMeshesFrozenButKeepClipping = keepFrustumCulling;\n      this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;\n      if (freezeMeshes) {\n        for (let index = 0; index < this._activeMeshes.length; index++) {\n          this._activeMeshes.data[index]._freeze();\n        }\n      }\n      onSuccess && onSuccess();\n    });\n    return this;\n  }\n  /**\n   * Use this function to restart evaluating active meshes on every frame\n   * @returns the current scene\n   */\n  unfreezeActiveMeshes() {\n    for (let index = 0; index < this.meshes.length; index++) {\n      const mesh = this.meshes[index];\n      if (mesh._internalAbstractMeshDataInfo) {\n        mesh._internalAbstractMeshDataInfo._isActive = false;\n      }\n    }\n    for (let index = 0; index < this._activeMeshes.length; index++) {\n      this._activeMeshes.data[index]._unFreeze();\n    }\n    this._activeMeshesFrozen = false;\n    return this;\n  }\n  _executeActiveContainerCleanup(container) {\n    const isInFastMode = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;\n    if (!isInFastMode && this._activeMeshesFrozen && this._activeMeshes.length) {\n      return; // Do not execute in frozen mode\n    }\n    // We need to ensure we are not in the rendering loop\n    this.onBeforeRenderObservable.addOnce(() => container.dispose());\n  }\n  _evaluateActiveMeshes() {\n    var _a;\n    if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {\n      if (this._activeMeshes.length > 0) {\n        (_a = this.activeCamera) === null || _a === void 0 ? void 0 : _a._activeMeshes.reset();\n        this._activeMeshes.reset();\n        this._renderingManager.reset();\n        this._processedMaterials.reset();\n        this._activeParticleSystems.reset();\n        this._activeSkeletons.reset();\n        this._softwareSkinnedMeshes.reset();\n      }\n      return;\n    }\n    if (this._activeMeshesFrozen && this._activeMeshes.length) {\n      if (!this._skipEvaluateActiveMeshesCompletely) {\n        const len = this._activeMeshes.length;\n        for (let i = 0; i < len; i++) {\n          const mesh = this._activeMeshes.data[i];\n          mesh.computeWorldMatrix();\n        }\n      }\n      if (this._activeParticleSystems) {\n        const psLength = this._activeParticleSystems.length;\n        for (let i = 0; i < psLength; i++) {\n          this._activeParticleSystems.data[i].animate();\n        }\n      }\n      this._renderingManager.resetSprites();\n      return;\n    }\n    if (!this.activeCamera) {\n      return;\n    }\n    this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);\n    this.activeCamera._activeMeshes.reset();\n    this._activeMeshes.reset();\n    this._renderingManager.reset();\n    this._processedMaterials.reset();\n    this._activeParticleSystems.reset();\n    this._activeSkeletons.reset();\n    this._softwareSkinnedMeshes.reset();\n    this._materialsRenderTargets.reset();\n    for (const step of this._beforeEvaluateActiveMeshStage) {\n      step.action();\n    }\n    // Determine mesh candidates\n    const meshes = this.getActiveMeshCandidates();\n    // Check each mesh\n    const len = meshes.length;\n    for (let i = 0; i < len; i++) {\n      const mesh = meshes.data[i];\n      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;\n      if (mesh.isBlocked) {\n        continue;\n      }\n      this._totalVertices.addCount(mesh.getTotalVertices(), false);\n      if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.hasAZeroComponent) {\n        continue;\n      }\n      mesh.computeWorldMatrix();\n      // Intersections\n      if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {\n        this._meshesForIntersections.pushNoDuplicate(mesh);\n      }\n      // Switch to current LOD\n      let meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);\n      mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;\n      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\n      if (meshToRender === undefined || meshToRender === null) {\n        continue;\n      }\n      // Compute world matrix if LOD is billboard\n      if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {\n        meshToRender.computeWorldMatrix();\n      }\n      mesh._preActivate();\n      if (mesh.isVisible && mesh.visibility > 0 && (mesh.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {\n        this._activeMeshes.push(mesh);\n        this.activeCamera._activeMeshes.push(mesh);\n        if (meshToRender !== mesh) {\n          meshToRender._activate(this._renderId, false);\n        }\n        for (const step of this._preActiveMeshStage) {\n          step.action(mesh);\n        }\n        if (mesh._activate(this._renderId, false)) {\n          if (!mesh.isAnInstance) {\n            meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;\n          } else {\n            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\n              meshToRender = mesh;\n            }\n          }\n          meshToRender._internalAbstractMeshDataInfo._isActive = true;\n          this._activeMesh(mesh, meshToRender);\n        }\n        mesh._postActivate();\n      }\n    }\n    this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this);\n    // Particle systems\n    if (this.particlesEnabled) {\n      this.onBeforeParticlesRenderingObservable.notifyObservers(this);\n      for (let particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {\n        const particleSystem = this.particleSystems[particleIndex];\n        if (!particleSystem.isStarted() || !particleSystem.emitter) {\n          continue;\n        }\n        const emitter = particleSystem.emitter;\n        if (!emitter.position || emitter.isEnabled()) {\n          this._activeParticleSystems.push(particleSystem);\n          particleSystem.animate();\n          this._renderingManager.dispatchParticles(particleSystem);\n        }\n      }\n      this.onAfterParticlesRenderingObservable.notifyObservers(this);\n    }\n  }\n  _activeMesh(sourceMesh, mesh) {\n    if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== undefined) {\n      if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {\n        mesh.skeleton.prepare();\n        this._activeBones.addCount(mesh.skeleton.bones.length, false);\n      }\n      if (!mesh.computeBonesUsingShaders) {\n        this._softwareSkinnedMeshes.pushNoDuplicate(mesh);\n      }\n    }\n    let forcePush = sourceMesh.hasInstances || sourceMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh;\n    if (mesh && mesh.subMeshes && mesh.subMeshes.length > 0) {\n      const subMeshes = this.getActiveSubMeshCandidates(mesh);\n      const len = subMeshes.length;\n      forcePush = forcePush || len === 1;\n      for (let i = 0; i < len; i++) {\n        const subMesh = subMeshes.data[i];\n        this._evaluateSubMesh(subMesh, mesh, sourceMesh, forcePush);\n      }\n    }\n  }\n  /**\n   * Update the transform matrix to update from the current active camera\n   * @param force defines a boolean used to force the update even if cache is up to date\n   */\n  updateTransformMatrix(force) {\n    if (!this.activeCamera) {\n      return;\n    }\n    if (this.activeCamera._renderingMultiview) {\n      const leftCamera = this.activeCamera._rigCameras[0];\n      const rightCamera = this.activeCamera._rigCameras[1];\n      this.setTransformMatrix(leftCamera.getViewMatrix(), leftCamera.getProjectionMatrix(force), rightCamera.getViewMatrix(), rightCamera.getProjectionMatrix(force));\n    } else {\n      this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));\n    }\n  }\n  _bindFrameBuffer(camera) {\n    let clear = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (camera && camera._multiviewTexture) {\n      camera._multiviewTexture._bindFrameBuffer();\n    } else if (camera && camera.outputRenderTarget) {\n      camera.outputRenderTarget._bindFrameBuffer();\n    } else {\n      if (!this._engine._currentFrameBufferIsDefaultFrameBuffer()) {\n        this._engine.restoreDefaultFramebuffer();\n      }\n    }\n    if (clear) {\n      this._clearFrameBuffer(camera);\n    }\n  }\n  _clearFrameBuffer(camera) {\n    // we assume the framebuffer currently bound is the right one\n    if (camera && camera._multiviewTexture) {\n      // no clearing?\n    } else if (camera && camera.outputRenderTarget && !camera._renderingMultiview) {\n      const rtt = camera.outputRenderTarget;\n      if (rtt.onClearObservable.hasObservers()) {\n        rtt.onClearObservable.notifyObservers(this._engine);\n      } else if (!rtt.skipInitialClear) {\n        if (this.autoClear) {\n          this._engine.clear(rtt.clearColor || this.clearColor, !rtt._cleared, true, true);\n        }\n        rtt._cleared = true;\n      }\n    } else {\n      if (!this._defaultFrameBufferCleared) {\n        this._defaultFrameBufferCleared = true;\n        this._clear();\n      } else {\n        this._engine.clear(null, false, true, true);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _renderForCamera(camera, rigParent) {\n    let bindFrameBuffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var _a, _b, _c;\n    if (camera && camera._skipRendering) {\n      return;\n    }\n    const engine = this._engine;\n    // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n    this._activeCamera = camera;\n    if (!this.activeCamera) {\n      throw new Error(\"Active camera not set\");\n    }\n    // Viewport\n    engine.setViewport(this.activeCamera.viewport);\n    // Camera\n    this.resetCachedMaterial();\n    this._renderId++;\n    if (!this.prePass && bindFrameBuffer) {\n      let skipInitialClear = true;\n      if (camera._renderingMultiview && camera.outputRenderTarget) {\n        skipInitialClear = camera.outputRenderTarget.skipInitialClear;\n        if (this.autoClear) {\n          this._defaultFrameBufferCleared = false;\n          camera.outputRenderTarget.skipInitialClear = false;\n        }\n      }\n      this._bindFrameBuffer(this._activeCamera);\n      if (camera._renderingMultiview && camera.outputRenderTarget) {\n        camera.outputRenderTarget.skipInitialClear = skipInitialClear;\n      }\n    }\n    this.updateTransformMatrix();\n    this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);\n    // Meshes\n    this._evaluateActiveMeshes();\n    // Software skinning\n    for (let softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {\n      const mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];\n      mesh.applySkeleton(mesh.skeleton);\n    }\n    // Render targets\n    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n    this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets);\n    if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {\n      this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);\n    }\n    if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {\n      this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);\n    }\n    if (this.environmentTexture && this.environmentTexture.isRenderTarget) {\n      this._renderTargets.pushNoDuplicate(this.environmentTexture);\n    }\n    // Collects render targets from external components.\n    for (const step of this._gatherActiveCameraRenderTargetsStage) {\n      step.action(this._renderTargets);\n    }\n    let needRebind = false;\n    if (this.renderTargetsEnabled) {\n      this._intermediateRendering = true;\n      if (this._renderTargets.length > 0) {\n        Tools.StartPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n        for (let renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {\n          const renderTarget = this._renderTargets.data[renderIndex];\n          if (renderTarget._shouldRender()) {\n            this._renderId++;\n            const hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;\n            renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);\n            needRebind = true;\n          }\n        }\n        Tools.EndPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n        this._renderId++;\n      }\n      for (const step of this._cameraDrawRenderTargetStage) {\n        needRebind = step.action(this.activeCamera) || needRebind;\n      }\n      this._intermediateRendering = false;\n    }\n    this._engine.currentRenderPassId = (_c = (_b = (_a = camera.outputRenderTarget) === null || _a === void 0 ? void 0 : _a.renderPassId) !== null && _b !== void 0 ? _b : camera.renderPassId) !== null && _c !== void 0 ? _c : 0;\n    // Restore framebuffer after rendering to targets\n    if (needRebind && !this.prePass) {\n      this._bindFrameBuffer(this._activeCamera, false);\n    }\n    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\n    // Prepare Frame\n    if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {\n      this.postProcessManager._prepareFrame();\n    }\n    // Before Camera Draw\n    for (const step of this._beforeCameraDrawStage) {\n      step.action(this.activeCamera);\n    }\n    // Render\n    this.onBeforeDrawPhaseObservable.notifyObservers(this);\n    if (engine.snapshotRendering && engine.snapshotRenderingMode === 1) {\n      this.finalizeSceneUbo();\n    }\n    this._renderingManager.render(null, null, true, true);\n    this.onAfterDrawPhaseObservable.notifyObservers(this);\n    // After Camera Draw\n    for (const step of this._afterCameraDrawStage) {\n      step.action(this.activeCamera);\n    }\n    // Finalize frame\n    if (this.postProcessManager && !camera._multiviewTexture) {\n      // if the camera has an output render target, render the post process to the render target\n      const texture = camera.outputRenderTarget ? camera.outputRenderTarget.renderTarget : undefined;\n      this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);\n    }\n    // After post process\n    for (const step of this._afterCameraPostProcessStage) {\n      step.action(this.activeCamera);\n    }\n    // Reset some special arrays\n    this._renderTargets.reset();\n    this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);\n  }\n  _processSubCameras(camera) {\n    let bindFrameBuffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (camera.cameraRigMode === 0 || camera._renderingMultiview) {\n      if (camera._renderingMultiview && !this._multiviewSceneUbo) {\n        this._createMultiviewUbo();\n      }\n      this._renderForCamera(camera, undefined, bindFrameBuffer);\n      this.onAfterRenderCameraObservable.notifyObservers(camera);\n      return;\n    }\n    if (camera._useMultiviewToSingleView) {\n      this._renderMultiviewToSingleView(camera);\n    } else {\n      // rig cameras\n      this.onBeforeCameraRenderObservable.notifyObservers(camera);\n      for (let index = 0; index < camera._rigCameras.length; index++) {\n        this._renderForCamera(camera._rigCameras[index], camera);\n      }\n    }\n    // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n    this._activeCamera = camera;\n    this.updateTransformMatrix();\n    this.onAfterRenderCameraObservable.notifyObservers(camera);\n  }\n  _checkIntersections() {\n    for (let index = 0; index < this._meshesForIntersections.length; index++) {\n      const sourceMesh = this._meshesForIntersections.data[index];\n      if (!sourceMesh.actionManager) {\n        continue;\n      }\n      for (let actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {\n        const action = sourceMesh.actionManager.actions[actionIndex];\n        if (action.trigger === 12 || action.trigger === 13) {\n          const parameters = action.getTriggerParameter();\n          const otherMesh = parameters.mesh ? parameters.mesh : parameters;\n          const areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);\n          const currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);\n          if (areIntersecting && currentIntersectionInProgress === -1) {\n            if (action.trigger === 12) {\n              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n              sourceMesh._intersectionsInProgress.push(otherMesh);\n            } else if (action.trigger === 13) {\n              sourceMesh._intersectionsInProgress.push(otherMesh);\n            }\n          } else if (!areIntersecting && currentIntersectionInProgress > -1) {\n            //They intersected, and now they don't.\n            //is this trigger an exit trigger? execute an event.\n            if (action.trigger === 13) {\n              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n            }\n            //if this is an exit trigger, or no exit trigger exists, remove the id from the intersection in progress array.\n            if (!sourceMesh.actionManager.hasSpecificTrigger(13, parameter => {\n              const parameterMesh = parameter.mesh ? parameter.mesh : parameter;\n              return otherMesh === parameterMesh;\n            }) || action.trigger === 13) {\n              sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _advancePhysicsEngineStep(step) {\n    // Do nothing. Code will be replaced if physics engine component is referenced\n  }\n  /** @internal */\n  _animate() {\n    // Nothing to do as long as Animatable have not been imported.\n  }\n  /** Execute all animations (for a frame) */\n  animate() {\n    if (this._engine.isDeterministicLockStep()) {\n      let deltaTime = Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime)) + this._timeAccumulator;\n      const defaultFrameTime = this._engine.getTimeStep();\n      const defaultFPS = 1000.0 / defaultFrameTime / 1000.0;\n      let stepsTaken = 0;\n      const maxSubSteps = this._engine.getLockstepMaxSteps();\n      let internalSteps = Math.floor(deltaTime / defaultFrameTime);\n      internalSteps = Math.min(internalSteps, maxSubSteps);\n      while (deltaTime > 0 && stepsTaken < internalSteps) {\n        this.onBeforeStepObservable.notifyObservers(this);\n        // Animations\n        this._animationRatio = defaultFrameTime * defaultFPS;\n        this._animate();\n        this.onAfterAnimationsObservable.notifyObservers(this);\n        // Physics\n        if (this.physicsEnabled) {\n          this._advancePhysicsEngineStep(defaultFrameTime);\n        }\n        this.onAfterStepObservable.notifyObservers(this);\n        this._currentStepId++;\n        stepsTaken++;\n        deltaTime -= defaultFrameTime;\n      }\n      this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;\n    } else {\n      // Animations\n      const deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime));\n      this._animationRatio = deltaTime * (60.0 / 1000.0);\n      this._animate();\n      this.onAfterAnimationsObservable.notifyObservers(this);\n      // Physics\n      if (this.physicsEnabled) {\n        this._advancePhysicsEngineStep(deltaTime);\n      }\n    }\n  }\n  _clear() {\n    if (this.autoClearDepthAndStencil || this.autoClear) {\n      this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);\n    }\n  }\n  _checkCameraRenderTarget(camera) {\n    var _a;\n    if ((camera === null || camera === void 0 ? void 0 : camera.outputRenderTarget) && !(camera === null || camera === void 0 ? void 0 : camera.isRigCamera)) {\n      camera.outputRenderTarget._cleared = false;\n    }\n    if ((_a = camera === null || camera === void 0 ? void 0 : camera.rigCameras) === null || _a === void 0 ? void 0 : _a.length) {\n      for (let i = 0; i < camera.rigCameras.length; ++i) {\n        const rtt = camera.rigCameras[i].outputRenderTarget;\n        if (rtt) {\n          rtt._cleared = false;\n        }\n      }\n    }\n  }\n  /**\n   * Resets the draw wrappers cache of all meshes\n   * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n   */\n  resetDrawCache(passId) {\n    if (!this.meshes) {\n      return;\n    }\n    for (const mesh of this.meshes) {\n      mesh.resetDrawCache(passId);\n    }\n  }\n  /**\n   * Render the scene\n   * @param updateCameras defines a boolean indicating if cameras must update according to their inputs (true by default)\n   * @param ignoreAnimations defines a boolean indicating if animations should not be executed (false by default)\n   */\n  render() {\n    let updateCameras = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let ignoreAnimations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var _a, _b, _c;\n    if (this.isDisposed) {\n      return;\n    }\n    if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null) {\n      this._checkIsReady();\n    }\n    this._frameId++;\n    this._defaultFrameBufferCleared = false;\n    this._checkCameraRenderTarget(this.activeCamera);\n    if ((_a = this.activeCameras) === null || _a === void 0 ? void 0 : _a.length) {\n      this.activeCameras.forEach(this._checkCameraRenderTarget);\n    }\n    // Register components that have been associated lately to the scene.\n    this._registerTransientComponents();\n    this._activeParticles.fetchNewFrame();\n    this._totalVertices.fetchNewFrame();\n    this._activeIndices.fetchNewFrame();\n    this._activeBones.fetchNewFrame();\n    this._meshesForIntersections.reset();\n    this.resetCachedMaterial();\n    this.onBeforeAnimationsObservable.notifyObservers(this);\n    // Actions\n    if (this.actionManager) {\n      this.actionManager.processTrigger(11);\n    }\n    // Animations\n    if (!ignoreAnimations) {\n      this.animate();\n    }\n    // Before camera update steps\n    for (const step of this._beforeCameraUpdateStage) {\n      step.action();\n    }\n    // Update Cameras\n    if (updateCameras) {\n      if (this.activeCameras && this.activeCameras.length > 0) {\n        for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n          const camera = this.activeCameras[cameraIndex];\n          camera.update();\n          if (camera.cameraRigMode !== 0) {\n            // rig cameras\n            for (let index = 0; index < camera._rigCameras.length; index++) {\n              camera._rigCameras[index].update();\n            }\n          }\n        }\n      } else if (this.activeCamera) {\n        this.activeCamera.update();\n        if (this.activeCamera.cameraRigMode !== 0) {\n          // rig cameras\n          for (let index = 0; index < this.activeCamera._rigCameras.length; index++) {\n            this.activeCamera._rigCameras[index].update();\n          }\n        }\n      }\n    }\n    // Before render\n    this.onBeforeRenderObservable.notifyObservers(this);\n    const engine = this.getEngine();\n    // Customs render targets\n    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n    const currentActiveCamera = ((_b = this.activeCameras) === null || _b === void 0 ? void 0 : _b.length) ? this.activeCameras[0] : this.activeCamera;\n    if (this.renderTargetsEnabled) {\n      Tools.StartPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n      this._intermediateRendering = true;\n      for (let customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {\n        const renderTarget = this.customRenderTargets[customIndex];\n        if (renderTarget._shouldRender()) {\n          this._renderId++;\n          this.activeCamera = renderTarget.activeCamera || this.activeCamera;\n          if (!this.activeCamera) {\n            throw new Error(\"Active camera not set\");\n          }\n          // Viewport\n          engine.setViewport(this.activeCamera.viewport);\n          // Camera\n          this.updateTransformMatrix();\n          renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);\n        }\n      }\n      Tools.EndPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n      this._intermediateRendering = false;\n      this._renderId++;\n    }\n    this._engine.currentRenderPassId = (_c = currentActiveCamera === null || currentActiveCamera === void 0 ? void 0 : currentActiveCamera.renderPassId) !== null && _c !== void 0 ? _c : 0;\n    // Restore back buffer\n    this.activeCamera = currentActiveCamera;\n    if (this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass) {\n      this._bindFrameBuffer(this._activeCamera, false);\n    }\n    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\n    for (const step of this._beforeClearStage) {\n      step.action();\n    }\n    // Clear\n    this._clearFrameBuffer(this.activeCamera);\n    // Collects render targets from external components.\n    for (const step of this._gatherRenderTargetsStage) {\n      step.action(this._renderTargets);\n    }\n    // Multi-cameras?\n    if (this.activeCameras && this.activeCameras.length > 0) {\n      for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n        this._processSubCameras(this.activeCameras[cameraIndex], cameraIndex > 0);\n      }\n    } else {\n      if (!this.activeCamera) {\n        throw new Error(\"No camera defined\");\n      }\n      this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);\n    }\n    // Intersection checks\n    this._checkIntersections();\n    // Executes the after render stage actions.\n    for (const step of this._afterRenderStage) {\n      step.action();\n    }\n    // After render\n    if (this.afterRender) {\n      this.afterRender();\n    }\n    this.onAfterRenderObservable.notifyObservers(this);\n    // Cleaning\n    if (this._toBeDisposed.length) {\n      for (let index = 0; index < this._toBeDisposed.length; index++) {\n        const data = this._toBeDisposed[index];\n        if (data) {\n          data.dispose();\n        }\n      }\n      this._toBeDisposed.length = 0;\n    }\n    if (this.dumpNextRenderTargets) {\n      this.dumpNextRenderTargets = false;\n    }\n    this._activeBones.addCount(0, true);\n    this._activeIndices.addCount(0, true);\n    this._activeParticles.addCount(0, true);\n    this._engine.restoreDefaultFramebuffer();\n  }\n  /**\n   * Freeze all materials\n   * A frozen material will not be updatable but should be faster to render\n   * Note: multimaterials will not be frozen, but their submaterials will\n   */\n  freezeMaterials() {\n    for (let i = 0; i < this.materials.length; i++) {\n      this.materials[i].freeze();\n    }\n  }\n  /**\n   * Unfreeze all materials\n   * A frozen material will not be updatable but should be faster to render\n   */\n  unfreezeMaterials() {\n    for (let i = 0; i < this.materials.length; i++) {\n      this.materials[i].unfreeze();\n    }\n  }\n  /**\n   * Releases all held resources\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n    this.beforeRender = null;\n    this.afterRender = null;\n    this.metadata = null;\n    this.skeletons.length = 0;\n    this.morphTargetManagers.length = 0;\n    this._transientComponents.length = 0;\n    this._isReadyForMeshStage.clear();\n    this._beforeEvaluateActiveMeshStage.clear();\n    this._evaluateSubMeshStage.clear();\n    this._preActiveMeshStage.clear();\n    this._cameraDrawRenderTargetStage.clear();\n    this._beforeCameraDrawStage.clear();\n    this._beforeRenderTargetDrawStage.clear();\n    this._beforeRenderingGroupDrawStage.clear();\n    this._beforeRenderingMeshStage.clear();\n    this._afterRenderingMeshStage.clear();\n    this._afterRenderingGroupDrawStage.clear();\n    this._afterCameraDrawStage.clear();\n    this._afterRenderTargetDrawStage.clear();\n    this._afterRenderStage.clear();\n    this._beforeCameraUpdateStage.clear();\n    this._beforeClearStage.clear();\n    this._gatherRenderTargetsStage.clear();\n    this._gatherActiveCameraRenderTargetsStage.clear();\n    this._pointerMoveStage.clear();\n    this._pointerDownStage.clear();\n    this._pointerUpStage.clear();\n    this.importedMeshesFiles = new Array();\n    if (this.stopAllAnimations) {\n      // Ensures that no animatable notifies a callback that could start a new animation group, constantly adding new animatables to the active list...\n      this._activeAnimatables.forEach(animatable => {\n        animatable.onAnimationEndObservable.clear();\n        animatable.onAnimationEnd = null;\n      });\n      this.stopAllAnimations();\n    }\n    this.resetCachedMaterial();\n    // Smart arrays\n    if (this.activeCamera) {\n      this.activeCamera._activeMeshes.dispose();\n      this.activeCamera = null;\n    }\n    this.activeCameras = null;\n    this._activeMeshes.dispose();\n    this._renderingManager.dispose();\n    this._processedMaterials.dispose();\n    this._activeParticleSystems.dispose();\n    this._activeSkeletons.dispose();\n    this._softwareSkinnedMeshes.dispose();\n    this._renderTargets.dispose();\n    this._materialsRenderTargets.dispose();\n    this._registeredForLateAnimationBindings.dispose();\n    this._meshesForIntersections.dispose();\n    this._toBeDisposed.length = 0;\n    // Abort active requests\n    const activeRequests = this._activeRequests.slice();\n    for (const request of activeRequests) {\n      request.abort();\n    }\n    this._activeRequests.length = 0;\n    // Events\n    try {\n      this.onDisposeObservable.notifyObservers(this);\n    } catch (e) {\n      console.error(\"An error occurred while calling onDisposeObservable!\", e);\n    }\n    this.detachControl();\n    // Detach cameras\n    const canvas = this._engine.getInputElement();\n    if (canvas) {\n      for (let index = 0; index < this.cameras.length; index++) {\n        this.cameras[index].detachControl();\n      }\n    }\n    // Release animation groups\n    this._disposeList(this.animationGroups);\n    // Release lights\n    this._disposeList(this.lights);\n    // Release meshes\n    this._disposeList(this.meshes, item => item.dispose(true));\n    this._disposeList(this.transformNodes, item => item.dispose(true));\n    // Release cameras\n    const cameras = this.cameras;\n    this._disposeList(cameras);\n    // Release materials\n    if (this._defaultMaterial) {\n      this._defaultMaterial.dispose();\n    }\n    this._disposeList(this.multiMaterials);\n    this._disposeList(this.materials);\n    // Release particles\n    this._disposeList(this.particleSystems);\n    // Release postProcesses\n    this._disposeList(this.postProcesses);\n    // Release textures\n    this._disposeList(this.textures);\n    // Release morph targets\n    this._disposeList(this.morphTargetManagers);\n    // Release UBO\n    this._sceneUbo.dispose();\n    if (this._multiviewSceneUbo) {\n      this._multiviewSceneUbo.dispose();\n    }\n    // Post-processes\n    this.postProcessManager.dispose();\n    // Components\n    this._disposeList(this._components);\n    // Remove from engine\n    let index = this._engine.scenes.indexOf(this);\n    if (index > -1) {\n      this._engine.scenes.splice(index, 1);\n    }\n    if (EngineStore._LastCreatedScene === this) {\n      if (this._engine.scenes.length > 0) {\n        EngineStore._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1];\n      } else {\n        EngineStore._LastCreatedScene = null;\n      }\n    }\n    index = this._engine._virtualScenes.indexOf(this);\n    if (index > -1) {\n      this._engine._virtualScenes.splice(index, 1);\n    }\n    this._engine.wipeCaches(true);\n    this.onDisposeObservable.clear();\n    this.onBeforeRenderObservable.clear();\n    this.onAfterRenderObservable.clear();\n    this.onBeforeRenderTargetsRenderObservable.clear();\n    this.onAfterRenderTargetsRenderObservable.clear();\n    this.onAfterStepObservable.clear();\n    this.onBeforeStepObservable.clear();\n    this.onBeforeActiveMeshesEvaluationObservable.clear();\n    this.onAfterActiveMeshesEvaluationObservable.clear();\n    this.onBeforeParticlesRenderingObservable.clear();\n    this.onAfterParticlesRenderingObservable.clear();\n    this.onBeforeDrawPhaseObservable.clear();\n    this.onAfterDrawPhaseObservable.clear();\n    this.onBeforeAnimationsObservable.clear();\n    this.onAfterAnimationsObservable.clear();\n    this.onDataLoadedObservable.clear();\n    this.onBeforeRenderingGroupObservable.clear();\n    this.onAfterRenderingGroupObservable.clear();\n    this.onMeshImportedObservable.clear();\n    this.onBeforeCameraRenderObservable.clear();\n    this.onAfterCameraRenderObservable.clear();\n    this.onAfterRenderCameraObservable.clear();\n    this.onReadyObservable.clear();\n    this.onNewCameraAddedObservable.clear();\n    this.onCameraRemovedObservable.clear();\n    this.onNewLightAddedObservable.clear();\n    this.onLightRemovedObservable.clear();\n    this.onNewGeometryAddedObservable.clear();\n    this.onGeometryRemovedObservable.clear();\n    this.onNewTransformNodeAddedObservable.clear();\n    this.onTransformNodeRemovedObservable.clear();\n    this.onNewMeshAddedObservable.clear();\n    this.onMeshRemovedObservable.clear();\n    this.onNewSkeletonAddedObservable.clear();\n    this.onSkeletonRemovedObservable.clear();\n    this.onNewMaterialAddedObservable.clear();\n    this.onNewMultiMaterialAddedObservable.clear();\n    this.onMaterialRemovedObservable.clear();\n    this.onMultiMaterialRemovedObservable.clear();\n    this.onNewTextureAddedObservable.clear();\n    this.onTextureRemovedObservable.clear();\n    this.onPrePointerObservable.clear();\n    this.onPointerObservable.clear();\n    this.onPreKeyboardObservable.clear();\n    this.onKeyboardObservable.clear();\n    this.onActiveCameraChanged.clear();\n    this.onScenePerformancePriorityChangedObservable.clear();\n    this._isDisposed = true;\n  }\n  _disposeList(items, callback) {\n    const itemsCopy = items.slice(0);\n    callback = callback !== null && callback !== void 0 ? callback : item => item.dispose();\n    for (const item of itemsCopy) {\n      callback(item);\n    }\n    items.length = 0;\n  }\n  /**\n   * Gets if the scene is already disposed\n   */\n  get isDisposed() {\n    return this._isDisposed;\n  }\n  /**\n   * Call this function to reduce memory footprint of the scene.\n   * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\n   */\n  clearCachedVertexData() {\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n      const mesh = this.meshes[meshIndex];\n      const geometry = mesh.geometry;\n      if (geometry) {\n        geometry.clearCachedData();\n      }\n    }\n  }\n  /**\n   * This function will remove the local cached buffer data from texture.\n   * It will save memory but will prevent the texture from being rebuilt\n   */\n  cleanCachedTextureBuffer() {\n    for (const baseTexture of this.textures) {\n      const buffer = baseTexture._buffer;\n      if (buffer) {\n        baseTexture._buffer = null;\n      }\n    }\n  }\n  /**\n   * Get the world extend vectors with an optional filter\n   *\n   * @param filterPredicate the predicate - which meshes should be included when calculating the world size\n   * @returns {{ min: Vector3; max: Vector3 }} min and max vectors\n   */\n  getWorldExtends(filterPredicate) {\n    const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    filterPredicate = filterPredicate || (() => true);\n    this.meshes.filter(filterPredicate).forEach(mesh => {\n      mesh.computeWorldMatrix(true);\n      if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {\n        return;\n      }\n      const boundingInfo = mesh.getBoundingInfo();\n      const minBox = boundingInfo.boundingBox.minimumWorld;\n      const maxBox = boundingInfo.boundingBox.maximumWorld;\n      Vector3.CheckExtends(minBox, min, max);\n      Vector3.CheckExtends(maxBox, min, max);\n    });\n    return {\n      min: min,\n      max: max\n    };\n  }\n  // Picking\n  /**\n   * Creates a ray that can be used to pick in the scene\n   * @param x defines the x coordinate of the origin (on-screen)\n   * @param y defines the y coordinate of the origin (on-screen)\n   * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n   * @param camera defines the camera to use for the picking\n   * @param cameraViewSpace defines if picking will be done in view space (false by default)\n   * @returns a Ray\n   */\n  createPickingRay(x, y, world, camera) {\n    let cameraViewSpace = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    throw _WarnImport(\"Ray\");\n  }\n  /**\n   * Creates a ray that can be used to pick in the scene\n   * @param x defines the x coordinate of the origin (on-screen)\n   * @param y defines the y coordinate of the origin (on-screen)\n   * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n   * @param result defines the ray where to store the picking ray\n   * @param camera defines the camera to use for the picking\n   * @param cameraViewSpace defines if picking will be done in view space (false by default)\n   * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\n   * @returns the current scene\n   */\n  createPickingRayToRef(x, y, world, result, camera) {\n    let cameraViewSpace = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    let enableDistantPicking = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    throw _WarnImport(\"Ray\");\n  }\n  /**\n   * Creates a ray that can be used to pick in the scene\n   * @param x defines the x coordinate of the origin (on-screen)\n   * @param y defines the y coordinate of the origin (on-screen)\n   * @param camera defines the camera to use for the picking\n   * @returns a Ray\n   */\n  createPickingRayInCameraSpace(x, y, camera) {\n    throw _WarnImport(\"Ray\");\n  }\n  /**\n   * Creates a ray that can be used to pick in the scene\n   * @param x defines the x coordinate of the origin (on-screen)\n   * @param y defines the y coordinate of the origin (on-screen)\n   * @param result defines the ray where to store the picking ray\n   * @param camera defines the camera to use for the picking\n   * @returns the current scene\n   */\n  createPickingRayInCameraSpaceToRef(x, y, result, camera) {\n    throw _WarnImport(\"Ray\");\n  }\n  /** @internal */\n  get _pickingAvailable() {\n    return false;\n  }\n  /** Launch a ray to try to pick a mesh in the scene\n   * @param x position on screen\n   * @param y position on screen\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns a PickingInfo\n   */\n  pick(x, y, predicate, fastCheck, camera, trianglePredicate) {\n    // Dummy info if picking as not been imported\n    return new PickingInfo();\n  }\n  /** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)\n   * @param x position on screen\n   * @param y position on screen\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n   * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)\n   */\n  pickWithBoundingInfo(x, y, predicate, fastCheck, camera) {\n    // Dummy info if picking as not been imported\n    return new PickingInfo();\n  }\n  /**\n   * Use the given ray to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\n   * irrespective of orientation.\n   * @param ray The ray to use to pick meshes\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns a PickingInfo\n   */\n  pickWithRay(ray, predicate, fastCheck, trianglePredicate) {\n    throw _WarnImport(\"Ray\");\n  }\n  /**\n   * Launch a ray to try to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\n   * irrespective of orientation.\n   * @param x X position on screen\n   * @param y Y position on screen\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n   * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns an array of PickingInfo\n   */\n  multiPick(x, y, predicate, camera, trianglePredicate) {\n    throw _WarnImport(\"Ray\");\n  }\n  /**\n   * Launch a ray to try to pick a mesh in the scene\n   * @param ray Ray to use\n   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns an array of PickingInfo\n   */\n  multiPickWithRay(ray, predicate, trianglePredicate) {\n    throw _WarnImport(\"Ray\");\n  }\n  /**\n   * Force the value of meshUnderPointer\n   * @param mesh defines the mesh to use\n   * @param pointerId optional pointer id when using more than one pointer\n   * @param pickResult optional pickingInfo data used to find mesh\n   */\n  setPointerOverMesh(mesh, pointerId, pickResult) {\n    this._inputManager.setPointerOverMesh(mesh, pointerId, pickResult);\n  }\n  /**\n   * Gets the mesh under the pointer\n   * @returns a Mesh or null if no mesh is under the pointer\n   */\n  getPointerOverMesh() {\n    return this._inputManager.getPointerOverMesh();\n  }\n  // Misc.\n  /** @internal */\n  _rebuildGeometries() {\n    for (const geometry of this.geometries) {\n      geometry._rebuild();\n    }\n    for (const mesh of this.meshes) {\n      mesh._rebuild();\n    }\n    if (this.postProcessManager) {\n      this.postProcessManager._rebuild();\n    }\n    for (const component of this._components) {\n      component.rebuild();\n    }\n    for (const system of this.particleSystems) {\n      system.rebuild();\n    }\n    if (this.spriteManagers) {\n      for (const spriteMgr of this.spriteManagers) {\n        spriteMgr.rebuild();\n      }\n    }\n  }\n  /** @internal */\n  _rebuildTextures() {\n    for (const texture of this.textures) {\n      texture._rebuild();\n    }\n    this.markAllMaterialsAsDirty(1);\n  }\n  // Tags\n  _getByTags(list, tagsQuery, forEach) {\n    if (tagsQuery === undefined) {\n      // returns the complete list (could be done with Tags.MatchesQuery but no need to have a for-loop here)\n      return list;\n    }\n    const listByTags = [];\n    forEach = forEach || (item => {\n      return;\n    });\n    for (const i in list) {\n      const item = list[i];\n      if (Tags && Tags.MatchesQuery(item, tagsQuery)) {\n        listByTags.push(item);\n        forEach(item);\n      }\n    }\n    return listByTags;\n  }\n  /**\n   * Get a list of meshes by tags\n   * @param tagsQuery defines the tags query to use\n   * @param forEach defines a predicate used to filter results\n   * @returns an array of Mesh\n   */\n  getMeshesByTags(tagsQuery, forEach) {\n    return this._getByTags(this.meshes, tagsQuery, forEach);\n  }\n  /**\n   * Get a list of cameras by tags\n   * @param tagsQuery defines the tags query to use\n   * @param forEach defines a predicate used to filter results\n   * @returns an array of Camera\n   */\n  getCamerasByTags(tagsQuery, forEach) {\n    return this._getByTags(this.cameras, tagsQuery, forEach);\n  }\n  /**\n   * Get a list of lights by tags\n   * @param tagsQuery defines the tags query to use\n   * @param forEach defines a predicate used to filter results\n   * @returns an array of Light\n   */\n  getLightsByTags(tagsQuery, forEach) {\n    return this._getByTags(this.lights, tagsQuery, forEach);\n  }\n  /**\n   * Get a list of materials by tags\n   * @param tagsQuery defines the tags query to use\n   * @param forEach defines a predicate used to filter results\n   * @returns an array of Material\n   */\n  getMaterialByTags(tagsQuery, forEach) {\n    return this._getByTags(this.materials, tagsQuery, forEach).concat(this._getByTags(this.multiMaterials, tagsQuery, forEach));\n  }\n  /**\n   * Get a list of transform nodes by tags\n   * @param tagsQuery defines the tags query to use\n   * @param forEach defines a predicate used to filter results\n   * @returns an array of TransformNode\n   */\n  getTransformNodesByTags(tagsQuery, forEach) {\n    return this._getByTags(this.transformNodes, tagsQuery, forEach);\n  }\n  /**\n   * Overrides the default sort function applied in the rendering group to prepare the meshes.\n   * This allowed control for front to back rendering or reversly depending of the special needs.\n   *\n   * @param renderingGroupId The rendering group id corresponding to its index\n   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n   * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n   */\n  setRenderingOrder(renderingGroupId) {\n    let opaqueSortCompareFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let alphaTestSortCompareFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let transparentSortCompareFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\n  }\n  /**\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n   *\n   * @param renderingGroupId The rendering group id corresponding to its index\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n   * @param depth Automatically clears depth between groups if true and autoClear is true.\n   * @param stencil Automatically clears stencil between groups if true and autoClear is true.\n   */\n  setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil) {\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let stencil = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);\n  }\n  /**\n   * Gets the current auto clear configuration for one rendering group of the rendering\n   * manager.\n   * @param index the rendering group index to get the information for\n   * @returns The auto clear setup for the requested rendering group\n   */\n  getAutoClearDepthStencilSetup(index) {\n    return this._renderingManager.getAutoClearDepthStencilSetup(index);\n  }\n  /** Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync) */\n  get blockMaterialDirtyMechanism() {\n    return this._blockMaterialDirtyMechanism;\n  }\n  set blockMaterialDirtyMechanism(value) {\n    if (this._blockMaterialDirtyMechanism === value) {\n      return;\n    }\n    this._blockMaterialDirtyMechanism = value;\n    if (!value) {\n      // Do a complete update\n      this.markAllMaterialsAsDirty(63);\n    }\n  }\n  /**\n   * Will flag all materials as dirty to trigger new shader compilation\n   * @param flag defines the flag used to specify which material part must be marked as dirty\n   * @param predicate If not null, it will be used to specify if a material has to be marked as dirty\n   */\n  markAllMaterialsAsDirty(flag, predicate) {\n    if (this._blockMaterialDirtyMechanism) {\n      return;\n    }\n    for (const material of this.materials) {\n      if (predicate && !predicate(material)) {\n        continue;\n      }\n      material.markAsDirty(flag);\n    }\n  }\n  /**\n   * @internal\n   */\n  _loadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {\n    const request = LoadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n    this._activeRequests.push(request);\n    request.onCompleteObservable.add(request => {\n      this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\n    });\n    return request;\n  }\n  /**\n   * @internal\n   */\n  _loadFileAsync(fileOrUrl, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {\n    return new Promise((resolve, reject) => {\n      this._loadFile(fileOrUrl, data => {\n        resolve(data);\n      }, onProgress, useOfflineSupport, useArrayBuffer, (request, exception) => {\n        reject(exception);\n      }, onOpened);\n    });\n  }\n  /**\n   * @internal\n   */\n  _requestFile(url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {\n    const request = RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n    this._activeRequests.push(request);\n    request.onCompleteObservable.add(request => {\n      this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\n    });\n    return request;\n  }\n  /**\n   * @internal\n   */\n  _requestFileAsync(url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {\n    return new Promise((resolve, reject) => {\n      this._requestFile(url, data => {\n        resolve(data);\n      }, onProgress, useOfflineSupport, useArrayBuffer, error => {\n        reject(error);\n      }, onOpened);\n    });\n  }\n  /**\n   * @internal\n   */\n  _readFile(file, onSuccess, onProgress, useArrayBuffer, onError) {\n    const request = ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);\n    this._activeRequests.push(request);\n    request.onCompleteObservable.add(request => {\n      this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\n    });\n    return request;\n  }\n  /**\n   * @internal\n   */\n  _readFileAsync(file, onProgress, useArrayBuffer) {\n    return new Promise((resolve, reject) => {\n      this._readFile(file, data => {\n        resolve(data);\n      }, onProgress, useArrayBuffer, error => {\n        reject(error);\n      });\n    });\n  }\n  /**\n   * This method gets the performance collector belonging to the scene, which is generally shared with the inspector.\n   * @returns the perf collector belonging to the scene.\n   */\n  getPerfCollector() {\n    throw _WarnImport(\"performanceViewerSceneExtension\");\n  }\n  // deprecated\n  /**\n   * Sets the active camera of the scene using its Id\n   * @param id defines the camera's Id\n   * @returns the new active camera or null if none found.\n   * @deprecated Please use setActiveCameraById instead\n   */\n  setActiveCameraByID(id) {\n    return this.setActiveCameraById(id);\n  }\n  /**\n   * Get a material using its id\n   * @param id defines the material's Id\n   * @returns the material or null if none found.\n   * @deprecated Please use getMaterialById instead\n   */\n  getMaterialByID(id) {\n    return this.getMaterialById(id);\n  }\n  /**\n   * Gets a the last added material using a given id\n   * @param id defines the material's Id\n   * @returns the last material with the given id or null if none found.\n   * @deprecated Please use getLastMaterialById instead\n   */\n  getLastMaterialByID(id) {\n    return this.getLastMaterialById(id);\n  }\n  /**\n   * Get a texture using its unique id\n   * @param uniqueId defines the texture's unique id\n   * @returns the texture or null if none found.\n   * @deprecated Please use getTextureByUniqueId instead\n   */\n  getTextureByUniqueID(uniqueId) {\n    return this.getTextureByUniqueId(uniqueId);\n  }\n  /**\n   * Gets a camera using its Id\n   * @param id defines the Id to look for\n   * @returns the camera or null if not found\n   * @deprecated Please use getCameraById instead\n   */\n  getCameraByID(id) {\n    return this.getCameraById(id);\n  }\n  /**\n   * Gets a camera using its unique Id\n   * @param uniqueId defines the unique Id to look for\n   * @returns the camera or null if not found\n   * @deprecated Please use getCameraByUniqueId instead\n   */\n  getCameraByUniqueID(uniqueId) {\n    return this.getCameraByUniqueId(uniqueId);\n  }\n  /**\n   * Gets a bone using its Id\n   * @param id defines the bone's Id\n   * @returns the bone or null if not found\n   * @deprecated Please use getBoneById instead\n   */\n  getBoneByID(id) {\n    return this.getBoneById(id);\n  }\n  /**\n   * Gets a light node using its Id\n   * @param id defines the light's Id\n   * @returns the light or null if none found.\n   * @deprecated Please use getLightById instead\n   */\n  getLightByID(id) {\n    return this.getLightById(id);\n  }\n  /**\n   * Gets a light node using its scene-generated unique Id\n   * @param uniqueId defines the light's unique Id\n   * @returns the light or null if none found.\n   * @deprecated Please use getLightByUniqueId instead\n   */\n  getLightByUniqueID(uniqueId) {\n    return this.getLightByUniqueId(uniqueId);\n  }\n  /**\n   * Gets a particle system by Id\n   * @param id defines the particle system Id\n   * @returns the corresponding system or null if none found\n   * @deprecated Please use getParticleSystemById instead\n   */\n  getParticleSystemByID(id) {\n    return this.getParticleSystemById(id);\n  }\n  /**\n   * Gets a geometry using its Id\n   * @param id defines the geometry's Id\n   * @returns the geometry or null if none found.\n   * @deprecated Please use getGeometryById instead\n   */\n  getGeometryByID(id) {\n    return this.getGeometryById(id);\n  }\n  /**\n   * Gets the first added mesh found of a given Id\n   * @param id defines the Id to search for\n   * @returns the mesh found or null if not found at all\n   * @deprecated Please use getMeshById instead\n   */\n  getMeshByID(id) {\n    return this.getMeshById(id);\n  }\n  /**\n   * Gets a mesh with its auto-generated unique Id\n   * @param uniqueId defines the unique Id to search for\n   * @returns the found mesh or null if not found at all.\n   * @deprecated Please use getMeshByUniqueId instead\n   */\n  getMeshByUniqueID(uniqueId) {\n    return this.getMeshByUniqueId(uniqueId);\n  }\n  /**\n   * Gets a the last added mesh using a given Id\n   * @param id defines the Id to search for\n   * @returns the found mesh or null if not found at all.\n   * @deprecated Please use getLastMeshById instead\n   */\n  getLastMeshByID(id) {\n    return this.getLastMeshById(id);\n  }\n  /**\n   * Gets a list of meshes using their Id\n   * @param id defines the Id to search for\n   * @returns a list of meshes\n   * @deprecated Please use getMeshesById instead\n   */\n  getMeshesByID(id) {\n    return this.getMeshesById(id);\n  }\n  /**\n   * Gets the first added transform node found of a given Id\n   * @param id defines the Id to search for\n   * @returns the found transform node or null if not found at all.\n   * @deprecated Please use getTransformNodeById instead\n   */\n  getTransformNodeByID(id) {\n    return this.getTransformNodeById(id);\n  }\n  /**\n   * Gets a transform node with its auto-generated unique Id\n   * @param uniqueId defines the unique Id to search for\n   * @returns the found transform node or null if not found at all.\n   * @deprecated Please use getTransformNodeByUniqueId instead\n   */\n  getTransformNodeByUniqueID(uniqueId) {\n    return this.getTransformNodeByUniqueId(uniqueId);\n  }\n  /**\n   * Gets a list of transform nodes using their Id\n   * @param id defines the Id to search for\n   * @returns a list of transform nodes\n   * @deprecated Please use getTransformNodesById instead\n   */\n  getTransformNodesByID(id) {\n    return this.getTransformNodesById(id);\n  }\n  /**\n   * Gets a node (Mesh, Camera, Light) using a given Id\n   * @param id defines the Id to search for\n   * @returns the found node or null if not found at all\n   * @deprecated Please use getNodeById instead\n   */\n  getNodeByID(id) {\n    return this.getNodeById(id);\n  }\n  /**\n   * Gets a the last added node (Mesh, Camera, Light) using a given Id\n   * @param id defines the Id to search for\n   * @returns the found node or null if not found at all\n   * @deprecated Please use getLastEntryById instead\n   */\n  getLastEntryByID(id) {\n    return this.getLastEntryById(id);\n  }\n  /**\n   * Gets a skeleton using a given Id (if many are found, this function will pick the last one)\n   * @param id defines the Id to search for\n   * @returns the found skeleton or null if not found at all.\n   * @deprecated Please use getLastSkeletonById instead\n   */\n  getLastSkeletonByID(id) {\n    return this.getLastSkeletonById(id);\n  }\n}\n/** The fog is deactivated */\nScene.FOGMODE_NONE = 0;\n/** The fog density is following an exponential function */\nScene.FOGMODE_EXP = 1;\n/** The fog density is following an exponential function faster than FOGMODE_EXP */\nScene.FOGMODE_EXP2 = 2;\n/** The fog density is following a linear function. */\nScene.FOGMODE_LINEAR = 3;\n/**\n * Gets or sets the minimum deltatime when deterministic lock step is enabled\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n */\nScene.MinDeltaTime = 1.0;\n/**\n * Gets or sets the maximum deltatime when deterministic lock step is enabled\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n */\nScene.MaxDeltaTime = 1000.0;"],"names":["ScenePerformancePriority","Scene","DefaultMaterialFactory","scene","CollisionCoordinatorFactory","environmentTexture","this","_environmentTexture","value","markAllMaterialsAsDirty","imageProcessingConfiguration","_imageProcessingConfiguration","performancePriority","_performancePriority","BackwardCompatible","skipFrustumClipping","_renderingManager","maintainStateBetweenFrames","skipPointerMovePicking","autoClear","Intermediate","Aggressive","onScenePerformancePriorityChangedObservable","notifyObservers","forceWireframe","_forceWireframe","_skipFrustumClipping","forcePointsCloud","_forcePointsCloud","animationPropertiesOverride","_animationPropertiesOverride","onDispose","callback","_onDisposeObserver","onDisposeObservable","remove","add","beforeRender","_onBeforeRenderObserver","onBeforeRenderObservable","afterRender","_onAfterRenderObserver","onAfterRenderObservable","beforeCameraRender","_onBeforeCameraRenderObserver","onBeforeCameraRenderObservable","afterCameraRender","_onAfterCameraRenderObserver","onAfterCameraRenderObservable","pointerDownPredicate","_pointerPickingConfiguration","pointerUpPredicate","pointerMovePredicate","pointerDownFastCheck","pointerUpFastCheck","pointerMoveFastCheck","skipPointerDownPicking","skipPointerUpPicking","unTranslatedPointer","_inputManager","DragMovementThreshold","LongPressDelay","DoubleClickDelay","ExclusiveDoubleClickMode","bindEyePosition","effect","variableName","arguments","length","undefined","isVector3","_a","eyePosition","_forcedViewPosition","_mirroredCameraPosition","activeCamera","globalPosition","devicePosition","invertNormal","useRightHandedSystem","Vector4","set","x","y","z","setFloat3","setVector4","finalizeSceneUbo","ubo","getSceneUniformBuffer","updateFloat4","w","update","_useRightHandedSystem","setStepId","newStepId","_currentStepId","getStepId","getInternalStep","_currentInternalStep","fogEnabled","_fogEnabled","fogMode","_fogMode","prePass","prePassRenderer","defaultRT","enabled","shadowsEnabled","_shadowsEnabled","lightsEnabled","_lightsEnabled","activeCameras","_activeCameras","cameras","_unObserveActiveCameras","onActiveCamerasChanged","_activeCamera","onActiveCameraChanged","defaultMaterial","_defaultMaterial","texturesEnabled","_texturesEnabled","skeletonsEnabled","_skeletonsEnabled","collisionCoordinator","_collisionCoordinator","init","renderingManager","frustumPlanes","_frustumPlanes","_registerTransientComponents","_transientComponents","component","register","_addComponent","_components","push","serializableComponent","addFromContainer","serialize","_serializableComponents","_getComponent","name","constructor","engine","options","super","cameraToUseForPointers","_isScene","_blockEntityCollection","autoClearDepthAndStencil","clearColor","ambientColor","environmentIntensity","animationsEnabled","useConstantAnimationDeltaTime","constantlyUpdateMeshUnderPointer","hoverCursor","defaultCursor","doNotHandleCursors","preventDefaultOnPointerDown","preventDefaultOnPointerUp","metadata","reservedDataStore","disableOfflineSupportExceptionRules","Array","onAfterRenderCameraObservable","onBeforeAnimationsObservable","onAfterAnimationsObservable","onBeforeDrawPhaseObservable","onAfterDrawPhaseObservable","onReadyObservable","onBeforeActiveMeshesEvaluationObservable","onAfterActiveMeshesEvaluationObservable","onBeforeParticlesRenderingObservable","onAfterParticlesRenderingObservable","onDataLoadedObservable","onNewCameraAddedObservable","onCameraRemovedObservable","onNewLightAddedObservable","onLightRemovedObservable","onNewGeometryAddedObservable","onGeometryRemovedObservable","onNewTransformNodeAddedObservable","onTransformNodeRemovedObservable","onNewMeshAddedObservable","onMeshRemovedObservable","onNewSkeletonAddedObservable","onSkeletonRemovedObservable","onNewMaterialAddedObservable","onNewMultiMaterialAddedObservable","onMaterialRemovedObservable","onMultiMaterialRemovedObservable","onNewTextureAddedObservable","onTextureRemovedObservable","onBeforeRenderTargetsRenderObservable","onAfterRenderTargetsRenderObservable","onBeforeStepObservable","onAfterStepObservable","onBeforeRenderingGroupObservable","onAfterRenderingGroupObservable","onMeshImportedObservable","onAnimationFileImportedObservable","_registeredForLateAnimationBindings","onPrePointerObservable","onPointerObservable","onPreKeyboardObservable","onKeyboardObservable","_timeAccumulator","FOGMODE_NONE","fogColor","fogDensity","fogStart","fogEnd","needsPreviousWorldMatrices","physicsEnabled","particlesEnabled","spritesEnabled","lensFlaresEnabled","collisionsEnabled","gravity","postProcessesEnabled","renderTargetsEnabled","dumpNextRenderTargets","customRenderTargets","importedMeshesFiles","probesEnabled","_meshesForIntersections","proceduralTexturesEnabled","_totalVertices","_activeIndices","_activeParticles","_activeBones","_animationTime","animationTimeScale","_renderId","_frameId","_executeWhenReadyTimeoutId","_intermediateRendering","_defaultFrameBufferCleared","_viewUpdateFlag","_projectionUpdateFlag","_toBeDisposed","_activeRequests","_pendingData","_isDisposed","dispatchAllSubMeshesOfActiveMeshes","_activeMeshes","_processedMaterials","_renderTargets","_materialsRenderTargets","_activeParticleSystems","_activeSkeletons","_softwareSkinnedMeshes","_activeAnimatables","_transformMatrix","Zero","requireLightSorting","_beforeCameraUpdateStage","Create","_beforeClearStage","_beforeRenderTargetClearStage","_gatherRenderTargetsStage","_gatherActiveCameraRenderTargetsStage","_isReadyForMeshStage","_beforeEvaluateActiveMeshStage","_evaluateSubMeshStage","_preActiveMeshStage","_cameraDrawRenderTargetStage","_beforeCameraDrawStage","_beforeRenderTargetDrawStage","_beforeRenderingGroupDrawStage","_beforeRenderingMeshStage","_afterRenderingMeshStage","_afterRenderingGroupDrawStage","_afterCameraDrawStage","_afterCameraPostProcessStage","_afterRenderTargetDrawStage","_afterRenderTargetPostProcessStage","_afterRenderStage","_pointerMoveStage","_pointerDownStage","_pointerUpStage","_geometriesByUniqueId","_defaultMeshCandidates","data","_defaultSubMeshCandidates","_preventFreeActiveMeshesAndRenderingGroups","_activeMeshesFrozen","_activeMeshesFrozenButKeepClipping","_skipEvaluateActiveMeshesCompletely","_allowPostProcessClearColor","getDeterministicFrameTime","_engine","getTimeStep","_registeredActions","_blockMaterialDirtyMechanism","_perfCollector","fullOptions","Object","assign","useGeometryUniqueIdsMap","useMaterialMeshMap","useClonedMeshMap","virtual","LastCreatedEngine","_virtualScenes","_LastCreatedScene","scenes","_uid","postProcessManager","attachControl","_createUbo","setDefaultCandidateProviders","onNewSceneAddedObservable","getClassName","_getDefaultMeshCandidates","meshes","_getDefaultSubMeshCandidates","mesh","subMeshes","getActiveMeshCandidates","bind","getActiveSubMeshCandidates","getIntersectingSubMeshCandidates","getCollidingSubMeshCandidates","meshUnderPointer","pointerX","pointerY","getCachedMaterial","_cachedMaterial","getCachedEffect","_cachedEffect","getCachedVisibility","_cachedVisibility","isCachedMaterialInvalid","material","visibility","getEngine","getTotalVertices","current","totalVerticesPerfCounter","getActiveIndices","totalActiveIndicesPerfCounter","getActiveParticles","activeParticlesPerfCounter","getActiveBones","activeBonesPerfCounter","getActiveMeshes","getAnimationRatio","_animationRatio","getRenderId","getFrameId","incrementRenderId","setSceneUniformBuffer","createSceneUniformBuffer","simulatePointerMove","pickResult","pointerEventInit","simulatePointerDown","simulatePointerUp","doubleTap","isPointerCaptured","pointerId","attachUp","attachDown","attachMove","detachControl","isReady","checkRenderTargets","_b","_c","index","currentRenderPassId","renderPassId","reset","hardwareInstancedRendering","hasThinInstances","getCaps","instancedArrays","instances","step","action","mat","_storeEffectOnSubMeshes","subMesh","getMaterial","hasRenderTargetTextures","getRenderTargetTextures","indexOf","concatWithNoDuplicate","isReadyForRendering","geometries","delayLoadState","camera","particleSystem","particleSystems","layers","layer","areAllEffectsReady","resetCachedMaterial","registerBeforeRender","func","unregisterBeforeRender","removeCallback","registerAfterRender","unregisterAfterRender","_executeOnceBeforeRender","execFunc","setTimeout","executeOnceBeforeRender","timeout","addPendingData","removePendingData","wasLoading","isLoading","splice","getWaitingItemsCount","executeWhenReady","addOnce","_checkIsReady","whenReadyAsync","Promise","resolve","clear","animatables","resetLastAnimationTimeFrame","_animationTimeLast","Now","getViewMatrix","_viewMatrix","getProjectionMatrix","_projectionMatrix","getTransformMatrix","setTransformMatrix","viewL","projectionL","viewR","projectionR","_multiviewSceneUbo","dispose","updateFlag","multiplyToRef","GetPlanesToRef","GetPlanes","useUbo","_updateMultiviewUbo","_sceneUbo","updateMatrix","sceneUbo","addUniform","getUniqueId","UniqueId","addMesh","newMesh","recursive","_resyncLightSources","parent","_addToSceneRootNodes","getChildMeshes","forEach","m","removeMesh","toRemove","pop","_removeFromSceneRootNodes","_invalidateMesh","addTransformNode","newTransformNode","getScene","_indexInSceneTransformNodesArray","transformNodes","removeTransformNode","lastNode","removeSkeleton","skeletons","_executeActiveContainerCleanup","removeMorphTargetManager","morphTargetManagers","removeLight","lights","_removeLightSource","sortLightsByPriority","removeCamera","index2","removeParticleSystem","removeAnimation","animations","stopAnimation","target","animationName","targetMask","removeAnimationGroup","animationGroups","removeMultiMaterial","multiMaterials","removeMaterial","_indexInSceneMaterialArray","materials","lastMaterial","removeActionManager","actionManagers","removeTexture","textures","addLight","newLight","lightSources","sort","CompareLightsPriority","addCamera","newCamera","addSkeleton","newSkeleton","addParticleSystem","newParticleSystem","addAnimation","newAnimation","addAnimationGroup","newAnimationGroup","addMultiMaterial","newMultiMaterial","addMaterial","newMaterial","addMorphTargetManager","newMorphTargetManager","addGeometry","newGeometry","uniqueId","addActionManager","newActionManager","addTexture","newTexture","switchActiveCamera","getInputElement","setActiveCameraById","id","getCameraById","setActiveCameraByName","getCameraByName","getAnimationGroupByName","_getMaterial","allowMultiMaterials","predicate","getMaterialByUniqueID","getMaterialById","getMaterialByName","getLastMaterialById","getTextureByUniqueId","getTextureByName","getCameraByUniqueId","getBoneById","skeletonIndex","skeleton","boneIndex","bones","getBoneByName","getLightByName","getLightById","getLightByUniqueId","getParticleSystemById","getGeometryById","_getGeometryByUniqueId","pushGeometry","geometry","force","removeGeometry","lastGeometry","getGeometries","getMeshById","getMeshesById","filter","getTransformNodeById","getTransformNodeByUniqueId","getTransformNodesById","getMeshByUniqueId","getLastMeshById","getLastTransformNodeById","getLastEntryById","getNodeById","transformNode","light","bone","getNodeByName","getMeshByName","getTransformNodeByName","getLastSkeletonById","getSkeletonByUniqueId","getSkeletonById","getSkeletonByName","getMorphTargetManagerById","getMorphTargetById","managerIndex","morphTargetManager","numTargets","getTarget","getMorphTargetByName","getPostProcessByName","postProcessIndex","postProcesses","postProcess","isActiveMesh","uid","RandomId","addExternalData","key","_externalData","getExternalData","get","getOrAddExternalDataWithFactory","factory","getOrAddWithFactory","removeExternalData","_evaluateSubMesh","initialMesh","forcePush","isInFrustum","dispatch","freeProcessedMaterials","blockfreeActiveMeshesAndRenderingGroups","freeActiveMeshes","freeRenderingGroups","i","texture","renderList","_isInIntermediateRendering","freezeActiveMeshes","skipEvaluateActiveMeshes","onSuccess","onError","freezeMeshes","keepFrustumCulling","updateTransformMatrix","_evaluateActiveMeshes","_freeze","unfreezeActiveMeshes","_internalAbstractMeshDataInfo","_isActive","_unFreeze","container","snapshotRendering","snapshotRenderingMode","len","computeWorldMatrix","psLength","animate","resetSprites","_currentLODIsUpToDate","isBlocked","addCount","isEnabled","scaling","hasAZeroComponent","actionManager","hasSpecificTriggers2","pushNoDuplicate","meshToRender","customLODSelector","getLOD","_currentLOD","billboardMode","_preActivate","isVisible","layerMask","alwaysSelectAsActiveMesh","_activate","isAnInstance","_actAsRegularMesh","_onlyForInstances","_activeMesh","_postActivate","particleIndex","isStarted","emitter","position","dispatchParticles","sourceMesh","prepare","computeBonesUsingShaders","hasInstances","_renderingMultiview","leftCamera","_rigCameras","rightCamera","_bindFrameBuffer","_multiviewTexture","outputRenderTarget","_currentFrameBufferIsDefaultFrameBuffer","restoreDefaultFramebuffer","_clearFrameBuffer","rtt","onClearObservable","hasObservers","skipInitialClear","_cleared","_clear","_renderForCamera","rigParent","bindFrameBuffer","_skipRendering","Error","setViewport","viewport","softwareSkinnedMeshIndex","applySkeleton","isRenderTarget","needRebind","StartPerformanceCounter","renderIndex","renderTarget","_shouldRender","hasSpecialRenderTargetCamera","render","EndPerformanceCounter","_prepareFrame","_finalizeFrame","isIntermediate","_processSubCameras","cameraRigMode","_createMultiviewUbo","_useMultiviewToSingleView","_renderMultiviewToSingleView","_checkIntersections","actionIndex","actions","trigger","parameters","getTriggerParameter","otherMesh","areIntersecting","intersectsMesh","usePreciseIntersection","currentIntersectionInProgress","_intersectionsInProgress","_executeCurrent","CreateNew","hasSpecificTrigger","parameter","parameterMesh","_advancePhysicsEngineStep","_animate","isDeterministicLockStep","deltaTime","Math","max","MinDeltaTime","min","getDeltaTime","MaxDeltaTime","defaultFrameTime","defaultFPS","stepsTaken","maxSubSteps","getLockstepMaxSteps","internalSteps","floor","_checkCameraRenderTarget","isRigCamera","rigCameras","resetDrawCache","passId","updateCameras","ignoreAnimations","isDisposed","fetchNewFrame","processTrigger","cameraIndex","currentActiveCamera","customIndex","freezeMaterials","freeze","unfreezeMaterials","unfreeze","stopAllAnimations","animatable","onAnimationEndObservable","onAnimationEnd","activeRequests","slice","request","abort","e","console","error","_disposeList","item","wipeCaches","items","itemsCopy","clearCachedVertexData","meshIndex","clearCachedData","cleanCachedTextureBuffer","baseTexture","_buffer","getWorldExtends","filterPredicate","Number","MAX_VALUE","infiniteDistance","boundingInfo","getBoundingInfo","minBox","boundingBox","minimumWorld","maxBox","maximumWorld","CheckExtends","createPickingRay","world","createPickingRayToRef","result","createPickingRayInCameraSpace","createPickingRayInCameraSpaceToRef","_pickingAvailable","pick","fastCheck","trianglePredicate","pickWithBoundingInfo","pickWithRay","ray","multiPick","multiPickWithRay","setPointerOverMesh","getPointerOverMesh","_rebuildGeometries","_rebuild","rebuild","system","spriteManagers","spriteMgr","_rebuildTextures","_getByTags","list","tagsQuery","listByTags","MatchesQuery","getMeshesByTags","getCamerasByTags","getLightsByTags","getMaterialByTags","concat","getTransformNodesByTags","setRenderingOrder","renderingGroupId","opaqueSortCompareFn","alphaTestSortCompareFn","transparentSortCompareFn","setRenderingAutoClearDepthStencil","autoClearDepthStencil","depth","stencil","getAutoClearDepthStencilSetup","blockMaterialDirtyMechanism","flag","markAsDirty","_loadFile","fileOrUrl","onProgress","useOfflineSupport","useArrayBuffer","onOpened","offlineProvider","onCompleteObservable","_loadFileAsync","reject","exception","_requestFile","url","_requestFileAsync","_readFile","file","_readFileAsync","getPerfCollector","setActiveCameraByID","getMaterialByID","getLastMaterialByID","getTextureByUniqueID","getCameraByID","getCameraByUniqueID","getBoneByID","getLightByID","getLightByUniqueID","getParticleSystemByID","getGeometryByID","getMeshByID","getMeshByUniqueID","getLastMeshByID","getMeshesByID","getTransformNodeByID","getTransformNodeByUniqueID","getTransformNodesByID","getNodeByID","getLastEntryByID","getLastSkeletonByID","FOGMODE_EXP","FOGMODE_EXP2","FOGMODE_LINEAR"],"sourceRoot":""}