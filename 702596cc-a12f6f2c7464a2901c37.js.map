{"version":3,"file":"702596cc-a12f6f2c7464a2901c37.js","mappings":"wKAgCWA,E,iTACX,SAAWA,GAEPA,EAAyBA,EAA6C,mBAAI,GAAK,qBAE/EA,EAAyBA,EAAuC,aAAI,GAAK,eAEzEA,EAAyBA,EAAqC,WAAI,GAAK,YAC1E,CAPD,CAOGA,IAA6BA,EAA2B,CAAC,IAKrD,MAAMC,EAOT,6BAAOC,CAAuBC,GAC1B,MAAM,OAAY,mBACtB,CAMA,kCAAOC,GACH,MAAM,OAAY,8BACtB,CAIA,cAAIC,GACA,OAAOC,KAAKC,WAChB,CACA,cAAIF,CAAWG,GACPA,IAAUF,KAAKC,cACfD,KAAKC,YAAcC,EACnBF,KAAKG,8BAA8BC,gBAAgBJ,KAAKC,aAEhE,CASA,gCAAII,GACA,OAAOL,KAAKM,6BAChB,CAIA,uBAAIC,GACA,OAAOP,KAAKQ,oBAChB,CACA,uBAAID,CAAoBL,GACpB,GAAIA,IAAUF,KAAKQ,qBAAnB,CAIA,OADAR,KAAKQ,qBAAuBN,EACpBA,GACJ,KAAK,EACDF,KAAKS,qBAAsB,EAC3BT,KAAKU,kBAAkBC,4BAA6B,EACpDX,KAAKY,wBAAyB,EAC9BZ,KAAKa,WAAY,EACjB,MACJ,KAAK,EACDb,KAAKS,qBAAsB,EAC3BT,KAAKU,kBAAkBC,4BAA6B,EACpDX,KAAKY,wBAAyB,EAC9BZ,KAAKa,WAAY,EACjB,MACJ,KAAK,EACDb,KAAKS,qBAAsB,EAC3BT,KAAKU,kBAAkBC,4BAA6B,EACpDX,KAAKY,wBAAyB,EAC9BZ,KAAKa,WAAY,EAGzBb,KAAKc,4CAA4CV,gBAAgBF,EAtBjE,CAuBJ,CAIA,kBAAIa,CAAeb,GACXF,KAAKgB,kBAAoBd,IAG7BF,KAAKgB,gBAAkBd,EACvBF,KAAKiB,wBAAwB,IACjC,CACA,kBAAIF,GACA,OAAOf,KAAKgB,eAChB,CAIA,uBAAIP,CAAoBP,GAChBF,KAAKkB,uBAAyBhB,IAGlCF,KAAKkB,qBAAuBhB,EAChC,CACA,uBAAIO,GACA,OAAOT,KAAKkB,oBAChB,CAIA,oBAAIC,CAAiBjB,GACbF,KAAKoB,oBAAsBlB,IAG/BF,KAAKoB,kBAAoBlB,EACzBF,KAAKiB,wBAAwB,IACjC,CACA,oBAAIE,GACA,OAAOnB,KAAKoB,iBAChB,CAMA,sBAAIC,GACA,OAAOrB,KAAKsB,mBAChB,CAMA,sBAAID,CAAmBnB,GACfF,KAAKsB,sBAAwBpB,IAGjCF,KAAKsB,oBAAsBpB,EAC3BF,KAAKuB,sCAAsCnB,gBAAgBF,GAC3DF,KAAKiB,wBAAwB,GACjC,CAIA,QAAAO,GACI,IAAIC,EAAQ,GAMZ,OALAA,EAAQA,EAAMC,OAAO1B,KAAK2B,QAC1BF,EAAQA,EAAMC,OAAO1B,KAAK4B,QAC1BH,EAAQA,EAAMC,OAAO1B,KAAK6B,SAC1BJ,EAAQA,EAAMC,OAAO1B,KAAK8B,gBAC1B9B,KAAK+B,UAAUC,SAASC,GAAcR,EAAQA,EAAMC,OAAOO,EAASC,SAC7DT,CACX,CAIA,+BAAIU,GACA,OAAOnC,KAAKoC,4BAChB,CACA,+BAAID,CAA4BjC,GAC5BF,KAAKoC,6BAA+BlC,CACxC,CAEA,aAAImC,CAAUC,GACNtC,KAAKuC,oBACLvC,KAAKwC,oBAAoBC,OAAOzC,KAAKuC,oBAEzCvC,KAAKuC,mBAAqBvC,KAAKwC,oBAAoBE,IAAIJ,EAC3D,CAEA,gBAAIK,CAAaL,GACTtC,KAAK4C,yBACL5C,KAAK6C,yBAAyBJ,OAAOzC,KAAK4C,yBAE1CN,IACAtC,KAAK4C,wBAA0B5C,KAAK6C,yBAAyBH,IAAIJ,GAEzE,CAEA,eAAIQ,CAAYR,GACRtC,KAAK+C,wBACL/C,KAAKgD,wBAAwBP,OAAOzC,KAAK+C,wBAEzCT,IACAtC,KAAK+C,uBAAyB/C,KAAKgD,wBAAwBN,IAAIJ,GAEvE,CAEA,sBAAIW,CAAmBX,GACftC,KAAKkD,+BACLlD,KAAKmD,+BAA+BV,OAAOzC,KAAKkD,+BAEpDlD,KAAKkD,8BAAgClD,KAAKmD,+BAA+BT,IAAIJ,EACjF,CAEA,qBAAIc,CAAkBd,GACdtC,KAAKqD,8BACLrD,KAAKsD,8BAA8Bb,OAAOzC,KAAKqD,8BAEnDrD,KAAKqD,6BAA+BrD,KAAKsD,8BAA8BZ,IAAIJ,EAC/E,CAIA,wBAAIiB,GACA,OAAOvD,KAAKwD,6BAA6BD,oBAC7C,CACA,wBAAIA,CAAqBrD,GACrBF,KAAKwD,6BAA6BD,qBAAuBrD,CAC7D,CAIA,sBAAIuD,GACA,OAAOzD,KAAKwD,6BAA6BC,kBAC7C,CACA,sBAAIA,CAAmBvD,GACnBF,KAAKwD,6BAA6BC,mBAAqBvD,CAC3D,CAIA,wBAAIwD,GACA,OAAO1D,KAAKwD,6BAA6BE,oBAC7C,CACA,wBAAIA,CAAqBxD,GACrBF,KAAKwD,6BAA6BE,qBAAuBxD,CAC7D,CAIA,wBAAIyD,GACA,OAAO3D,KAAKwD,6BAA6BG,oBAC7C,CACA,wBAAIA,CAAqBzD,GACrBF,KAAKwD,6BAA6BG,qBAAuBzD,CAC7D,CAIA,sBAAI0D,GACA,OAAO5D,KAAKwD,6BAA6BI,kBAC7C,CACA,sBAAIA,CAAmB1D,GACnBF,KAAKwD,6BAA6BI,mBAAqB1D,CAC3D,CAIA,wBAAI2D,GACA,OAAO7D,KAAKwD,6BAA6BK,oBAC7C,CACA,wBAAIA,CAAqB3D,GACrBF,KAAKwD,6BAA6BK,qBAAuB3D,CAC7D,CAIA,0BAAIU,GACA,OAAOZ,KAAKwD,6BAA6B5C,sBAC7C,CACA,0BAAIA,CAAuBV,GACvBF,KAAKwD,6BAA6B5C,uBAAyBV,CAC/D,CAIA,0BAAI4D,GACA,OAAO9D,KAAKwD,6BAA6BM,sBAC7C,CACA,0BAAIA,CAAuB5D,GACvBF,KAAKwD,6BAA6BM,uBAAyB5D,CAC/D,CAIA,wBAAI6D,GACA,OAAO/D,KAAKwD,6BAA6BO,oBAC7C,CACA,wBAAIA,CAAqB7D,GACrBF,KAAKwD,6BAA6BO,qBAAuB7D,CAC7D,CAIA,uBAAI8D,GACA,OAAOhE,KAAKiE,cAAcD,mBAC9B,CAIA,gCAAWE,GACP,OAAO,IAAaA,qBACxB,CACA,gCAAWA,CAAsBhE,GAC7B,IAAagE,sBAAwBhE,CACzC,CAIA,yBAAWiE,GACP,OAAO,IAAaA,cACxB,CACA,yBAAWA,CAAejE,GACtB,IAAaiE,eAAiBjE,CAClC,CAIA,2BAAWkE,GACP,OAAO,IAAaA,gBACxB,CACA,2BAAWA,CAAiBlE,GACxB,IAAakE,iBAAmBlE,CACpC,CAEA,mCAAWmE,GACP,OAAO,IAAaA,wBACxB,CACA,mCAAWA,CAAyBnE,GAChC,IAAamE,yBAA2BnE,CAC5C,CAQA,eAAAoE,CAAgBC,EAAQC,EAAe,eAAgBC,GAAY,GAC/D,MAAMC,EAAc1E,KAAK2E,oBACnB3E,KAAK2E,oBACL3E,KAAK4E,wBACD5E,KAAK4E,wBACJ5E,KAAK6E,cAAcC,gBAAkB,KAAQC,aAClDC,EAAehF,KAAKiF,wBAA0D,MAAhCjF,KAAK4E,yBAUzD,OATA,KAAWM,QAAQ,GAAGC,IAAIT,EAAYU,EAAGV,EAAYW,EAAGX,EAAYY,EAAGN,GAAgB,EAAI,GACvFT,IACIE,EACAF,EAAOgB,UAAUf,EAAc,KAAWU,QAAQ,GAAGE,EAAG,KAAWF,QAAQ,GAAGG,EAAG,KAAWH,QAAQ,GAAGI,GAGvGf,EAAOiB,WAAWhB,EAAc,KAAWU,QAAQ,KAGpD,KAAWA,QAAQ,EAC9B,CAKA,gBAAAO,GACI,MAAMC,EAAM1F,KAAK2F,wBACXjB,EAAc1E,KAAKsE,gBAAgB,MAGzC,OAFAoB,EAAIE,aAAa,eAAgBlB,EAAYU,EAAGV,EAAYW,EAAGX,EAAYY,EAAGZ,EAAYmB,GAC1FH,EAAII,SACGJ,CACX,CAIA,wBAAIT,CAAqB/E,GACjBF,KAAK+F,wBAA0B7F,IAGnCF,KAAK+F,sBAAwB7F,EAC7BF,KAAKiB,wBAAwB,IACjC,CACA,wBAAIgE,GACA,OAAOjF,KAAK+F,qBAChB,CAMA,SAAAC,CAAUC,GACNjG,KAAKkG,eAAiBD,CAC1B,CAMA,SAAAE,GACI,OAAOnG,KAAKkG,cAChB,CAMA,eAAAE,GACI,OAAOpG,KAAKqG,oBAChB,CAMA,cAAIC,CAAWpG,GACPF,KAAKuG,cAAgBrG,IAGzBF,KAAKuG,YAAcrG,EACnBF,KAAKiB,wBAAwB,IACjC,CACA,cAAIqF,GACA,OAAOtG,KAAKuG,WAChB,CAWA,WAAIC,CAAQtG,GACJF,KAAKyG,WAAavG,IAGtBF,KAAKyG,SAAWvG,EAChBF,KAAKiB,wBAAwB,IACjC,CACA,WAAIuF,GACA,OAAOxG,KAAKyG,QAChB,CAIA,WAAIC,GACA,QAAS1G,KAAK2G,iBAAmB3G,KAAK2G,gBAAgBC,UAAUC,OACpE,CAIA,kBAAIC,CAAe5G,GACXF,KAAK+G,kBAAoB7G,IAG7BF,KAAK+G,gBAAkB7G,EACvBF,KAAKiB,wBAAwB,GACjC,CACA,kBAAI6F,GACA,OAAO9G,KAAK+G,eAChB,CAIA,iBAAIC,CAAc9G,GACVF,KAAKiH,iBAAmB/G,IAG5BF,KAAKiH,eAAiB/G,EACtBF,KAAKiB,wBAAwB,GACjC,CACA,iBAAI+F,GACA,OAAOhH,KAAKiH,cAChB,CAEA,iBAAIC,GACA,OAAOlH,KAAKmH,cAChB,CACA,iBAAID,CAAcrF,GACV7B,KAAKoH,0BACLpH,KAAKoH,0BACLpH,KAAKoH,wBAA0B,MAE/BvF,IACA7B,KAAKoH,yBAA0B,QAAcvF,GAAS,KAClD7B,KAAKqH,uBAAuBjH,gBAAgBJ,KAAK,KAGzDA,KAAKmH,eAAiBtF,CAC1B,CAEA,gBAAIgD,GACA,OAAO7E,KAAKsH,aAChB,CACA,gBAAIzC,CAAa3E,GACTA,IAAUF,KAAKsH,gBAGnBtH,KAAKsH,cAAgBpH,EACrBF,KAAKuH,sBAAsBnH,gBAAgBJ,MAC/C,CAEA,mBAAIwH,GAIA,OAHKxH,KAAKyH,mBACNzH,KAAKyH,iBAAmB9H,EAAMC,uBAAuBI,OAElDA,KAAKyH,gBAChB,CAEA,mBAAID,CAAgBtH,GAChBF,KAAKyH,iBAAmBvH,CAC5B,CAIA,mBAAIwH,CAAgBxH,GACZF,KAAK2H,mBAAqBzH,IAG9BF,KAAK2H,iBAAmBzH,EACxBF,KAAKiB,wBAAwB,GACjC,CACA,mBAAIyG,GACA,OAAO1H,KAAK2H,gBAChB,CAIA,cAAIC,GACA,OAAO5H,KAAK6H,WAChB,CACA,cAAID,CAAW1H,GACX,GAAIF,KAAK6H,YAKL,OAJA7H,KAAK6H,YAAc3H,OACdA,IACDF,KAAK8H,qBAAuB9H,KAAK+H,+BAIzC/H,KAAK6H,YAAc3H,EACfA,IACAF,KAAK+H,6BAA+B/H,KAAK8H,qBACzC9H,KAAK8H,qBAAuB9H,KAAKgI,sBAEzC,CAIA,oBAAIC,CAAiB/H,GACbF,KAAKkI,oBAAsBhI,IAG/BF,KAAKkI,kBAAoBhI,EACzBF,KAAKiB,wBAAwB,GACjC,CACA,oBAAIgH,GACA,OAAOjI,KAAKkI,iBAChB,CAEA,wBAAIC,GAKA,OAJKnI,KAAKoI,wBACNpI,KAAKoI,sBAAwBzI,EAAMG,8BACnCE,KAAKoI,sBAAsBC,KAAKrI,OAE7BA,KAAKoI,qBAChB,CAIA,oBAAIE,GACA,OAAOtI,KAAKU,iBAChB,CAIA,iBAAI6H,GACA,OAAOvI,KAAKwI,cAChB,CAIA,4BAAAC,GAEI,GAAIzI,KAAK0I,qBAAqBC,OAAS,EAAG,CACtC,IAAK,MAAMC,KAAa5I,KAAK0I,qBACzBE,EAAUC,WAEd7I,KAAK0I,qBAAqBC,OAAS,CACvC,CACJ,CAQA,aAAAG,CAAcF,GACV5I,KAAK+I,YAAYC,KAAKJ,GACtB5I,KAAK0I,qBAAqBM,KAAKJ,GAC/B,MAAMK,EAAwBL,EAC1BK,EAAsBC,kBAAoBD,EAAsBE,WAChEnJ,KAAKoJ,wBAAwBJ,KAAKC,EAE1C,CAOA,aAAAI,CAAcC,GACV,IAAK,MAAMV,KAAa5I,KAAK+I,YACzB,GAAIH,EAAUU,OAASA,EACnB,OAAOV,EAGf,OAAO,IACX,CAMA,WAAAW,CAAYC,EAAQC,GAEhBzJ,KAAKiE,cAAgB,IAAI,IAAajE,MAEtCA,KAAK0J,uBAAyB,KAE9B1J,KAAK2J,UAAW,EAEhB3J,KAAK4J,wBAAyB,EAI9B5J,KAAKa,WAAY,EAIjBb,KAAK6J,0BAA2B,EAChC7J,KAAKC,YAAc,IAAI,KAAO,GAAK,GAAK,GAAK,GAI7CD,KAAKG,8BAAgC,IAAI,KAIzCH,KAAK8J,aAAe,IAAI,KAAO,EAAG,EAAG,GAOrC9J,KAAK+J,qBAAuB,EAC5B/J,KAAKQ,qBAAuB,EAI5BR,KAAKc,4CAA8C,IAAI,KACvDd,KAAKgB,iBAAkB,EACvBhB,KAAKkB,sBAAuB,EAC5BlB,KAAKoB,mBAAoB,EAIzBpB,KAAKgK,UAAY,GAIjBhK,KAAK6B,QAAU,GAKf7B,KAAK4B,OAAS,GAId5B,KAAK2B,OAAS,GAKd3B,KAAK+B,UAAY,GAKjB/B,KAAKiK,gBAAkB,GAIvBjK,KAAKkK,WAAa,GAKlBlK,KAAKmK,gBAAkB,GAKvBnK,KAAKoK,eAAiB,GAQtBpK,KAAKqK,UAAY,GAKjBrK,KAAKsK,oBAAsB,GAI3BtK,KAAKuK,WAAa,GAQlBvK,KAAK8B,eAAiB,GAKtB9B,KAAKwK,eAAiB,GAItBxK,KAAKyK,SAAW,GAEhBzK,KAAKsB,oBAAsB,KAI3BtB,KAAK0K,cAAgB,GAMrB1K,KAAK2K,aAAe,GAIpB3K,KAAK4K,OAAS,KAId5K,KAAK6K,OAAS,GAKd7K,KAAK8K,iBAAmB,GAKxB9K,KAAK+K,mBAAqB,GAI1B/K,KAAKgL,mBAAoB,EACzBhL,KAAKoC,6BAA+B,KAKpCpC,KAAKiL,+BAAgC,EAKrCjL,KAAKkL,kCAAmC,EAIxClL,KAAKmL,YAAc,UAInBnL,KAAKoL,cAAgB,GAIrBpL,KAAKqL,oBAAqB,EAK1BrL,KAAKsL,6BAA8B,EAKnCtL,KAAKuL,2BAA4B,EAKjCvL,KAAKwL,SAAW,KAIhBxL,KAAKyL,kBAAoB,KAIzBzL,KAAK0L,oCAAsC,GAI3C1L,KAAKwC,oBAAsB,IAAI,KAC/BxC,KAAKuC,mBAAqB,KAI1BvC,KAAK6C,yBAA2B,IAAI,KACpC7C,KAAK4C,wBAA0B,KAI/B5C,KAAKgD,wBAA0B,IAAI,KAKnChD,KAAK2L,8BAAgC,IAAI,KACzC3L,KAAK+C,uBAAyB,KAI9B/C,KAAK4L,6BAA+B,IAAI,KAIxC5L,KAAK6L,4BAA8B,IAAI,KAIvC7L,KAAK8L,4BAA8B,IAAI,KAIvC9L,KAAK+L,2BAA6B,IAAI,KAItC/L,KAAKgM,kBAAoB,IAAI,KAI7BhM,KAAKmD,+BAAiC,IAAI,KAC1CnD,KAAKkD,8BAAgC,KAKrClD,KAAKsD,8BAAgC,IAAI,KACzCtD,KAAKqD,6BAA+B,KAIpCrD,KAAKiM,yCAA2C,IAAI,KAIpDjM,KAAKkM,wCAA0C,IAAI,KAKnDlM,KAAKmM,qCAAuC,IAAI,KAKhDnM,KAAKoM,oCAAsC,IAAI,KAI/CpM,KAAKqM,uBAAyB,IAAI,KAIlCrM,KAAKsM,2BAA6B,IAAI,KAItCtM,KAAKuM,0BAA4B,IAAI,KAIrCvM,KAAKwM,0BAA4B,IAAI,KAIrCxM,KAAKyM,yBAA2B,IAAI,KAIpCzM,KAAK0M,6BAA+B,IAAI,KAIxC1M,KAAK2M,4BAA8B,IAAI,KAIvC3M,KAAK4M,kCAAoC,IAAI,KAI7C5M,KAAK6M,iCAAmC,IAAI,KAI5C7M,KAAK8M,yBAA2B,IAAI,KAIpC9M,KAAK+M,wBAA0B,IAAI,KAInC/M,KAAKgN,6BAA+B,IAAI,KAIxChN,KAAKiN,4BAA8B,IAAI,KAIvCjN,KAAKkN,6BAA+B,IAAI,KAIxClN,KAAKmN,kCAAoC,IAAI,KAI7CnN,KAAKoN,4BAA8B,IAAI,KAIvCpN,KAAKqN,iCAAmC,IAAI,KAI5CrN,KAAKsN,4BAA8B,IAAI,KAIvCtN,KAAKuN,2BAA6B,IAAI,KAKtCvN,KAAKwN,sCAAwC,IAAI,KAKjDxN,KAAKyN,qCAAuC,IAAI,KAIhDzN,KAAK0N,uBAAyB,IAAI,KAIlC1N,KAAK2N,sBAAwB,IAAI,KAIjC3N,KAAKuH,sBAAwB,IAAI,KAIjCvH,KAAKqH,uBAAyB,IAAI,KAMlCrH,KAAK4N,iCAAmC,IAAI,KAM5C5N,KAAK6N,gCAAkC,IAAI,KAI3C7N,KAAK8N,yBAA2B,IAAI,KAIpC9N,KAAK+N,kCAAoC,IAAI,KAI7C/N,KAAKuB,sCAAwC,IAAI,KAIjDvB,KAAKgO,oCAAsC,IAAI,KAG/ChO,KAAKiO,oCAAsC,IAAI,IAAsB,KAErEjO,KAAKwD,6BAA+B,IAAI,IAKxCxD,KAAKkO,uBAAyB,IAAI,KAIlClO,KAAKmO,oBAAsB,IAAI,KAM/BnO,KAAKoO,wBAA0B,IAAI,KAInCpO,KAAKqO,qBAAuB,IAAI,KAEhCrO,KAAK+F,uBAAwB,EAE7B/F,KAAKsO,iBAAmB,EACxBtO,KAAKkG,eAAiB,EACtBlG,KAAKqG,qBAAuB,EAE5BrG,KAAKuG,aAAc,EACnBvG,KAAKyG,SAAW9G,EAAM4O,aAMtBvO,KAAKwO,SAAW,IAAI,KAAO,GAAK,GAAK,IAMrCxO,KAAKyO,WAAa,GAMlBzO,KAAK0O,SAAW,EAMhB1O,KAAK2O,OAAS,IAId3O,KAAK4O,4BAA6B,EAElC5O,KAAK+G,iBAAkB,EACvB/G,KAAKiH,gBAAiB,EACtBjH,KAAKoH,wBAA0B,KAE/BpH,KAAK2H,kBAAmB,EACxB3H,KAAK6H,YAAc,KAKnB7H,KAAK6O,gBAAiB,EAKtB7O,KAAK8O,kBAAmB,EAKxB9O,KAAK+O,gBAAiB,EAEtB/O,KAAKkI,mBAAoB,EAKzBlI,KAAKgP,mBAAoB,EAMzBhP,KAAKiP,mBAAoB,EAKzBjP,KAAKkP,QAAU,IAAI,KAAQ,GAAI,MAAO,GAKtClP,KAAKmP,sBAAuB,EAK5BnP,KAAKoP,sBAAuB,EAK5BpP,KAAKqP,uBAAwB,EAI7BrP,KAAKsP,oBAAsB,GAI3BtP,KAAKuP,oBAAsB,GAK3BvP,KAAKwP,eAAgB,EACrBxP,KAAKyP,wBAA0B,IAAI,IAAsB,KAKzDzP,KAAK0P,2BAA4B,EAEjC1P,KAAK2P,eAAiB,IAAI,IAE1B3P,KAAK4P,eAAiB,IAAI,IAE1B5P,KAAK6P,iBAAmB,IAAI,IAE5B7P,KAAK8P,aAAe,IAAI,IAExB9P,KAAK+P,eAAiB,EAKtB/P,KAAKgQ,mBAAqB,EAC1BhQ,KAAKiQ,UAAY,EACjBjQ,KAAKkQ,SAAW,EAChBlQ,KAAKmQ,2BAA6B,KAClCnQ,KAAKoQ,wBAAyB,EAC9BpQ,KAAKqQ,4BAA6B,EAClCrQ,KAAKsQ,iBAAmB,EACxBtQ,KAAKuQ,uBAAyB,EAE9BvQ,KAAKwQ,cAAgB,IAAIC,MAAM,KAC/BzQ,KAAK0Q,gBAAkB,IAAID,MAE3BzQ,KAAK2Q,aAAe,IAAIF,MACxBzQ,KAAK4Q,aAAc,EAKnB5Q,KAAK6Q,oCAAqC,EAC1C7Q,KAAK8Q,cAAgB,IAAI,IAAW,KACpC9Q,KAAK+Q,oBAAsB,IAAI,IAAW,KAC1C/Q,KAAKgR,eAAiB,IAAI,IAAsB,KAChDhR,KAAKiR,wBAA0B,IAAI,IAAsB,KAEzDjR,KAAKkR,uBAAyB,IAAI,IAAW,KAC7ClR,KAAKmR,iBAAmB,IAAI,IAAsB,IAClDnR,KAAKoR,uBAAyB,IAAI,IAAsB,IAExDpR,KAAKqR,mBAAqB,IAAIZ,MAC9BzQ,KAAKsR,iBAAmB,KAAOC,OAK/BvR,KAAKwR,qBAAsB,EAK3BxR,KAAK+I,YAAc,GAKnB/I,KAAKoJ,wBAA0B,GAI/BpJ,KAAK0I,qBAAuB,GAK5B1I,KAAKyR,yBAA2B,IAAMC,SAKtC1R,KAAK2R,kBAAoB,IAAMD,SAK/B1R,KAAK4R,8BAAgC,IAAMF,SAK3C1R,KAAK6R,0BAA4B,IAAMH,SAKvC1R,KAAK8R,sCAAwC,IAAMJ,SAKnD1R,KAAK+R,qBAAuB,IAAML,SAKlC1R,KAAKgS,+BAAiC,IAAMN,SAK5C1R,KAAKiS,sBAAwB,IAAMP,SAKnC1R,KAAKkS,oBAAsB,IAAMR,SAKjC1R,KAAKmS,6BAA+B,IAAMT,SAK1C1R,KAAKoS,uBAAyB,IAAMV,SAKpC1R,KAAKqS,6BAA+B,IAAMX,SAK1C1R,KAAKsS,+BAAiC,IAAMZ,SAK5C1R,KAAKuS,0BAA4B,IAAMb,SAKvC1R,KAAKwS,yBAA2B,IAAMd,SAKtC1R,KAAKyS,8BAAgC,IAAMf,SAK3C1R,KAAK0S,sBAAwB,IAAMhB,SAKnC1R,KAAK2S,6BAA+B,IAAMjB,SAK1C1R,KAAK4S,4BAA8B,IAAMlB,SAIzC1R,KAAK6S,mCAAqC,IAAMnB,SAKhD1R,KAAK8S,kBAAoB,IAAMpB,SAK/B1R,KAAK+S,kBAAoB,IAAMrB,SAK/B1R,KAAKgT,kBAAoB,IAAMtB,SAK/B1R,KAAKiT,gBAAkB,IAAMvB,SAI7B1R,KAAKkT,sBAAwB,KAC7BlT,KAAKmT,uBAAyB,CAC1BC,KAAM,GACNzK,OAAQ,GAEZ3I,KAAKqT,0BAA4B,CAC7BD,KAAM,GACNzK,OAAQ,GAEZ3I,KAAKsT,4CAA6C,EAElDtT,KAAKuT,qBAAsB,EAE3BvT,KAAKwT,oCAAqC,EAC1CxT,KAAKyT,qCAAsC,EAE3CzT,KAAK0T,6BAA8B,EAKnC1T,KAAK2T,0BAA4B,IACtB3T,KAAK4T,QAAQC,cAGxB7T,KAAK8T,mBAAqB,EAC1B9T,KAAK+T,8BAA+B,EAKpC/T,KAAKgU,eAAiB,KACtBhU,KAAKkH,cAAgB,GACrB,MAAM+M,EAAc,CAChBC,yBAAyB,EACzBC,oBAAoB,EACpBC,kBAAkB,EAClBC,SAAS,KACN5K,GAEPD,EAASxJ,KAAK4T,QAAUpK,GAAU,IAAY8K,kBAC1CL,EAAYI,QACZ7K,EAAO+K,eAAevL,KAAKhJ,OAG3B,IAAYwU,kBAAoBxU,KAChCwJ,EAAOiL,OAAOzL,KAAKhJ,OAEvBA,KAAK0U,KAAO,KACZ1U,KAAKU,kBAAoB,IAAI,IAAiBV,MAC1C,MACAA,KAAK2U,mBAAqB,IAAI,IAAmB3U,QAEjD,WACAA,KAAK4U,gBAGT5U,KAAK6U,aAED,MACA7U,KAAKM,8BAAgC,IAAI,KAE7CN,KAAK8U,+BACDb,EAAYC,0BACZlU,KAAKkT,sBAAwB,CAAC,GAElClT,KAAKmU,mBAAqBF,EAAYE,mBACtCnU,KAAKoU,iBAAmBH,EAAYG,iBAC/B3K,GAAYA,EAAQ4K,SACrB7K,EAAOuL,0BAA0B3U,gBAAgBJ,KAEzD,CAKA,YAAAgV,GACI,MAAO,OACX,CAIA,yBAAAC,GAGI,OAFAjV,KAAKmT,uBAAuBC,KAAOpT,KAAK2B,OACxC3B,KAAKmT,uBAAuBxK,OAAS3I,KAAK2B,OAAOgH,OAC1C3I,KAAKmT,sBAChB,CAIA,4BAAA+B,CAA6BC,GAGzB,OAFAnV,KAAKqT,0BAA0BD,KAAO+B,EAAKC,UAC3CpV,KAAKqT,0BAA0B1K,OAASwM,EAAKC,UAAUzM,OAChD3I,KAAKqT,yBAChB,CAMA,4BAAAyB,GACI9U,KAAKqV,wBAA0B,IAAMrV,KAAKiV,4BAC1CjV,KAAKsV,2BAA8BH,GAASnV,KAAKkV,6BAA6BC,GAC9EnV,KAAKuV,iCAAmC,CAACJ,EAAMK,IAAaxV,KAAKkV,6BAA6BC,GAC9FnV,KAAKyV,8BAAgC,CAACN,EAAMO,IAAa1V,KAAKkV,6BAA6BC,EAC/F,CAIA,oBAAIQ,GACA,OAAO3V,KAAKiE,cAAc0R,gBAC9B,CAIA,YAAIC,GACA,OAAO5V,KAAKiE,cAAc2R,QAC9B,CACA,YAAIA,CAAS1V,GACTF,KAAKiE,cAAc2R,SAAW1V,CAClC,CAIA,YAAI2V,GACA,OAAO7V,KAAKiE,cAAc4R,QAC9B,CACA,YAAIA,CAAS3V,GACTF,KAAKiE,cAAc4R,SAAW3V,CAClC,CAKA,iBAAA4V,GACI,OAAO9V,KAAK+V,eAChB,CAKA,eAAAC,GACI,OAAOhW,KAAKiW,aAChB,CAKA,mBAAAC,GACI,OAAOlW,KAAKmW,iBAChB,CAQA,uBAAAC,CAAwBC,EAAU9R,EAAQ+R,EAAa,GACnD,OAAOtW,KAAKiW,gBAAkB1R,GAAUvE,KAAK+V,kBAAoBM,GAAYrW,KAAKmW,oBAAsBG,CAC5G,CAKA,SAAAC,GACI,OAAOvW,KAAK4T,OAChB,CAKA,gBAAA4C,GACI,OAAOxW,KAAK2P,eAAe8G,OAC/B,CAKA,4BAAIC,GACA,OAAO1W,KAAK2P,cAChB,CAKA,gBAAAgH,GACI,OAAO3W,KAAK4P,eAAe6G,OAC/B,CAKA,iCAAIG,GACA,OAAO5W,KAAK4P,cAChB,CAKA,kBAAAiH,GACI,OAAO7W,KAAK6P,iBAAiB4G,OACjC,CAKA,8BAAIK,GACA,OAAO9W,KAAK6P,gBAChB,CAKA,cAAAkH,GACI,OAAO/W,KAAK8P,aAAa2G,OAC7B,CAKA,0BAAIO,GACA,OAAOhX,KAAK8P,YAChB,CAKA,eAAAmH,GACI,OAAOjX,KAAK8Q,aAChB,CAKA,iBAAAoG,GACI,YAAgCC,IAAzBnX,KAAKoX,gBAAgCpX,KAAKoX,gBAAkB,CACvE,CAKA,WAAAC,GACI,OAAOrX,KAAKiQ,SAChB,CAKA,UAAAqH,GACI,OAAOtX,KAAKkQ,QAChB,CAEA,iBAAAqH,GACIvX,KAAKiQ,WACT,CACA,UAAA4E,GACI7U,KAAKwX,sBAAsBxX,KAAKyX,2BACpC,CAQA,mBAAAC,CAAoBC,EAAYC,GAE5B,OADA5X,KAAKiE,cAAcyT,oBAAoBC,EAAYC,GAC5C5X,IACX,CAQA,mBAAA6X,CAAoBF,EAAYC,GAE5B,OADA5X,KAAKiE,cAAc4T,oBAAoBF,EAAYC,GAC5C5X,IACX,CASA,iBAAA8X,CAAkBH,EAAYC,EAAkBG,GAE5C,OADA/X,KAAKiE,cAAc6T,kBAAkBH,EAAYC,EAAkBG,GAC5D/X,IACX,CAMA,iBAAAgY,CAAkBC,EAAY,GAC1B,OAAOjY,KAAKiE,cAAc+T,kBAAkBC,EAChD,CAOA,aAAArD,CAAcsD,GAAW,EAAMC,GAAa,EAAMC,GAAa,GAC3DpY,KAAKiE,cAAc2Q,cAAcsD,EAAUC,EAAYC,EAC3D,CAEA,aAAAC,GACIrY,KAAKiE,cAAcoU,eACvB,CAOA,OAAAC,CAAQC,GAAqB,GACzB,GAAIvY,KAAK4Q,YACL,OAAO,EAEX,IAAI4H,EACJ,MAAMhP,EAASxJ,KAAKuW,YACdkC,EAAsBjP,EAAOiP,oBACnCjP,EAAOiP,oBAAsBzY,KAAK6E,cAAc6T,cAAgBD,EAChE,IAAIH,GAAU,EAgBd,IAdItY,KAAK2Q,aAAahI,OAAS,IAC3B2P,GAAU,GAGdtY,KAAK2G,iBAAiBb,SAElB9F,KAAK2Y,iCAAmC3Y,KAAK4Y,sBAC7CN,IAAYA,EAAUtY,KAAK4Y,qBAAqBN,WAGhDC,IACAvY,KAAK+Q,oBAAoB8H,QACzB7Y,KAAKiR,wBAAwB4H,SAE5BL,EAAQ,EAAGA,EAAQxY,KAAK2B,OAAOgH,OAAQ6P,IAAS,CACjD,MAAMrD,EAAOnV,KAAK2B,OAAO6W,GACzB,IAAKrD,EAAKC,WAAuC,IAA1BD,EAAKC,UAAUzM,OAClC,SAIJ,IAAKwM,EAAKmD,SAAQ,GAAO,CACrBA,GAAU,EACV,QACJ,CACA,MAAMQ,EAA6B3D,EAAK4D,kBACZ,kBAAxB5D,EAAKH,gBACmB,uBAAxBG,EAAKH,gBACJxL,EAAOwP,UAAUC,iBAAmB9D,EAAK+D,UAAUvQ,OAAS,EAEjE,IAAK,MAAMwQ,KAAQnZ,KAAK+R,qBACfoH,EAAKC,OAAOjE,EAAM2D,KACnBR,GAAU,GAGlB,IAAKC,EACD,SAEJ,MAAMc,EAAMlE,EAAKkB,UAAYrW,KAAKwH,gBAClC,GAAI6R,EACA,GAAIA,EAAIC,wBACJ,IAAK,MAAMC,KAAWpE,EAAKC,UAAW,CAClC,MAAMiB,EAAWkD,EAAQC,cACrBnD,GAAYA,EAASoD,yBAA+D,MAApCpD,EAASqD,0BACL,IAAhD1Z,KAAK+Q,oBAAoB4I,QAAQtD,KACjCrW,KAAK+Q,oBAAoB/H,KAAKqN,GAC9BrW,KAAKiR,wBAAwB2I,sBAAsBvD,EAASqD,2BAGxE,MAGIL,EAAII,yBAA0D,MAA/BJ,EAAIK,0BACY,IAA3C1Z,KAAK+Q,oBAAoB4I,QAAQN,KACjCrZ,KAAK+Q,oBAAoB/H,KAAKqQ,GAC9BrZ,KAAKiR,wBAAwB2I,sBAAsBP,EAAIK,2BAK3E,CAEA,GAAInB,EACA,IAAKC,EAAQ,EAAGA,EAAQxY,KAAKiR,wBAAwBtI,SAAU6P,EAAO,CACtDxY,KAAKiR,wBAAwBmC,KAAKoF,GACrCqB,wBACLvB,GAAU,EAElB,CAGJ,IAAKE,EAAQ,EAAGA,EAAQxY,KAAKuK,WAAW5B,OAAQ6P,IAAS,CAErB,IADfxY,KAAKuK,WAAWiO,GACpBsB,iBACTxB,GAAU,EAElB,CAEA,GAAItY,KAAKkH,eAAiBlH,KAAKkH,cAAcyB,OAAS,EAClD,IAAK,MAAMoR,KAAU/Z,KAAKkH,cACjB6S,EAAOzB,SAAQ,KAChBA,GAAU,QAIbtY,KAAK6E,eACL7E,KAAK6E,aAAayT,SAAQ,KAC3BA,GAAU,IAIlB,IAAK,MAAM0B,KAAkBha,KAAKiK,gBACzB+P,EAAe1B,YAChBA,GAAU,GAIlB,GAAItY,KAAK6K,OACL,IAAK,MAAMoP,KAASja,KAAK6K,OAChBoP,EAAM3B,YACPA,GAAU,GAStB,OAJK9O,EAAO0Q,uBACR5B,GAAU,GAEd9O,EAAOiP,oBAAsBA,EACtBH,CACX,CAEA,mBAAA6B,GACIna,KAAK+V,gBAAkB,KACvB/V,KAAKiW,cAAgB,KACrBjW,KAAKmW,kBAAoB,IAC7B,CAKA,oBAAAiE,CAAqBC,GACjBra,KAAK6C,yBAAyBH,IAAI2X,EACtC,CAKA,sBAAAC,CAAuBD,GACnBra,KAAK6C,yBAAyB0X,eAAeF,EACjD,CAKA,mBAAAG,CAAoBH,GAChBra,KAAKgD,wBAAwBN,IAAI2X,EACrC,CAKA,qBAAAI,CAAsBJ,GAClBra,KAAKgD,wBAAwBuX,eAAeF,EAChD,CACA,wBAAAK,CAAyBL,GACrB,MAAMM,EAAW,KACbN,IACAO,YAAW,KACP5a,KAAKsa,uBAAuBK,EAAS,GACvC,EAEN3a,KAAKoa,qBAAqBO,EAC9B,CAQA,uBAAAE,CAAwBR,EAAMS,QACV3D,IAAZ2D,EACAF,YAAW,KACP5a,KAAK0a,yBAAyBL,EAAK,GACpCS,GAGH9a,KAAK0a,yBAAyBL,EAEtC,CAKA,cAAAU,CAAe3H,GACXpT,KAAK2Q,aAAa3H,KAAKoK,EAC3B,CAKA,iBAAA4H,CAAkB5H,GACd,MAAM6H,EAAajb,KAAKkb,UAClB1C,EAAQxY,KAAK2Q,aAAagJ,QAAQvG,IACzB,IAAXoF,GACAxY,KAAK2Q,aAAawK,OAAO3C,EAAO,GAEhCyC,IAAejb,KAAKkb,WACpBlb,KAAKqM,uBAAuBjM,gBAAgBJ,KAEpD,CAKA,oBAAAob,GACI,OAAOpb,KAAK2Q,aAAahI,MAC7B,CAIA,aAAIuS,GACA,OAAOlb,KAAK2Q,aAAahI,OAAS,CACtC,CAMA,gBAAA0S,CAAiBhB,EAAM9B,GAAqB,GACxCvY,KAAKgM,kBAAkBsP,QAAQjB,GACS,OAApCra,KAAKmQ,4BAGTnQ,KAAKub,cAAchD,EACvB,CAMA,cAAAiD,CAAejD,GAAqB,GAChC,OAAO,IAAIkD,SAASC,IAChB1b,KAAKqb,kBAAiB,KAClBK,GAAS,GACVnD,EAAmB,GAE9B,CAIA,aAAAgD,CAAchD,GAAqB,GAE/B,OADAvY,KAAKyI,+BACDzI,KAAKsY,QAAQC,IACbvY,KAAKgM,kBAAkB5L,gBAAgBJ,MACvCA,KAAKgM,kBAAkB2P,aACvB3b,KAAKmQ,2BAA6B,OAGlCnQ,KAAK4Q,aACL5Q,KAAKgM,kBAAkB2P,aACvB3b,KAAKmQ,2BAA6B,YAGtCnQ,KAAKmQ,2BAA6ByK,YAAW,KAEzC5a,KAAKuX,oBACLvX,KAAKub,cAAchD,EAAmB,GACvC,KACP,CAIA,eAAIqD,GACA,OAAO5b,KAAKqR,kBAChB,CAKA,2BAAAwK,GACI7b,KAAK8b,mBAAqB,IAAcC,GAC5C,CAMA,aAAAC,GACI,OAAOhc,KAAKic,WAChB,CAKA,mBAAAC,GACI,OAAOlc,KAAKmc,iBAChB,CAKA,kBAAAC,GACI,OAAOpc,KAAKsR,gBAChB,CAQA,kBAAA+K,CAAmBC,EAAOC,EAAaC,EAAOC,GAErCD,GAAUC,IAAezc,KAAK0c,qBAC/B1c,KAAK0c,mBAAmBC,UACxB3c,KAAK0c,mBAAqB,MAE1B1c,KAAKsQ,kBAAoBgM,EAAMM,YAAc5c,KAAKuQ,wBAA0BgM,EAAYK,aAG5F5c,KAAKsQ,gBAAkBgM,EAAMM,WAC7B5c,KAAKuQ,sBAAwBgM,EAAYK,WACzC5c,KAAKic,YAAcK,EACnBtc,KAAKmc,kBAAoBI,EACzBvc,KAAKic,YAAYY,cAAc7c,KAAKmc,kBAAmBnc,KAAKsR,kBAEvDtR,KAAKwI,eAIN,IAAQsU,eAAe9c,KAAKsR,iBAAkBtR,KAAKwI,gBAHnDxI,KAAKwI,eAAiB,IAAQuU,UAAU/c,KAAKsR,kBAK7CtR,KAAK0c,oBAAsB1c,KAAK0c,mBAAmBM,OACnDhd,KAAKid,oBAAoBT,EAAOC,GAE3Bzc,KAAKkd,UAAUF,SACpBhd,KAAKkd,UAAUC,aAAa,iBAAkBnd,KAAKsR,kBACnDtR,KAAKkd,UAAUC,aAAa,OAAQnd,KAAKic,aACzCjc,KAAKkd,UAAUC,aAAa,aAAcnd,KAAKmc,oBAEvD,CAKA,qBAAAxW,GACI,OAAO3F,KAAK0c,mBAAqB1c,KAAK0c,mBAAqB1c,KAAKkd,SACpE,CAMA,wBAAAzF,CAAyBnO,GACrB,MAAM8T,EAAW,IAAI,IAAcpd,KAAK4T,aAASuD,GAAW,EAAO7N,GAAQ,SAK3E,OAJA8T,EAASC,WAAW,iBAAkB,IACtCD,EAASC,WAAW,OAAQ,IAC5BD,EAASC,WAAW,aAAc,IAClCD,EAASC,WAAW,eAAgB,GAC7BD,CACX,CAKA,qBAAA5F,CAAsB9R,GAClB1F,KAAKkd,UAAYxX,EACjB1F,KAAKsQ,iBAAmB,EACxBtQ,KAAKuQ,uBAAyB,CAClC,CAKA,WAAA+M,GACI,OAAO,IAAkBC,QAC7B,CAMA,OAAAC,CAAQC,EAASC,GAAY,GACrB1d,KAAK4J,yBAGT5J,KAAK2B,OAAOqH,KAAKyU,GACjBA,EAAQE,sBACHF,EAAQG,QACTH,EAAQI,uBAEZ,KAAMC,cAAa,KACf9d,KAAK8M,yBAAyB1M,gBAAgBqd,EAAQ,IAEtDC,GACAD,EAAQM,iBAAiB/b,SAASgc,IAC9Bhe,KAAKwd,QAAQQ,EAAE,IAG3B,CAOA,UAAAC,CAAWC,EAAUR,GAAY,GAC7B,MAAMlF,EAAQxY,KAAK2B,OAAOgY,QAAQuE,GAelC,OAde,IAAX1F,IAEAxY,KAAK2B,OAAOwZ,OAAO3C,EAAO,GACrB0F,EAASN,QACVM,EAASC,6BAGjBne,KAAKiE,cAAcma,gBAAgBF,GACnCle,KAAK+M,wBAAwB3M,gBAAgB8d,GACzCR,GACAQ,EAASH,iBAAiB/b,SAASgc,IAC/Bhe,KAAKie,WAAWD,EAAE,IAGnBxF,CACX,CAKA,gBAAA6F,CAAiBC,GACTte,KAAK4J,wBAGL0U,EAAiBC,aAAeve,OAA+D,IAAvDse,EAAiBE,mCAI7DF,EAAiBE,iCAAmCxe,KAAK8B,eAAe6G,OACxE3I,KAAK8B,eAAekH,KAAKsV,GACpBA,EAAiBV,QAClBU,EAAiBT,uBAErB7d,KAAK4M,kCAAkCxM,gBAAgBke,GAC3D,CAMA,mBAAAG,CAAoBP,GAChB,MAAM1F,EAAQ0F,EAASM,iCACvB,IAAe,IAAXhG,EAAc,CACd,GAAIA,IAAUxY,KAAK8B,eAAe6G,OAAS,EAAG,CAC1C,MAAM+V,EAAW1e,KAAK8B,eAAe9B,KAAK8B,eAAe6G,OAAS,GAClE3I,KAAK8B,eAAe0W,GAASkG,EAC7BA,EAASF,iCAAmChG,CAChD,CACA0F,EAASM,kCAAoC,EAC7Cxe,KAAK8B,eAAe6c,MACfT,EAASN,QACVM,EAASC,2BAEjB,CAEA,OADAne,KAAK6M,iCAAiCzM,gBAAgB8d,GAC/C1F,CACX,CAMA,cAAAoG,CAAeV,GACX,MAAM1F,EAAQxY,KAAK+B,UAAU4X,QAAQuE,GAQrC,OAPe,IAAX1F,IAEAxY,KAAK+B,UAAUoZ,OAAO3C,EAAO,GAC7BxY,KAAKiN,4BAA4B7M,gBAAgB8d,GAEjDle,KAAK6e,+BAA+B7e,KAAKmR,mBAEtCqH,CACX,CAMA,wBAAAsG,CAAyBZ,GACrB,MAAM1F,EAAQxY,KAAKsK,oBAAoBqP,QAAQuE,GAK/C,OAJe,IAAX1F,GAEAxY,KAAKsK,oBAAoB6Q,OAAO3C,EAAO,GAEpCA,CACX,CAMA,WAAAuG,CAAYb,GACR,MAAM1F,EAAQxY,KAAK4B,OAAO+X,QAAQuE,GAClC,IAAe,IAAX1F,EAAc,CAEd,IAAK,MAAMrD,KAAQnV,KAAK2B,OACpBwT,EAAK6J,mBAAmBd,GAAU,GAGtCle,KAAK4B,OAAOuZ,OAAO3C,EAAO,GAC1BxY,KAAKif,uBACAf,EAASN,QACVM,EAASC,2BAEjB,CAEA,OADAne,KAAKyM,yBAAyBrM,gBAAgB8d,GACvC1F,CACX,CAMA,YAAA0G,CAAahB,GACT,MAAM1F,EAAQxY,KAAK6B,QAAQ8X,QAAQuE,GASnC,IARe,IAAX1F,IAEAxY,KAAK6B,QAAQsZ,OAAO3C,EAAO,GACtB0F,EAASN,QACVM,EAASC,6BAIbne,KAAKkH,cAAe,CACpB,MAAMiY,EAASnf,KAAKkH,cAAcyS,QAAQuE,IAC1B,IAAZiB,GAEAnf,KAAKkH,cAAciU,OAAOgE,EAAQ,EAE1C,CAWA,OATInf,KAAK6E,eAAiBqZ,IAClBle,KAAK6B,QAAQ8G,OAAS,EACtB3I,KAAK6E,aAAe7E,KAAK6B,QAAQ,GAGjC7B,KAAK6E,aAAe,MAG5B7E,KAAKuM,0BAA0BnM,gBAAgB8d,GACxC1F,CACX,CAMA,oBAAA4G,CAAqBlB,GACjB,MAAM1F,EAAQxY,KAAKiK,gBAAgB0P,QAAQuE,GAM3C,OALe,IAAX1F,IACAxY,KAAKiK,gBAAgBkR,OAAO3C,EAAO,GAEnCxY,KAAK6e,+BAA+B7e,KAAKkR,yBAEtCsH,CACX,CAMA,eAAA6G,CAAgBnB,GACZ,MAAM1F,EAAQxY,KAAKkK,WAAWyP,QAAQuE,GAItC,OAHe,IAAX1F,GACAxY,KAAKkK,WAAWiR,OAAO3C,EAAO,GAE3BA,CACX,CAOA,aAAA8G,CAAcC,EAAQC,EAAeC,GAErC,CAMA,oBAAAC,CAAqBxB,GACjB,MAAM1F,EAAQxY,KAAKmK,gBAAgBwP,QAAQuE,GAI3C,OAHe,IAAX1F,GACAxY,KAAKmK,gBAAgBgR,OAAO3C,EAAO,GAEhCA,CACX,CAMA,mBAAAmH,CAAoBzB,GAChB,MAAM1F,EAAQxY,KAAKoK,eAAeuP,QAAQuE,GAK1C,OAJe,IAAX1F,GACAxY,KAAKoK,eAAe+Q,OAAO3C,EAAO,GAEtCxY,KAAKqN,iCAAiCjN,gBAAgB8d,GAC/C1F,CACX,CAMA,cAAAoH,CAAe1B,GACX,MAAM1F,EAAQ0F,EAAS2B,2BACvB,IAAe,IAAXrH,GAAgBA,EAAQxY,KAAKqK,UAAU1B,OAAQ,CAC/C,GAAI6P,IAAUxY,KAAKqK,UAAU1B,OAAS,EAAG,CACrC,MAAMmX,EAAe9f,KAAKqK,UAAUrK,KAAKqK,UAAU1B,OAAS,GAC5D3I,KAAKqK,UAAUmO,GAASsH,EACxBA,EAAaD,2BAA6BrH,CAC9C,CACA0F,EAAS2B,4BAA8B,EACvC7f,KAAKqK,UAAUsU,KACnB,CAEA,OADA3e,KAAKoN,4BAA4BhN,gBAAgB8d,GAC1C1F,CACX,CAOA,mBAAAuH,CAAoB7B,GAChB,MAAM1F,EAAQxY,KAAKwK,eAAemP,QAAQuE,GAI1C,OAHe,IAAX1F,GACAxY,KAAKwK,eAAe2Q,OAAO3C,EAAO,GAE/BA,CACX,CAMA,aAAAwH,CAAc9B,GACV,MAAM1F,EAAQxY,KAAKyK,SAASkP,QAAQuE,GAKpC,OAJe,IAAX1F,GACAxY,KAAKyK,SAAS0Q,OAAO3C,EAAO,GAEhCxY,KAAKuN,2BAA2BnN,gBAAgB8d,GACzC1F,CACX,CAKA,QAAAyH,CAASC,GACL,IAAIlgB,KAAK4J,uBAAT,CAGA5J,KAAK4B,OAAOoH,KAAKkX,GACjBlgB,KAAKif,uBACAiB,EAAStC,QACVsC,EAASrC,uBAGb,IAAK,MAAM1I,KAAQnV,KAAK2B,QACyB,IAAzCwT,EAAKgL,aAAaxG,QAAQuG,KAC1B/K,EAAKgL,aAAanX,KAAKkX,GACvB/K,EAAKwI,uBAGb,KAAMG,cAAa,KACf9d,KAAKwM,0BAA0BpM,gBAAgB8f,EAAS,GAd5D,CAgBJ,CAIA,oBAAAjB,GACQjf,KAAKwR,qBACLxR,KAAK4B,OAAOwe,KAAK,IAAeC,sBAExC,CAKA,SAAAC,CAAUC,GACFvgB,KAAK4J,yBAGT5J,KAAK6B,QAAQmH,KAAKuX,GAClB,KAAMzC,cAAa,KACf9d,KAAKsM,2BAA2BlM,gBAAgBmgB,EAAU,IAEzDA,EAAU3C,QACX2C,EAAU1C,uBAElB,CAKA,WAAA2C,CAAYC,GACJzgB,KAAK4J,yBAGT5J,KAAK+B,UAAUiH,KAAKyX,GACpB,KAAM3C,cAAa,KACf9d,KAAKgN,6BAA6B5M,gBAAgBqgB,EAAY,IAEtE,CAKA,iBAAAC,CAAkBC,GACV3gB,KAAK4J,wBAGT5J,KAAKiK,gBAAgBjB,KAAK2X,EAC9B,CAKA,YAAAC,CAAaC,GACL7gB,KAAK4J,wBAGT5J,KAAKkK,WAAWlB,KAAK6X,EACzB,CAKA,iBAAAC,CAAkBC,GACV/gB,KAAK4J,wBAGT5J,KAAKmK,gBAAgBnB,KAAK+X,EAC9B,CAKA,gBAAAC,CAAiBC,GACTjhB,KAAK4J,yBAGT5J,KAAKoK,eAAepB,KAAKiY,GACzB,KAAMnD,cAAa,KACf9d,KAAKmN,kCAAkC/M,gBAAgB6gB,EAAiB,IAEhF,CAKA,WAAAC,CAAYC,GACJnhB,KAAK4J,wBAGLuX,EAAY5C,aAAeve,OAAoD,IAA5CmhB,EAAYtB,6BAInDsB,EAAYtB,2BAA6B7f,KAAKqK,UAAU1B,OACxD3I,KAAKqK,UAAUrB,KAAKmY,GACpB,KAAMrD,cAAa,KACf9d,KAAKkN,6BAA6B9M,gBAAgB+gB,EAAY,IAEtE,CAKA,qBAAAC,CAAsBC,GACdrhB,KAAK4J,wBAGT5J,KAAKsK,oBAAoBtB,KAAKqY,EAClC,CAKA,WAAAC,CAAYC,GACJvhB,KAAK4J,yBAGL5J,KAAKkT,wBACLlT,KAAKkT,sBAAsBqO,EAAYC,UAAYxhB,KAAKuK,WAAW5B,QAEvE3I,KAAKuK,WAAWvB,KAAKuY,GACzB,CAMA,gBAAAE,CAAiBC,GACb1hB,KAAKwK,eAAexB,KAAK0Y,EAC7B,CAKA,UAAAC,CAAWC,GACH5hB,KAAK4J,yBAGT5J,KAAKyK,SAASzB,KAAK4Y,GACnB5hB,KAAKsN,4BAA4BlN,gBAAgBwhB,GACrD,CAMA,kBAAAC,CAAmBtB,EAAW3L,GAAgB,GAC3B5U,KAAK4T,QAAQkO,oBAIxB9hB,KAAK6E,cACL7E,KAAK6E,aAAawT,gBAEtBrY,KAAK6E,aAAe0b,EAChB3L,GACA2L,EAAU3L,gBAElB,CAMA,mBAAAmN,CAAoBC,GAChB,MAAMjI,EAAS/Z,KAAKiiB,cAAcD,GAClC,OAAIjI,GACA/Z,KAAK6E,aAAekV,EACbA,GAEJ,IACX,CAMA,qBAAAmI,CAAsB5Y,GAClB,MAAMyQ,EAAS/Z,KAAKmiB,gBAAgB7Y,GACpC,OAAIyQ,GACA/Z,KAAK6E,aAAekV,EACbA,GAEJ,IACX,CAMA,uBAAAqI,CAAwB9Y,GACpB,IAAK,IAAIkP,EAAQ,EAAGA,EAAQxY,KAAKmK,gBAAgBxB,OAAQ6P,IACrD,GAAIxY,KAAKmK,gBAAgBqO,GAAOlP,OAASA,EACrC,OAAOtJ,KAAKmK,gBAAgBqO,GAGpC,OAAO,IACX,CACA,YAAA6J,CAAaC,EAAqBC,GAC9B,IAAK,IAAI/J,EAAQ,EAAGA,EAAQxY,KAAKqK,UAAU1B,OAAQ6P,IAAS,CACxD,MAAMnC,EAAWrW,KAAKqK,UAAUmO,GAChC,GAAI+J,EAAUlM,GACV,OAAOA,CAEf,CACA,GAAIiM,EACA,IAAK,IAAI9J,EAAQ,EAAGA,EAAQxY,KAAKoK,eAAezB,OAAQ6P,IAAS,CAC7D,MAAMnC,EAAWrW,KAAKoK,eAAeoO,GACrC,GAAI+J,EAAUlM,GACV,OAAOA,CAEf,CAEJ,OAAO,IACX,CAOA,qBAAAmM,CAAsBhB,EAAUc,GAAsB,GAClD,OAAOtiB,KAAKqiB,aAAaC,GAAsBtE,GAAMA,EAAEwD,WAAaA,GACxE,CAOA,eAAAiB,CAAgBT,EAAIM,GAAsB,GACtC,OAAOtiB,KAAKqiB,aAAaC,GAAsBtE,GAAMA,EAAEgE,KAAOA,GAClE,CAOA,iBAAAU,CAAkBpZ,EAAMgZ,GAAsB,GAC1C,OAAOtiB,KAAKqiB,aAAaC,GAAsBtE,GAAMA,EAAE1U,OAASA,GACpE,CAOA,mBAAAqZ,CAAoBX,EAAIM,GAAsB,GAC1C,IAAK,IAAI9J,EAAQxY,KAAKqK,UAAU1B,OAAS,EAAG6P,GAAS,EAAGA,IACpD,GAAIxY,KAAKqK,UAAUmO,GAAOwJ,KAAOA,EAC7B,OAAOhiB,KAAKqK,UAAUmO,GAG9B,GAAI8J,EACA,IAAK,IAAI9J,EAAQxY,KAAKoK,eAAezB,OAAS,EAAG6P,GAAS,EAAGA,IACzD,GAAIxY,KAAKoK,eAAeoO,GAAOwJ,KAAOA,EAClC,OAAOhiB,KAAKoK,eAAeoO,GAIvC,OAAO,IACX,CAMA,oBAAAoK,CAAqBpB,GACjB,IAAK,IAAIhJ,EAAQ,EAAGA,EAAQxY,KAAKyK,SAAS9B,OAAQ6P,IAC9C,GAAIxY,KAAKyK,SAAS+N,GAAOgJ,WAAaA,EAClC,OAAOxhB,KAAKyK,SAAS+N,GAG7B,OAAO,IACX,CAMA,gBAAAqK,CAAiBvZ,GACb,IAAK,IAAIkP,EAAQ,EAAGA,EAAQxY,KAAKyK,SAAS9B,OAAQ6P,IAC9C,GAAIxY,KAAKyK,SAAS+N,GAAOlP,OAASA,EAC9B,OAAOtJ,KAAKyK,SAAS+N,GAG7B,OAAO,IACX,CAMA,aAAAyJ,CAAcD,GACV,IAAK,IAAIxJ,EAAQ,EAAGA,EAAQxY,KAAK6B,QAAQ8G,OAAQ6P,IAC7C,GAAIxY,KAAK6B,QAAQ2W,GAAOwJ,KAAOA,EAC3B,OAAOhiB,KAAK6B,QAAQ2W,GAG5B,OAAO,IACX,CAMA,mBAAAsK,CAAoBtB,GAChB,IAAK,IAAIhJ,EAAQ,EAAGA,EAAQxY,KAAK6B,QAAQ8G,OAAQ6P,IAC7C,GAAIxY,KAAK6B,QAAQ2W,GAAOgJ,WAAaA,EACjC,OAAOxhB,KAAK6B,QAAQ2W,GAG5B,OAAO,IACX,CAMA,eAAA2J,CAAgB7Y,GACZ,IAAK,IAAIkP,EAAQ,EAAGA,EAAQxY,KAAK6B,QAAQ8G,OAAQ6P,IAC7C,GAAIxY,KAAK6B,QAAQ2W,GAAOlP,OAASA,EAC7B,OAAOtJ,KAAK6B,QAAQ2W,GAG5B,OAAO,IACX,CAMA,WAAAuK,CAAYf,GACR,IAAK,IAAIgB,EAAgB,EAAGA,EAAgBhjB,KAAK+B,UAAU4G,OAAQqa,IAAiB,CAChF,MAAM/gB,EAAWjC,KAAK+B,UAAUihB,GAChC,IAAK,IAAIC,EAAY,EAAGA,EAAYhhB,EAASC,MAAMyG,OAAQsa,IACvD,GAAIhhB,EAASC,MAAM+gB,GAAWjB,KAAOA,EACjC,OAAO/f,EAASC,MAAM+gB,EAGlC,CACA,OAAO,IACX,CAMA,aAAAC,CAAc5Z,GACV,IAAK,IAAI0Z,EAAgB,EAAGA,EAAgBhjB,KAAK+B,UAAU4G,OAAQqa,IAAiB,CAChF,MAAM/gB,EAAWjC,KAAK+B,UAAUihB,GAChC,IAAK,IAAIC,EAAY,EAAGA,EAAYhhB,EAASC,MAAMyG,OAAQsa,IACvD,GAAIhhB,EAASC,MAAM+gB,GAAW3Z,OAASA,EACnC,OAAOrH,EAASC,MAAM+gB,EAGlC,CACA,OAAO,IACX,CAMA,cAAAE,CAAe7Z,GACX,IAAK,IAAIkP,EAAQ,EAAGA,EAAQxY,KAAK4B,OAAO+G,OAAQ6P,IAC5C,GAAIxY,KAAK4B,OAAO4W,GAAOlP,OAASA,EAC5B,OAAOtJ,KAAK4B,OAAO4W,GAG3B,OAAO,IACX,CAMA,YAAA4K,CAAapB,GACT,IAAK,IAAIxJ,EAAQ,EAAGA,EAAQxY,KAAK4B,OAAO+G,OAAQ6P,IAC5C,GAAIxY,KAAK4B,OAAO4W,GAAOwJ,KAAOA,EAC1B,OAAOhiB,KAAK4B,OAAO4W,GAG3B,OAAO,IACX,CAMA,kBAAA6K,CAAmB7B,GACf,IAAK,IAAIhJ,EAAQ,EAAGA,EAAQxY,KAAK4B,OAAO+G,OAAQ6P,IAC5C,GAAIxY,KAAK4B,OAAO4W,GAAOgJ,WAAaA,EAChC,OAAOxhB,KAAK4B,OAAO4W,GAG3B,OAAO,IACX,CAMA,qBAAA8K,CAAsBtB,GAClB,IAAK,IAAIxJ,EAAQ,EAAGA,EAAQxY,KAAKiK,gBAAgBtB,OAAQ6P,IACrD,GAAIxY,KAAKiK,gBAAgBuO,GAAOwJ,KAAOA,EACnC,OAAOhiB,KAAKiK,gBAAgBuO,GAGpC,OAAO,IACX,CAMA,eAAA+K,CAAgBvB,GACZ,IAAK,IAAIxJ,EAAQ,EAAGA,EAAQxY,KAAKuK,WAAW5B,OAAQ6P,IAChD,GAAIxY,KAAKuK,WAAWiO,GAAOwJ,KAAOA,EAC9B,OAAOhiB,KAAKuK,WAAWiO,GAG/B,OAAO,IACX,CACA,sBAAAgL,CAAuBhC,GACnB,GAAIxhB,KAAKkT,sBAAuB,CAC5B,MAAMsF,EAAQxY,KAAKkT,sBAAsBsO,GACzC,QAAcrK,IAAVqB,EACA,OAAOxY,KAAKuK,WAAWiO,EAE/B,MAEI,IAAK,IAAIA,EAAQ,EAAGA,EAAQxY,KAAKuK,WAAW5B,OAAQ6P,IAChD,GAAIxY,KAAKuK,WAAWiO,GAAOgJ,WAAaA,EACpC,OAAOxhB,KAAKuK,WAAWiO,GAInC,OAAO,IACX,CAOA,YAAAiL,CAAaC,EAAUC,GACnB,SAAKA,GAAS3jB,KAAKwjB,uBAAuBE,EAASlC,aAGnDxhB,KAAKshB,YAAYoC,GACjB,KAAM5F,cAAa,KACf9d,KAAK0M,6BAA6BtM,gBAAgBsjB,EAAS,KAExD,EACX,CAMA,cAAAE,CAAeF,GACX,IAAIlL,EACJ,GAAIxY,KAAKkT,uBAEL,GADAsF,EAAQxY,KAAKkT,sBAAsBwQ,EAASlC,eAC9BrK,IAAVqB,EACA,OAAO,OAKX,GADAA,EAAQxY,KAAKuK,WAAWoP,QAAQ+J,GAC5BlL,EAAQ,EACR,OAAO,EAGf,GAAIA,IAAUxY,KAAKuK,WAAW5B,OAAS,EAAG,CACtC,MAAMkb,EAAe7jB,KAAKuK,WAAWvK,KAAKuK,WAAW5B,OAAS,GAC1Dkb,IACA7jB,KAAKuK,WAAWiO,GAASqL,EACrB7jB,KAAKkT,wBACLlT,KAAKkT,sBAAsB2Q,EAAarC,UAAYhJ,GAGhE,CAMA,OALIxY,KAAKkT,wBACLlT,KAAKkT,sBAAsBwQ,EAASlC,eAAYrK,GAEpDnX,KAAKuK,WAAWoU,MAChB3e,KAAK2M,4BAA4BvM,gBAAgBsjB,IAC1C,CACX,CAKA,aAAAI,GACI,OAAO9jB,KAAKuK,UAChB,CAMA,WAAAwZ,CAAY/B,GACR,IAAK,IAAIxJ,EAAQ,EAAGA,EAAQxY,KAAK2B,OAAOgH,OAAQ6P,IAC5C,GAAIxY,KAAK2B,OAAO6W,GAAOwJ,KAAOA,EAC1B,OAAOhiB,KAAK2B,OAAO6W,GAG3B,OAAO,IACX,CAMA,aAAAwL,CAAchC,GACV,OAAOhiB,KAAK2B,OAAOsiB,QAAO,SAAUjG,GAChC,OAAOA,EAAEgE,KAAOA,CACpB,GACJ,CAMA,oBAAAkC,CAAqBlC,GACjB,IAAK,IAAIxJ,EAAQ,EAAGA,EAAQxY,KAAK8B,eAAe6G,OAAQ6P,IACpD,GAAIxY,KAAK8B,eAAe0W,GAAOwJ,KAAOA,EAClC,OAAOhiB,KAAK8B,eAAe0W,GAGnC,OAAO,IACX,CAMA,0BAAA2L,CAA2B3C,GACvB,IAAK,IAAIhJ,EAAQ,EAAGA,EAAQxY,KAAK8B,eAAe6G,OAAQ6P,IACpD,GAAIxY,KAAK8B,eAAe0W,GAAOgJ,WAAaA,EACxC,OAAOxhB,KAAK8B,eAAe0W,GAGnC,OAAO,IACX,CAMA,qBAAA4L,CAAsBpC,GAClB,OAAOhiB,KAAK8B,eAAemiB,QAAO,SAAUjG,GACxC,OAAOA,EAAEgE,KAAOA,CACpB,GACJ,CAMA,iBAAAqC,CAAkB7C,GACd,IAAK,IAAIhJ,EAAQ,EAAGA,EAAQxY,KAAK2B,OAAOgH,OAAQ6P,IAC5C,GAAIxY,KAAK2B,OAAO6W,GAAOgJ,WAAaA,EAChC,OAAOxhB,KAAK2B,OAAO6W,GAG3B,OAAO,IACX,CAMA,eAAA8L,CAAgBtC,GACZ,IAAK,IAAIxJ,EAAQxY,KAAK2B,OAAOgH,OAAS,EAAG6P,GAAS,EAAGA,IACjD,GAAIxY,KAAK2B,OAAO6W,GAAOwJ,KAAOA,EAC1B,OAAOhiB,KAAK2B,OAAO6W,GAG3B,OAAO,IACX,CAMA,wBAAA+L,CAAyBvC,GACrB,IAAK,IAAIxJ,EAAQxY,KAAK8B,eAAe6G,OAAS,EAAG6P,GAAS,EAAGA,IACzD,GAAIxY,KAAK8B,eAAe0W,GAAOwJ,KAAOA,EAClC,OAAOhiB,KAAK8B,eAAe0W,GAGnC,OAAO,IACX,CAMA,gBAAAgM,CAAiBxC,GACb,IAAIxJ,EACJ,IAAKA,EAAQxY,KAAK2B,OAAOgH,OAAS,EAAG6P,GAAS,EAAGA,IAC7C,GAAIxY,KAAK2B,OAAO6W,GAAOwJ,KAAOA,EAC1B,OAAOhiB,KAAK2B,OAAO6W,GAG3B,IAAKA,EAAQxY,KAAK8B,eAAe6G,OAAS,EAAG6P,GAAS,EAAGA,IACrD,GAAIxY,KAAK8B,eAAe0W,GAAOwJ,KAAOA,EAClC,OAAOhiB,KAAK8B,eAAe0W,GAGnC,IAAKA,EAAQxY,KAAK6B,QAAQ8G,OAAS,EAAG6P,GAAS,EAAGA,IAC9C,GAAIxY,KAAK6B,QAAQ2W,GAAOwJ,KAAOA,EAC3B,OAAOhiB,KAAK6B,QAAQ2W,GAG5B,IAAKA,EAAQxY,KAAK4B,OAAO+G,OAAS,EAAG6P,GAAS,EAAGA,IAC7C,GAAIxY,KAAK4B,OAAO4W,GAAOwJ,KAAOA,EAC1B,OAAOhiB,KAAK4B,OAAO4W,GAG3B,OAAO,IACX,CAMA,WAAAiM,CAAYzC,GACR,MAAM7M,EAAOnV,KAAK+jB,YAAY/B,GAC9B,GAAI7M,EACA,OAAOA,EAEX,MAAMuP,EAAgB1kB,KAAKkkB,qBAAqBlC,GAChD,GAAI0C,EACA,OAAOA,EAEX,MAAMC,EAAQ3kB,KAAKojB,aAAapB,GAChC,GAAI2C,EACA,OAAOA,EAEX,MAAM5K,EAAS/Z,KAAKiiB,cAAcD,GAClC,GAAIjI,EACA,OAAOA,EAEX,MAAM6K,EAAO5kB,KAAK+iB,YAAYf,GAC9B,OAAI4C,GAGG,IACX,CAMA,aAAAC,CAAcvb,GACV,MAAM6L,EAAOnV,KAAK8kB,cAAcxb,GAChC,GAAI6L,EACA,OAAOA,EAEX,MAAMuP,EAAgB1kB,KAAK+kB,uBAAuBzb,GAClD,GAAIob,EACA,OAAOA,EAEX,MAAMC,EAAQ3kB,KAAKmjB,eAAe7Z,GAClC,GAAIqb,EACA,OAAOA,EAEX,MAAM5K,EAAS/Z,KAAKmiB,gBAAgB7Y,GACpC,GAAIyQ,EACA,OAAOA,EAEX,MAAM6K,EAAO5kB,KAAKkjB,cAAc5Z,GAChC,OAAIsb,GAGG,IACX,CAMA,aAAAE,CAAcxb,GACV,IAAK,IAAIkP,EAAQ,EAAGA,EAAQxY,KAAK2B,OAAOgH,OAAQ6P,IAC5C,GAAIxY,KAAK2B,OAAO6W,GAAOlP,OAASA,EAC5B,OAAOtJ,KAAK2B,OAAO6W,GAG3B,OAAO,IACX,CAMA,sBAAAuM,CAAuBzb,GACnB,IAAK,IAAIkP,EAAQ,EAAGA,EAAQxY,KAAK8B,eAAe6G,OAAQ6P,IACpD,GAAIxY,KAAK8B,eAAe0W,GAAOlP,OAASA,EACpC,OAAOtJ,KAAK8B,eAAe0W,GAGnC,OAAO,IACX,CAMA,mBAAAwM,CAAoBhD,GAChB,IAAK,IAAIxJ,EAAQxY,KAAK+B,UAAU4G,OAAS,EAAG6P,GAAS,EAAGA,IACpD,GAAIxY,KAAK+B,UAAUyW,GAAOwJ,KAAOA,EAC7B,OAAOhiB,KAAK+B,UAAUyW,GAG9B,OAAO,IACX,CAMA,qBAAAyM,CAAsBzD,GAClB,IAAK,IAAIhJ,EAAQ,EAAGA,EAAQxY,KAAK+B,UAAU4G,OAAQ6P,IAC/C,GAAIxY,KAAK+B,UAAUyW,GAAOgJ,WAAaA,EACnC,OAAOxhB,KAAK+B,UAAUyW,GAG9B,OAAO,IACX,CAMA,eAAA0M,CAAgBlD,GACZ,IAAK,IAAIxJ,EAAQ,EAAGA,EAAQxY,KAAK+B,UAAU4G,OAAQ6P,IAC/C,GAAIxY,KAAK+B,UAAUyW,GAAOwJ,KAAOA,EAC7B,OAAOhiB,KAAK+B,UAAUyW,GAG9B,OAAO,IACX,CAMA,iBAAA2M,CAAkB7b,GACd,IAAK,IAAIkP,EAAQ,EAAGA,EAAQxY,KAAK+B,UAAU4G,OAAQ6P,IAC/C,GAAIxY,KAAK+B,UAAUyW,GAAOlP,OAASA,EAC/B,OAAOtJ,KAAK+B,UAAUyW,GAG9B,OAAO,IACX,CAMA,yBAAA4M,CAA0BpD,GACtB,IAAK,IAAIxJ,EAAQ,EAAGA,EAAQxY,KAAKsK,oBAAoB3B,OAAQ6P,IACzD,GAAIxY,KAAKsK,oBAAoBkO,GAAOgJ,WAAaQ,EAC7C,OAAOhiB,KAAKsK,oBAAoBkO,GAGxC,OAAO,IACX,CAMA,kBAAA6M,CAAmBrD,GACf,IAAK,IAAIsD,EAAe,EAAGA,EAAetlB,KAAKsK,oBAAoB3B,SAAU2c,EAAc,CACvF,MAAMC,EAAqBvlB,KAAKsK,oBAAoBgb,GACpD,IAAK,IAAI9M,EAAQ,EAAGA,EAAQ+M,EAAmBC,aAAchN,EAAO,CAChE,MAAM+G,EAASgG,EAAmBE,UAAUjN,GAC5C,GAAI+G,EAAOyC,KAAOA,EACd,OAAOzC,CAEf,CACJ,CACA,OAAO,IACX,CAMA,oBAAAmG,CAAqBpc,GACjB,IAAK,IAAIgc,EAAe,EAAGA,EAAetlB,KAAKsK,oBAAoB3B,SAAU2c,EAAc,CACvF,MAAMC,EAAqBvlB,KAAKsK,oBAAoBgb,GACpD,IAAK,IAAI9M,EAAQ,EAAGA,EAAQ+M,EAAmBC,aAAchN,EAAO,CAChE,MAAM+G,EAASgG,EAAmBE,UAAUjN,GAC5C,GAAI+G,EAAOjW,OAASA,EAChB,OAAOiW,CAEf,CACJ,CACA,OAAO,IACX,CAMA,oBAAAoG,CAAqBrc,GACjB,IAAK,IAAIsc,EAAmB,EAAGA,EAAmB5lB,KAAK0K,cAAc/B,SAAUid,EAAkB,CAC7F,MAAMC,EAAc7lB,KAAK0K,cAAckb,GACvC,GAAIC,EAAYvc,OAASA,EACrB,OAAOuc,CAEf,CACA,OAAO,IACX,CAMA,YAAAC,CAAa3Q,GACT,OAA6C,IAAtCnV,KAAK8Q,cAAc6I,QAAQxE,EACtC,CAIA,OAAI4Q,GAIA,OAHK/lB,KAAK0U,OACN1U,KAAK0U,KAAO,KAAMsR,YAEfhmB,KAAK0U,IAChB,CASA,eAAAuR,CAAgBC,EAAK9S,GAIjB,OAHKpT,KAAKmmB,gBACNnmB,KAAKmmB,cAAgB,IAAI,KAEtBnmB,KAAKmmB,cAAczjB,IAAIwjB,EAAK9S,EACvC,CAMA,eAAAgT,CAAgBF,GACZ,OAAKlmB,KAAKmmB,cAGHnmB,KAAKmmB,cAAcE,IAAIH,GAFnB,IAGf,CAOA,+BAAAI,CAAgCJ,EAAKK,GAIjC,OAHKvmB,KAAKmmB,gBACNnmB,KAAKmmB,cAAgB,IAAI,KAEtBnmB,KAAKmmB,cAAcK,oBAAoBN,EAAKK,EACvD,CAMA,kBAAAE,CAAmBP,GACf,OAAOlmB,KAAKmmB,cAAc1jB,OAAOyjB,EACrC,CACA,gBAAAQ,CAAiBnN,EAASpE,EAAMwR,EAAaC,GACzC,GAAIA,GAAarN,EAAQsN,YAAY7mB,KAAKwI,gBAAiB,CACvD,IAAK,MAAM2Q,KAAQnZ,KAAKiS,sBACpBkH,EAAKC,OAAOjE,EAAMoE,GAEtB,MAAMlD,EAAWkD,EAAQC,cACrBnD,UAEIA,EAASoD,yBAA+D,MAApCpD,EAASqD,0BACO,IAAhD1Z,KAAK+Q,oBAAoB4I,QAAQtD,KACjCrW,KAAK+Q,oBAAoB/H,KAAKqN,GAC9BrW,KAAKiR,wBAAwB2I,sBAAsBvD,EAASqD,4BAIpE1Z,KAAKU,kBAAkBomB,SAASvN,EAASpE,EAAMkB,GAEvD,CACJ,CAIA,sBAAA0Q,GACI/mB,KAAK+Q,oBAAoB4L,SAC7B,CAMA,2CAAIqK,GACA,OAAOhnB,KAAKsT,0CAChB,CACA,2CAAI0T,CAAwC9mB,GACpCF,KAAKsT,6CAA+CpT,IAGpDA,IACAF,KAAKinB,mBACLjnB,KAAKknB,uBAETlnB,KAAKsT,2CAA6CpT,EACtD,CAIA,gBAAA+mB,GACI,IAAIjnB,KAAKgnB,0CAGThnB,KAAK8Q,cAAc6L,UACf3c,KAAK6E,cAAgB7E,KAAK6E,aAAaiM,eACvC9Q,KAAK6E,aAAaiM,cAAc6L,UAEhC3c,KAAKkH,eACL,IAAK,IAAIigB,EAAI,EAAGA,EAAInnB,KAAKkH,cAAcyB,OAAQwe,IAAK,CAChD,MAAMtiB,EAAe7E,KAAKkH,cAAcigB,GACpCtiB,GAAgBA,EAAaiM,eAC7BjM,EAAaiM,cAAc6L,SAEnC,CAER,CAIA,mBAAAuK,GACI,IAAIlnB,KAAKgnB,0CAGLhnB,KAAKU,mBACLV,KAAKU,kBAAkBwmB,sBAEvBlnB,KAAKyK,UACL,IAAK,IAAI0c,EAAI,EAAGA,EAAInnB,KAAKyK,SAAS9B,OAAQwe,IAAK,CAC3C,MAAMC,EAAUpnB,KAAKyK,SAAS0c,GAC1BC,GAAWA,EAAQC,YACnBD,EAAQF,qBAEhB,CAER,CAEA,0BAAAI,GACI,OAAOtnB,KAAKoQ,sBAChB,CAUA,kBAAAmX,CAAmBC,GAA2B,EAAOC,EAAWC,EAASC,GAAe,EAAMC,GAAqB,GAoB/G,OAnBA5nB,KAAKqb,kBAAiB,KAClB,GAAKrb,KAAK6E,aAAV,CAWA,GAPK7E,KAAKwI,gBACNxI,KAAK6nB,wBAET7nB,KAAK8nB,wBACL9nB,KAAKuT,qBAAsB,EAC3BvT,KAAKwT,mCAAqCoU,EAC1C5nB,KAAKyT,oCAAsC+T,EACvCG,EACA,IAAK,IAAInP,EAAQ,EAAGA,EAAQxY,KAAK8Q,cAAcnI,OAAQ6P,IACnDxY,KAAK8Q,cAAcsC,KAAKoF,GAAOuP,UAGvCN,GAAaA,GAbb,MAFIC,GAAWA,EAAQ,yBAeC,IAErB1nB,IACX,CAKA,oBAAAgoB,GACI,IAAK,IAAIxP,EAAQ,EAAGA,EAAQxY,KAAK2B,OAAOgH,OAAQ6P,IAAS,CACrD,MAAMrD,EAAOnV,KAAK2B,OAAO6W,GACrBrD,EAAK8S,gCACL9S,EAAK8S,8BAA8BC,WAAY,EAEvD,CACA,IAAK,IAAI1P,EAAQ,EAAGA,EAAQxY,KAAK8Q,cAAcnI,OAAQ6P,IACnDxY,KAAK8Q,cAAcsC,KAAKoF,GAAO2P,YAGnC,OADAnoB,KAAKuT,qBAAsB,EACpBvT,IACX,CACA,8BAAA6e,CAA+BuJ,KACNpoB,KAAK4T,QAAQyU,mBAA4D,IAAvCroB,KAAK4T,QAAQ0U,wBAC/CtoB,KAAKuT,qBAAuBvT,KAAK8Q,cAAcnI,QAIpE3I,KAAK6C,yBAAyByY,SAAQ,IAAM8M,EAAUzL,WAC1D,CACA,qBAAAmL,GACI,GAAI9nB,KAAK4T,QAAQyU,mBAA4D,IAAvCroB,KAAK4T,QAAQ0U,sBAU/C,YATItoB,KAAK8Q,cAAcnI,OAAS,IAC5B3I,KAAK6E,cAAciM,cAAc+H,QACjC7Y,KAAK8Q,cAAc+H,QACnB7Y,KAAKU,kBAAkBmY,QACvB7Y,KAAK+Q,oBAAoB8H,QACzB7Y,KAAKkR,uBAAuB2H,QAC5B7Y,KAAKmR,iBAAiB0H,QACtB7Y,KAAKoR,uBAAuByH,UAIpC,GAAI7Y,KAAKuT,qBAAuBvT,KAAK8Q,cAAcnI,OAAQ,CACvD,IAAK3I,KAAKyT,oCAAqC,CAC3C,MAAM8U,EAAMvoB,KAAK8Q,cAAcnI,OAC/B,IAAK,IAAIwe,EAAI,EAAGA,EAAIoB,EAAKpB,IAAK,CACbnnB,KAAK8Q,cAAcsC,KAAK+T,GAChCqB,oBACT,CACJ,CACA,GAAIxoB,KAAKkR,uBAAwB,CAC7B,MAAMuX,EAAWzoB,KAAKkR,uBAAuBvI,OAC7C,IAAK,IAAIwe,EAAI,EAAGA,EAAIsB,EAAUtB,IAC1BnnB,KAAKkR,uBAAuBkC,KAAK+T,GAAGuB,SAE5C,CAEA,YADA1oB,KAAKU,kBAAkBioB,cAE3B,CACA,IAAK3oB,KAAK6E,aACN,OAEJ7E,KAAKiM,yCAAyC7L,gBAAgBJ,MAC9DA,KAAK6E,aAAaiM,cAAc+H,QAChC7Y,KAAK8Q,cAAc+H,QACnB7Y,KAAKU,kBAAkBmY,QACvB7Y,KAAK+Q,oBAAoB8H,QACzB7Y,KAAKkR,uBAAuB2H,QAC5B7Y,KAAKmR,iBAAiB0H,QACtB7Y,KAAKoR,uBAAuByH,QAC5B7Y,KAAKiR,wBAAwB4H,QAC7B,IAAK,MAAMM,KAAQnZ,KAAKgS,+BACpBmH,EAAKC,SAGT,MAAMzX,EAAS3B,KAAKqV,0BAEdkT,EAAM5mB,EAAOgH,OACnB,IAAK,IAAIwe,EAAI,EAAGA,EAAIoB,EAAKpB,IAAK,CAC1B,MAAMhS,EAAOxT,EAAOyR,KAAK+T,GAEzB,GADAhS,EAAK8S,8BAA8BW,uBAAwB,EACvDzT,EAAK0T,UACL,SAGJ,GADA7oB,KAAK2P,eAAemZ,SAAS3T,EAAKqB,oBAAoB,IACjDrB,EAAKmD,YAAcnD,EAAK4T,aAAe5T,EAAK6T,QAAQC,kBACrD,SAEJ9T,EAAKqT,qBAEDrT,EAAK+T,eAAiB/T,EAAK+T,cAAcC,qBAAqB,GAAI,KAClEnpB,KAAKyP,wBAAwB2Z,gBAAgBjU,GAGjD,IAAIkU,EAAerpB,KAAKspB,kBAAoBtpB,KAAKspB,kBAAkBnU,EAAMnV,KAAK6E,cAAgBsQ,EAAKoU,OAAOvpB,KAAK6E,cAG/G,GAFAsQ,EAAK8S,8BAA8BuB,YAAcH,EACjDlU,EAAK8S,8BAA8BW,uBAAwB,EACvDS,UAIAA,IAAiBlU,GAAuC,IAA/BkU,EAAaI,eACtCJ,EAAab,qBAEjBrT,EAAKuU,eACDvU,EAAKwU,WACLxU,EAAKmB,WAAa,GACjBnB,EAAKyU,UAAY5pB,KAAK6E,aAAa+kB,YACnC5pB,KAAKkB,sBAAwBiU,EAAK0U,0BAA4B1U,EAAK0R,YAAY7mB,KAAKwI,kBAAkB,CACvGxI,KAAK8Q,cAAc9H,KAAKmM,GACxBnV,KAAK6E,aAAaiM,cAAc9H,KAAKmM,GACjCkU,IAAiBlU,GACjBkU,EAAaS,UAAU9pB,KAAKiQ,WAAW,GAE3C,IAAK,MAAMkJ,KAAQnZ,KAAKkS,oBACpBiH,EAAKC,OAAOjE,GAEZA,EAAK2U,UAAU9pB,KAAKiQ,WAAW,KAC1BkF,EAAK4U,aAIF5U,EAAK8S,8BAA8B+B,oBACnCX,EAAelU,GAJnBkU,EAAapB,8BAA8BgC,mBAAoB,EAOnEZ,EAAapB,8BAA8BC,WAAY,EACvDloB,KAAKkqB,YAAY/U,EAAMkU,IAE3BlU,EAAKgV,eACT,CACJ,CAGA,GAFAnqB,KAAKkM,wCAAwC9L,gBAAgBJ,MAEzDA,KAAK8O,iBAAkB,CACvB9O,KAAKmM,qCAAqC/L,gBAAgBJ,MAC1D,IAAK,IAAIoqB,EAAgB,EAAGA,EAAgBpqB,KAAKiK,gBAAgBtB,OAAQyhB,IAAiB,CACtF,MAAMpQ,EAAiBha,KAAKiK,gBAAgBmgB,GAC5C,IAAKpQ,EAAeqQ,cAAgBrQ,EAAesQ,QAC/C,SAEJ,MAAMA,EAAUtQ,EAAesQ,QAC1BA,EAAQC,WAAYD,EAAQvB,cAC7B/oB,KAAKkR,uBAAuBlI,KAAKgR,GACjCA,EAAe0O,UACf1oB,KAAKU,kBAAkB8pB,kBAAkBxQ,GAEjD,CACAha,KAAKoM,oCAAoChM,gBAAgBJ,KAC7D,CACJ,CAEA,gBAAAyqB,CAAiBtV,GACRnV,KAAKkI,mBAAsBiN,EAAKlT,WAGjCjC,KAAKmR,iBAAiBiY,gBAAgBjU,EAAKlT,YAC3CkT,EAAKlT,SAASyoB,UACd1qB,KAAK8P,aAAagZ,SAAS3T,EAAKlT,SAASC,MAAMyG,QAAQ,IAEtDwM,EAAKwV,0BACF3qB,KAAKoR,uBAAuBgY,gBAAgBjU,IAASnV,KAAK4H,YAC1DuN,EAAKyV,cAAczV,EAAKlT,UAGpC,CACA,WAAAioB,CAAYW,EAAY1V,GACpBnV,KAAKyqB,iBAAiBtV,GACtB,IAAIyR,EAAYiE,EAAWC,cAAgBD,EAAWd,cAAgB/pB,KAAK6Q,oCAAsC7Q,KAAKkB,sBAAwBiU,EAAK0U,yBACnJ,GAAI1U,GAAQA,EAAKC,WAAaD,EAAKC,UAAUzM,OAAS,EAAG,CACrD,MAAMyM,EAAYpV,KAAKsV,2BAA2BH,GAC5CoT,EAAMnT,EAAUzM,OACtBie,EAAYA,GAAqB,IAAR2B,EACzB,IAAK,IAAIpB,EAAI,EAAGA,EAAIoB,EAAKpB,IAAK,CAC1B,MAAM5N,EAAUnE,EAAUhC,KAAK+T,GAC/BnnB,KAAK0mB,iBAAiBnN,EAASpE,EAAM0V,EAAYjE,EACrD,CACJ,CACJ,CAKA,qBAAAiB,CAAsBlE,GAClB,MAAM9e,EAAe7E,KAAK6E,aAC1B,GAAKA,EAGL,GAAIA,EAAakmB,oBAAqB,CAClC,MAAMC,EAAanmB,EAAaomB,YAAY,GACtCC,EAAcrmB,EAAaomB,YAAY,GAC7CjrB,KAAKqc,mBAAmB2O,EAAWhP,gBAAiBgP,EAAW9O,oBAAoByH,GAAQuH,EAAYlP,gBAAiBkP,EAAYhP,oBAAoByH,GAC5J,MAEI3jB,KAAKqc,mBAAmBxX,EAAamX,gBAAiBnX,EAAaqX,oBAAoByH,GAE/F,CACA,gBAAAwH,CAAiBpR,EAAQ4B,GAAQ,GACzB5B,GAAUA,EAAOqR,kBACjBrR,EAAOqR,kBAAkBD,mBAEpBpR,GAAUA,EAAOsR,mBACtBtR,EAAOsR,mBAAmBF,mBAGrBnrB,KAAK4T,QAAQ0X,2CACdtrB,KAAK4T,QAAQ2X,4BAGjB5P,GACA3b,KAAKwrB,kBAAkBzR,EAE/B,CACA,iBAAAyR,CAAkBzR,GAEd,GAAIA,GAAUA,EAAOqR,wBAGhB,GAAIrR,GAAUA,EAAOsR,qBAAuBtR,EAAOgR,oBAAqB,CACzE,MAAMU,EAAM1R,EAAOsR,mBACfI,EAAIC,kBAAkBC,eACtBF,EAAIC,kBAAkBtrB,gBAAgBJ,KAAK4T,SAErC6X,EAAIG,kBAAqB7R,EAAO8R,gBAClC7rB,KAAKa,WACLb,KAAK4T,QAAQ+H,MAAM8P,EAAI1rB,YAAcC,KAAKC,aAAcwrB,EAAIK,UAAU,GAAM,GAEhFL,EAAIK,UAAW,EAEvB,MAES9rB,KAAKqQ,2BAKNrQ,KAAK4T,QAAQ+H,MAAM,MAAM,GAAO,GAAM,IAJtC3b,KAAKqQ,4BAA6B,EAClCrQ,KAAK+rB,SAMjB,CAIA,gBAAAC,CAAiBjS,EAAQkS,EAAWC,GAAkB,GAClD,GAAInS,GAAUA,EAAOoS,eACjB,OAEJ,MAAM3iB,EAASxJ,KAAK4T,QAGpB,GADA5T,KAAKsH,cAAgByS,GAChB/Z,KAAK6E,aACN,MAAM,IAAIunB,MAAM,yBAOpB,GAJA5iB,EAAO6iB,YAAYrsB,KAAK6E,aAAaynB,UAErCtsB,KAAKma,sBACLna,KAAKiQ,aACAjQ,KAAK0G,SAAWwlB,EAAiB,CAClC,IAAIN,GAAmB,EACnB7R,EAAOgR,qBAAuBhR,EAAOsR,qBACrCO,EAAmB7R,EAAOsR,mBAAmBO,iBACzC5rB,KAAKa,YACLb,KAAKqQ,4BAA6B,EAClC0J,EAAOsR,mBAAmBO,kBAAmB,IAGrD5rB,KAAKmrB,iBAAiBnrB,KAAKsH,eACvByS,EAAOgR,qBAAuBhR,EAAOsR,qBACrCtR,EAAOsR,mBAAmBO,iBAAmBA,EAErD,CACA5rB,KAAK6nB,wBACL7nB,KAAKmD,+BAA+B/C,gBAAgBJ,KAAK6E,cAEzD7E,KAAK8nB,wBAEL,IAAK,IAAIyE,EAA2B,EAAGA,EAA2BvsB,KAAKoR,uBAAuBzI,OAAQ4jB,IAA4B,CAC9H,MAAMpX,EAAOnV,KAAKoR,uBAAuBgC,KAAKmZ,GAC9CpX,EAAKyV,cAAczV,EAAKlT,SAC5B,CAEAjC,KAAKwN,sCAAsCpN,gBAAgBJ,MAC3DA,KAAKgR,eAAe4I,sBAAsB5Z,KAAKiR,yBAC3C8I,EAAOzK,qBAAuByK,EAAOzK,oBAAoB3G,OAAS,GAClE3I,KAAKgR,eAAe4I,sBAAsBG,EAAOzK,qBAEjD2c,GAAaA,EAAU3c,qBAAuB2c,EAAU3c,oBAAoB3G,OAAS,GACrF3I,KAAKgR,eAAe4I,sBAAsBqS,EAAU3c,qBAEpDtP,KAAKqB,oBAAsBrB,KAAKqB,mBAAmBmrB,gBACnDxsB,KAAKgR,eAAeoY,gBAAgBppB,KAAKqB,oBAG7C,IAAK,MAAM8X,KAAQnZ,KAAK8R,sCACpBqH,EAAKC,OAAOpZ,KAAKgR,gBAErB,IAAIyb,GAAa,EACjB,GAAIzsB,KAAKoP,qBAAsB,CAE3B,GADApP,KAAKoQ,wBAAyB,EAC1BpQ,KAAKgR,eAAerI,OAAS,EAAG,CAChC,KAAM+jB,wBAAwB,iBAAkB1sB,KAAKgR,eAAerI,OAAS,GAC7E,IAAK,IAAIgkB,EAAc,EAAGA,EAAc3sB,KAAKgR,eAAerI,OAAQgkB,IAAe,CAC/E,MAAMC,EAAe5sB,KAAKgR,eAAeoC,KAAKuZ,GAC9C,GAAIC,EAAaC,gBAAiB,CAC9B7sB,KAAKiQ,YACL,MAAM6c,EAA+BF,EAAa/nB,cAAgB+nB,EAAa/nB,eAAiB7E,KAAK6E,aACrG+nB,EAAaG,OAAOD,EAA8B9sB,KAAKqP,uBACvDod,GAAa,CACjB,CACJ,CACA,KAAMO,sBAAsB,iBAAkBhtB,KAAKgR,eAAerI,OAAS,GAC3E3I,KAAKiQ,WACT,CACA,IAAK,MAAMkJ,KAAQnZ,KAAKmS,6BACpBsa,EAAatT,EAAKC,OAAOpZ,KAAK6E,eAAiB4nB,EAEnDzsB,KAAKoQ,wBAAyB,CAClC,CACApQ,KAAK4T,QAAQ6E,oBAAsBsB,EAAOsR,oBAAoB3S,cAAgBqB,EAAOrB,cAAgB,EAEjG+T,IAAezsB,KAAK0G,UACpB1G,KAAKmrB,iBAAiBnrB,KAAKsH,eAAe,GAC1CtH,KAAK6nB,yBAET7nB,KAAKyN,qCAAqCrN,gBAAgBJ,OAEtDA,KAAK2U,oBAAuBoF,EAAOqR,mBAAsBprB,KAAK0G,SAC9D1G,KAAK2U,mBAAmBsY,gBAG5B,IAAK,MAAM9T,KAAQnZ,KAAKoS,uBACpB+G,EAAKC,OAAOpZ,KAAK6E,cAGrB7E,KAAK8L,4BAA4B1L,gBAAgBJ,MAC7CwJ,EAAO6e,mBAAsD,IAAjC7e,EAAO8e,uBACnCtoB,KAAKyF,mBAETzF,KAAKU,kBAAkBqsB,OAAO,KAAM,MAAM,GAAM,GAChD/sB,KAAK+L,2BAA2B3L,gBAAgBJ,MAEhD,IAAK,MAAMmZ,KAAQnZ,KAAK0S,sBACpByG,EAAKC,OAAOpZ,KAAK6E,cAGrB,GAAI7E,KAAK2U,qBAAuBoF,EAAOqR,kBAAmB,CAEtD,MAAMhE,EAAUrN,EAAOsR,mBAAqBtR,EAAOsR,mBAAmBuB,kBAAezV,EACrFnX,KAAK2U,mBAAmBuY,eAAenT,EAAOoT,eAAgB/F,EAClE,CAEA,IAAK,MAAMjO,KAAQnZ,KAAK2S,6BACpBwG,EAAKC,OAAOpZ,KAAK6E,cAGrB7E,KAAKgR,eAAe6H,QACpB7Y,KAAKsD,8BAA8BlD,gBAAgBJ,KAAK6E,aAC5D,CACA,kBAAAuoB,CAAmBrT,EAAQmS,GAAkB,GACzC,GAA6B,IAAzBnS,EAAOsT,eAAuBtT,EAAOgR,oBAMrC,OALIhR,EAAOgR,sBAAwB/qB,KAAK0c,oBACpC1c,KAAKstB,sBAETttB,KAAKgsB,iBAAiBjS,OAAQ5C,EAAW+U,QACzClsB,KAAK2L,8BAA8BvL,gBAAgB2Z,GAGvD,GAAIA,EAAOwT,0BACPvtB,KAAKwtB,6BAA6BzT,OAEjC,CAED/Z,KAAKmD,+BAA+B/C,gBAAgB2Z,GACpD,IAAK,IAAIvB,EAAQ,EAAGA,EAAQuB,EAAOkR,YAAYtiB,OAAQ6P,IACnDxY,KAAKgsB,iBAAiBjS,EAAOkR,YAAYzS,GAAQuB,EAEzD,CAEA/Z,KAAKsH,cAAgByS,EACrB/Z,KAAK6nB,wBACL7nB,KAAK2L,8BAA8BvL,gBAAgB2Z,EACvD,CACA,mBAAA0T,GACI,IAAK,IAAIjV,EAAQ,EAAGA,EAAQxY,KAAKyP,wBAAwB9G,OAAQ6P,IAAS,CACtE,MAAMqS,EAAa7qB,KAAKyP,wBAAwB2D,KAAKoF,GACrD,GAAKqS,EAAW3B,cAGhB,IAAK,IAAIwE,EAAc,EAAG7C,EAAW3B,eAAiBwE,EAAc7C,EAAW3B,cAAcyE,QAAQhlB,OAAQ+kB,IAAe,CACxH,MAAMtU,EAASyR,EAAW3B,cAAcyE,QAAQD,GAChD,GAAuB,KAAnBtU,EAAOwU,SAAqC,KAAnBxU,EAAOwU,QAAgB,CAChD,MAAMC,EAAazU,EAAO0U,sBACpBC,EAAYF,EAAW1Y,KAAO0Y,EAAW1Y,KAAO0Y,EAChDG,EAAkBD,EAAUE,eAAepD,EAAYgD,EAAWK,wBAClEC,EAAgCtD,EAAWuD,yBAAyBzU,QAAQoU,GAC9EC,IAAsD,IAAnCG,EACI,KAAnB/U,EAAOwU,SACPxU,EAAOiV,gBAAgB,IAAYC,UAAUzD,OAAY1T,EAAW4W,IACpElD,EAAWuD,yBAAyBplB,KAAK+kB,IAEjB,KAAnB3U,EAAOwU,SACZ/C,EAAWuD,yBAAyBplB,KAAK+kB,IAGvCC,GAAmBG,GAAiC,IAGnC,KAAnB/U,EAAOwU,SACPxU,EAAOiV,gBAAgB,IAAYC,UAAUzD,OAAY1T,EAAW4W,IAGnElD,EAAW3B,cAAcqF,mBAAmB,IAAKC,IAClD,MAAMC,EAAgBD,EAAUrZ,KAAOqZ,EAAUrZ,KAAOqZ,EACxD,OAAOT,IAAcU,CAAa,KAEf,KAAnBrV,EAAOwU,SACP/C,EAAWuD,yBAAyBjT,OAAOgT,EAA+B,GAGtF,CACJ,CACJ,CACJ,CAIA,yBAAAO,CAA0BvV,GAE1B,CAEA,QAAAwV,CAASC,GAET,CAEA,OAAAlG,GACI,GAAI1oB,KAAK4T,QAAQib,0BAA2B,CACxC,IAAIC,EAAYC,KAAKC,IAAIrvB,EAAMsvB,aAAcF,KAAKG,IAAIlvB,KAAK4T,QAAQub,eAAgBxvB,EAAMyvB,eAAiBpvB,KAAKsO,iBAC/G,MAAM+gB,EAAmBrvB,KAAK4T,QAAQC,cAChCyb,EAAa,IAASD,EAAmB,IAC/C,IAAIE,EAAa,EACjB,MAAMC,EAAcxvB,KAAK4T,QAAQ6b,sBACjC,IAAIC,EAAgBX,KAAKY,MAAMb,EAAYO,GAE3C,IADAK,EAAgBX,KAAKG,IAAIQ,EAAeF,GACjCV,EAAY,GAAKS,EAAaG,GACjC1vB,KAAK0N,uBAAuBtN,gBAAgBJ,MAE5CA,KAAKoX,gBAAkBiY,EAAmBC,EAC1CtvB,KAAK2uB,SAASU,GACdrvB,KAAK6L,4BAA4BzL,gBAAgBJ,MAE7CA,KAAK6O,gBACL7O,KAAK0uB,0BAA0BW,GAEnCrvB,KAAK2N,sBAAsBvN,gBAAgBJ,MAC3CA,KAAKkG,iBACLqpB,IACAT,GAAaO,EAEjBrvB,KAAKsO,iBAAmBwgB,EAAY,EAAI,EAAIA,CAChD,KACK,CAED,MAAMA,EAAY9uB,KAAKiL,8BAAgC,GAAK8jB,KAAKC,IAAIrvB,EAAMsvB,aAAcF,KAAKG,IAAIlvB,KAAK4T,QAAQub,eAAgBxvB,EAAMyvB,eACrIpvB,KAAKoX,gBAA8B,IAAZ0X,EACvB9uB,KAAK2uB,WACL3uB,KAAK6L,4BAA4BzL,gBAAgBJ,MAE7CA,KAAK6O,gBACL7O,KAAK0uB,0BAA0BI,EAEvC,CACJ,CACA,MAAA/C,IACQ/rB,KAAK6J,0BAA4B7J,KAAKa,YACtCb,KAAK4T,QAAQ+H,MAAM3b,KAAKC,YAAaD,KAAKa,WAAab,KAAKe,gBAAkBf,KAAKmB,iBAAkBnB,KAAK6J,yBAA0B7J,KAAK6J,yBAEjJ,CACA,wBAAA+lB,CAAyB7V,GAIrB,GAHIA,GAAQsR,qBAAuBtR,GAAQ8V,cACvC9V,EAAOsR,mBAAmBS,UAAW,GAErC/R,GAAQ+V,YAAYnnB,OACpB,IAAK,IAAIwe,EAAI,EAAGA,EAAIpN,EAAO+V,WAAWnnB,SAAUwe,EAAG,CAC/C,MAAMsE,EAAM1R,EAAO+V,WAAW3I,GAAGkE,mBAC7BI,IACAA,EAAIK,UAAW,EAEvB,CAER,CAKA,cAAAiE,CAAeC,GACX,GAAKhwB,KAAK2B,OAGV,IAAK,MAAMwT,KAAQnV,KAAK2B,OACpBwT,EAAK4a,eAAeC,EAE5B,CACA,qBAAAhoB,CAAsBioB,GAAgB,EAAMC,GAAmB,GAK3D,GAJAlwB,KAAK6E,aAAe,KACpB7E,KAAKkR,uBAAuB2H,QAC5B7Y,KAAKmR,iBAAiB0H,QAElBoX,EACA,IAAK,MAAMlW,KAAU/Z,KAAK6B,QAEtB,GADAkY,EAAOjU,SACsB,IAAzBiU,EAAOsT,cAEP,IAAK,IAAI7U,EAAQ,EAAGA,EAAQuB,EAAOkR,YAAYtiB,OAAQ6P,IACnDuB,EAAOkR,YAAYzS,GAAO1S,SAO1C,IAAK,MAAMqT,KAAQnZ,KAAK2R,kBACpBwH,EAAKC,SAGT,MAAMzX,EAAS3B,KAAKqV,0BACdkT,EAAM5mB,EAAOgH,OACnB,IAAK,IAAIwe,EAAI,EAAGA,EAAIoB,EAAKpB,IAAK,CAC1B,MAAMhS,EAAOxT,EAAOyR,KAAK+T,GACrBhS,EAAK0T,YAGT7oB,KAAK2P,eAAemZ,SAAS3T,EAAKqB,oBAAoB,GACjDrB,EAAKmD,WAAcnD,EAAK4T,cAAe5T,EAAK6T,QAAQC,oBAGzD9T,EAAKqT,qBACDrT,EAAK+T,eAAiB/T,EAAK+T,cAAcC,qBAAqB,GAAI,KAClEnpB,KAAKyP,wBAAwB2Z,gBAAgBjU,IAErD,CAEA,GAAInV,KAAK8O,iBACL,IAAK,IAAIsb,EAAgB,EAAGA,EAAgBpqB,KAAKiK,gBAAgBtB,OAAQyhB,IAAiB,CACtF,MAAMpQ,EAAiBha,KAAKiK,gBAAgBmgB,GAC5C,IAAKpQ,EAAeqQ,cAAgBrQ,EAAesQ,QAC/C,SAEJ,MAAMA,EAAUtQ,EAAesQ,QAC1BA,EAAQC,WAAYD,EAAQvB,cAC7B/oB,KAAKkR,uBAAuBlI,KAAKgR,GACjCA,EAAe0O,UAEvB,CAGJ1oB,KAAK4H,YAAYuoB,SACrB,CAMA,MAAApD,CAAOkD,GAAgB,EAAMC,GAAmB,GAC5C,IAAIlwB,KAAKowB,WAAT,CAGIpwB,KAAKgM,kBAAkB2f,gBAAsD,OAApC3rB,KAAKmQ,4BAC9CnQ,KAAKub,gBAETvb,KAAKkQ,WACLlQ,KAAKqQ,4BAA6B,EAClCrQ,KAAK4vB,yBAAyB5vB,KAAK6E,cAC/B7E,KAAKkH,eAAeyB,QACpB3I,KAAKkH,cAAclF,QAAQhC,KAAK4vB,0BAGpC5vB,KAAKyI,+BACLzI,KAAK6P,iBAAiBwgB,gBACtBrwB,KAAK2P,eAAe0gB,gBACpBrwB,KAAK4P,eAAeygB,gBACpBrwB,KAAK8P,aAAaugB,gBAClBrwB,KAAKyP,wBAAwBoJ,QAC7B7Y,KAAKma,sBACLna,KAAK4L,6BAA6BxL,gBAAgBJ,MAE9CA,KAAKkpB,eACLlpB,KAAKkpB,cAAcoH,eAAe,IAGjCJ,GACDlwB,KAAK0oB,UAGT,IAAK,MAAMvP,KAAQnZ,KAAKyR,yBACpB0H,EAAKC,SAGT,GAAI6W,EACA,GAAIjwB,KAAKkH,eAAiBlH,KAAKkH,cAAcyB,OAAS,EAClD,IAAK,IAAI4nB,EAAc,EAAGA,EAAcvwB,KAAKkH,cAAcyB,OAAQ4nB,IAAe,CAC9E,MAAMxW,EAAS/Z,KAAKkH,cAAcqpB,GAElC,GADAxW,EAAOjU,SACsB,IAAzBiU,EAAOsT,cAEP,IAAK,IAAI7U,EAAQ,EAAGA,EAAQuB,EAAOkR,YAAYtiB,OAAQ6P,IACnDuB,EAAOkR,YAAYzS,GAAO1S,QAGtC,MAEC,GAAI9F,KAAK6E,eACV7E,KAAK6E,aAAaiB,SACsB,IAApC9F,KAAK6E,aAAawoB,eAElB,IAAK,IAAI7U,EAAQ,EAAGA,EAAQxY,KAAK6E,aAAaomB,YAAYtiB,OAAQ6P,IAC9DxY,KAAK6E,aAAaomB,YAAYzS,GAAO1S,SAQrD,GAFA9F,KAAK6C,yBAAyBzC,gBAAgBJ,MAE1CA,KAAK8H,qBACL9H,KAAKiQ,YACLjQ,KAAK4T,QAAQ6E,oBAAsB,EACnCzY,KAAK8H,qBAAqBmoB,EAAeC,OAExC,CACD,MAAM1mB,EAASxJ,KAAKuW,YAEpBvW,KAAKwN,sCAAsCpN,gBAAgBJ,MAC3D,MAAMwwB,EAAsBxwB,KAAKkH,eAAeyB,OAAS3I,KAAKkH,cAAc,GAAKlH,KAAK6E,aACtF,GAAI7E,KAAKoP,qBAAsB,CAC3B,KAAMsd,wBAAwB,wBAAyB1sB,KAAKsP,oBAAoB3G,OAAS,GACzF3I,KAAKoQ,wBAAyB,EAC9B,IAAK,IAAIqgB,EAAc,EAAGA,EAAczwB,KAAKsP,oBAAoB3G,OAAQ8nB,IAAe,CACpF,MAAM7D,EAAe5sB,KAAKsP,oBAAoBmhB,GAC9C,GAAI7D,EAAaC,gBAAiB,CAG9B,GAFA7sB,KAAKiQ,YACLjQ,KAAK6E,aAAe+nB,EAAa/nB,cAAgB7E,KAAK6E,cACjD7E,KAAK6E,aACN,MAAM,IAAIunB,MAAM,yBAGpB5iB,EAAO6iB,YAAYrsB,KAAK6E,aAAaynB,UAErCtsB,KAAK6nB,wBACL+E,EAAaG,OAAOyD,IAAwBxwB,KAAK6E,aAAc7E,KAAKqP,sBACxE,CACJ,CACA,KAAM2d,sBAAsB,wBAAyBhtB,KAAKsP,oBAAoB3G,OAAS,GACvF3I,KAAKoQ,wBAAyB,EAC9BpQ,KAAKiQ,WACT,CACAjQ,KAAK4T,QAAQ6E,oBAAsB+X,GAAqB9X,cAAgB,EAExE1Y,KAAK6E,aAAe2rB,EAChBxwB,KAAKsH,eAAsD,KAArCtH,KAAKsH,cAAc+lB,gBAAyBrtB,KAAK0G,SACvE1G,KAAKmrB,iBAAiBnrB,KAAKsH,eAAe,GAE9CtH,KAAKyN,qCAAqCrN,gBAAgBJ,MAC1D,IAAK,MAAMmZ,KAAQnZ,KAAK2R,kBACpBwH,EAAKC,SAGTpZ,KAAKwrB,kBAAkBxrB,KAAK6E,cAE5B,IAAK,MAAMsU,KAAQnZ,KAAK6R,0BACpBsH,EAAKC,OAAOpZ,KAAKgR,gBAGrB,GAAIhR,KAAKkH,eAAiBlH,KAAKkH,cAAcyB,OAAS,EAClD,IAAK,IAAI4nB,EAAc,EAAGA,EAAcvwB,KAAKkH,cAAcyB,OAAQ4nB,IAC/DvwB,KAAKotB,mBAAmBptB,KAAKkH,cAAcqpB,GAAcA,EAAc,OAG1E,CACD,IAAKvwB,KAAK6E,aACN,MAAM,IAAIunB,MAAM,qBAEpBpsB,KAAKotB,mBAAmBptB,KAAK6E,eAAgB7E,KAAK6E,aAAawmB,mBACnE,CACJ,CAEArrB,KAAKytB,sBAEL,IAAK,MAAMtU,KAAQnZ,KAAK8S,kBACpBqG,EAAKC,SAQT,GALIpZ,KAAK8C,aACL9C,KAAK8C,cAET9C,KAAKgD,wBAAwB5C,gBAAgBJ,MAEzCA,KAAKwQ,cAAc7H,OAAQ,CAC3B,IAAK,IAAI6P,EAAQ,EAAGA,EAAQxY,KAAKwQ,cAAc7H,OAAQ6P,IAAS,CAC5D,MAAMpF,EAAOpT,KAAKwQ,cAAcgI,GAC5BpF,GACAA,EAAKuJ,SAEb,CACA3c,KAAKwQ,cAAc7H,OAAS,CAChC,CACI3I,KAAKqP,wBACLrP,KAAKqP,uBAAwB,GAEjCrP,KAAK8P,aAAagZ,SAAS,GAAG,GAC9B9oB,KAAK4P,eAAekZ,SAAS,GAAG,GAChC9oB,KAAK6P,iBAAiBiZ,SAAS,GAAG,GAClC9oB,KAAK4T,QAAQ2X,2BAlJb,CAmJJ,CAMA,eAAAmF,GACI,IAAK,IAAIvJ,EAAI,EAAGA,EAAInnB,KAAKqK,UAAU1B,OAAQwe,IACvCnnB,KAAKqK,UAAU8c,GAAGwJ,QAE1B,CAKA,iBAAAC,GACI,IAAK,IAAIzJ,EAAI,EAAGA,EAAInnB,KAAKqK,UAAU1B,OAAQwe,IACvCnnB,KAAKqK,UAAU8c,GAAG0J,UAE1B,CAIA,OAAAlU,GACI,GAAI3c,KAAKowB,WACL,OAEJpwB,KAAK2C,aAAe,KACpB3C,KAAK8C,YAAc,KACnB9C,KAAKwL,SAAW,KAChBxL,KAAK+B,UAAU4G,OAAS,EACxB3I,KAAKsK,oBAAoB3B,OAAS,EAClC3I,KAAK0I,qBAAqBC,OAAS,EACnC3I,KAAK+R,qBAAqB4J,QAC1B3b,KAAKgS,+BAA+B2J,QACpC3b,KAAKiS,sBAAsB0J,QAC3B3b,KAAKkS,oBAAoByJ,QACzB3b,KAAKmS,6BAA6BwJ,QAClC3b,KAAKoS,uBAAuBuJ,QAC5B3b,KAAKqS,6BAA6BsJ,QAClC3b,KAAKsS,+BAA+BqJ,QACpC3b,KAAKuS,0BAA0BoJ,QAC/B3b,KAAKwS,yBAAyBmJ,QAC9B3b,KAAKyS,8BAA8BkJ,QACnC3b,KAAK0S,sBAAsBiJ,QAC3B3b,KAAK4S,4BAA4B+I,QACjC3b,KAAK8S,kBAAkB6I,QACvB3b,KAAKyR,yBAAyBkK,QAC9B3b,KAAK2R,kBAAkBgK,QACvB3b,KAAK6R,0BAA0B8J,QAC/B3b,KAAK8R,sCAAsC6J,QAC3C3b,KAAK+S,kBAAkB4I,QACvB3b,KAAKgT,kBAAkB2I,QACvB3b,KAAKiT,gBAAgB0I,QACrB3b,KAAKuP,oBAAsB,GACvBvP,KAAKqR,oBAAsBrR,KAAK8wB,oBAEhC9wB,KAAKqR,mBAAmBrP,SAAS+uB,IAC7BA,EAAWC,yBAAyBrV,QACpCoV,EAAWE,eAAiB,IAAI,IAEpCjxB,KAAK8wB,qBAET9wB,KAAKma,sBAEDna,KAAK6E,eACL7E,KAAK6E,aAAaiM,cAAc6L,UAChC3c,KAAK6E,aAAe,MAExB7E,KAAKkH,cAAgB,KACrBlH,KAAK8Q,cAAc6L,UACnB3c,KAAKU,kBAAkBic,UACvB3c,KAAK+Q,oBAAoB4L,UACzB3c,KAAKkR,uBAAuByL,UAC5B3c,KAAKmR,iBAAiBwL,UACtB3c,KAAKoR,uBAAuBuL,UAC5B3c,KAAKgR,eAAe2L,UACpB3c,KAAKiR,wBAAwB0L,UAC7B3c,KAAKiO,oCAAoC0O,UACzC3c,KAAKyP,wBAAwBkN,UAC7B3c,KAAKwQ,cAAc7H,OAAS,EAE5B,MAAMuoB,EAAiBlxB,KAAK0Q,gBAAgBygB,QAC5C,IAAK,MAAMC,KAAWF,EAClBE,EAAQC,QAEZrxB,KAAK0Q,gBAAgB/H,OAAS,EAE9B,IACI3I,KAAKwC,oBAAoBpC,gBAAgBJ,KAC7C,CACA,MAAOsxB,GACH,IAAOlF,MAAM,uDAAwDkF,EACzE,CACAtxB,KAAKqY,gBAGL,GADerY,KAAK4T,QAAQkO,kBAExB,IAAK,IAAItJ,EAAQ,EAAGA,EAAQxY,KAAK6B,QAAQ8G,OAAQ6P,IAC7CxY,KAAK6B,QAAQ2W,GAAOH,gBAI5BrY,KAAKuxB,aAAavxB,KAAKmK,iBAEvBnK,KAAKuxB,aAAavxB,KAAK4B,QAEnB5B,KAAKyH,kBACLzH,KAAKyH,iBAAiBkV,UAE1B3c,KAAKuxB,aAAavxB,KAAKoK,gBACvBpK,KAAKuxB,aAAavxB,KAAKqK,WAEvBrK,KAAKuxB,aAAavxB,KAAK2B,QAAS6vB,GAASA,EAAK7U,SAAQ,KACtD3c,KAAKuxB,aAAavxB,KAAK8B,gBAAiB0vB,GAASA,EAAK7U,SAAQ,KAE9D,MAAM9a,EAAU7B,KAAK6B,QACrB7B,KAAKuxB,aAAa1vB,GAElB7B,KAAKuxB,aAAavxB,KAAKiK,iBAEvBjK,KAAKuxB,aAAavxB,KAAK0K,eAEvB1K,KAAKuxB,aAAavxB,KAAKyK,UAEvBzK,KAAKuxB,aAAavxB,KAAKsK,qBAEvBtK,KAAKkd,UAAUP,UACX3c,KAAK0c,oBACL1c,KAAK0c,mBAAmBC,UAG5B3c,KAAK2U,mBAAmBgI,UAExB3c,KAAKuxB,aAAavxB,KAAK+I,aAEvB,IAAIyP,EAAQxY,KAAK4T,QAAQa,OAAOkF,QAAQ3Z,MACpCwY,GAAS,GACTxY,KAAK4T,QAAQa,OAAO0G,OAAO3C,EAAO,GAElC,IAAYhE,oBAAsBxU,OAC9BA,KAAK4T,QAAQa,OAAO9L,OAAS,EAC7B,IAAY6L,kBAAoBxU,KAAK4T,QAAQa,OAAOzU,KAAK4T,QAAQa,OAAO9L,OAAS,GAGjF,IAAY6L,kBAAoB,MAGxCgE,EAAQxY,KAAK4T,QAAQW,eAAeoF,QAAQ3Z,MACxCwY,GAAS,GACTxY,KAAK4T,QAAQW,eAAe4G,OAAO3C,EAAO,GAE9CxY,KAAK4T,QAAQ6d,YAAW,GACxBzxB,KAAKwC,oBAAoBmZ,QACzB3b,KAAK6C,yBAAyB8Y,QAC9B3b,KAAKgD,wBAAwB2Y,QAC7B3b,KAAKwN,sCAAsCmO,QAC3C3b,KAAKyN,qCAAqCkO,QAC1C3b,KAAK2N,sBAAsBgO,QAC3B3b,KAAK0N,uBAAuBiO,QAC5B3b,KAAKiM,yCAAyC0P,QAC9C3b,KAAKkM,wCAAwCyP,QAC7C3b,KAAKmM,qCAAqCwP,QAC1C3b,KAAKoM,oCAAoCuP,QACzC3b,KAAK8L,4BAA4B6P,QACjC3b,KAAK+L,2BAA2B4P,QAChC3b,KAAK4L,6BAA6B+P,QAClC3b,KAAK6L,4BAA4B8P,QACjC3b,KAAKqM,uBAAuBsP,QAC5B3b,KAAK4N,iCAAiC+N,QACtC3b,KAAK6N,gCAAgC8N,QACrC3b,KAAK8N,yBAAyB6N,QAC9B3b,KAAKmD,+BAA+BwY,QACpC3b,KAAKsD,8BAA8BqY,QACnC3b,KAAK2L,8BAA8BgQ,QACnC3b,KAAKgM,kBAAkB2P,QACvB3b,KAAKsM,2BAA2BqP,QAChC3b,KAAKuM,0BAA0BoP,QAC/B3b,KAAKwM,0BAA0BmP,QAC/B3b,KAAKyM,yBAAyBkP,QAC9B3b,KAAK0M,6BAA6BiP,QAClC3b,KAAK2M,4BAA4BgP,QACjC3b,KAAK4M,kCAAkC+O,QACvC3b,KAAK6M,iCAAiC8O,QACtC3b,KAAK8M,yBAAyB6O,QAC9B3b,KAAK+M,wBAAwB4O,QAC7B3b,KAAKgN,6BAA6B2O,QAClC3b,KAAKiN,4BAA4B0O,QACjC3b,KAAKkN,6BAA6ByO,QAClC3b,KAAKmN,kCAAkCwO,QACvC3b,KAAKoN,4BAA4BuO,QACjC3b,KAAKqN,iCAAiCsO,QACtC3b,KAAKsN,4BAA4BqO,QACjC3b,KAAKuN,2BAA2BoO,QAChC3b,KAAKkO,uBAAuByN,QAC5B3b,KAAKmO,oBAAoBwN,QACzB3b,KAAKoO,wBAAwBuN,QAC7B3b,KAAKqO,qBAAqBsN,QAC1B3b,KAAKuH,sBAAsBoU,QAC3B3b,KAAKc,4CAA4C6a,QACjD3b,KAAKG,8BAA8Bwb,QACnC3b,KAAKuB,sCAAsCoa,QAC3C3b,KAAKgO,oCAAoC2N,QACzC3b,KAAK4Q,aAAc,CACvB,CACA,YAAA2gB,CAAaG,EAAOpvB,GAChB,MAAMqvB,EAAYD,EAAMP,MAAM,GAC9B7uB,EAAWA,GAAY,CAAEkvB,GAASA,EAAK7U,WACvC,IAAK,MAAM6U,KAAQG,EACfrvB,EAASkvB,GAEbE,EAAM/oB,OAAS,CACnB,CAIA,cAAIynB,GACA,OAAOpwB,KAAK4Q,WAChB,CAKA,qBAAAghB,GACI,IAAK,IAAIC,EAAY,EAAGA,EAAY7xB,KAAK2B,OAAOgH,OAAQkpB,IAAa,CACjE,MACMnO,EADO1jB,KAAK2B,OAAOkwB,GACHnO,SAClBA,GACAA,EAASoO,iBAEjB,CACJ,CAKA,wBAAAC,GACI,IAAK,MAAMC,KAAehyB,KAAKyK,SAAU,CACtBunB,EAAYC,UAEvBD,EAAYC,QAAU,KAE9B,CACJ,CAOA,eAAAC,CAAgBC,GACZ,MAAMjD,EAAM,IAAI,KAAQkD,OAAOC,UAAWD,OAAOC,UAAWD,OAAOC,WAC7DrD,EAAM,IAAI,MAASoD,OAAOC,WAAYD,OAAOC,WAAYD,OAAOC,WAatE,OAZAF,EAAkBA,GAAmB,MAAO,GAC5CnyB,KAAK2B,OAAOsiB,OAAOkO,GAAiBnwB,SAASmT,IAEzC,GADAA,EAAKqT,oBAAmB,IACnBrT,EAAKC,WAAuC,IAA1BD,EAAKC,UAAUzM,QAAgBwM,EAAKmd,iBACvD,OAEJ,MAAMC,EAAepd,EAAKqd,kBACpBC,EAASF,EAAaG,YAAYC,aAClCC,EAASL,EAAaG,YAAYG,aACxC,KAAQC,aAAaL,EAAQvD,EAAKF,GAClC,KAAQ8D,aAAaF,EAAQ1D,EAAKF,EAAI,IAEnC,CACHE,IAAKA,EACLF,IAAKA,EAEb,CAYA,gBAAA+D,CAAiB3tB,EAAGC,EAAG2tB,EAAOjZ,EAAQkZ,GAAkB,GACpD,MAAM,OAAY,MACtB,CAaA,qBAAAC,CAAsB9tB,EAAGC,EAAG2tB,EAAOG,EAAQpZ,EAAQkZ,GAAkB,EAAOG,GAAuB,GAC/F,MAAM,OAAY,MACtB,CASA,6BAAAC,CAA8BjuB,EAAGC,EAAG0U,GAChC,MAAM,OAAY,MACtB,CAUA,kCAAAuZ,CAAmCluB,EAAGC,EAAG8tB,EAAQpZ,GAC7C,MAAM,OAAY,MACtB,CAUA,IAAAwZ,CAAKnuB,EAAGC,EAAGkd,EAAWiR,EAAWzZ,EAAQ0Z,GACrC,MAAMC,GAAO,OAAY,OAAO,GAKhC,OAJIA,GACA,IAAOC,KAAKD,GAGT,IAAI,GACf,CASA,oBAAAE,CAAqBxuB,EAAGC,EAAGkd,EAAWiR,EAAWzZ,GAC7C,MAAM2Z,GAAO,OAAY,OAAO,GAKhC,OAJIA,GACA,IAAOC,KAAKD,GAGT,IAAI,GACf,CAWA,WAAAG,CAAYC,EAAKvR,EAAWiR,EAAWC,GACnC,MAAM,OAAY,MACtB,CAYA,SAAAM,CAAU3uB,EAAGC,EAAGkd,EAAWxI,EAAQ0Z,GAC/B,MAAM,OAAY,MACtB,CASA,gBAAAO,CAAiBF,EAAKvR,EAAWkR,GAC7B,MAAM,OAAY,MACtB,CAOA,kBAAAQ,CAAmB9e,EAAM8C,EAAWN,GAChC3X,KAAKiE,cAAcgwB,mBAAmB9e,EAAM8C,EAAWN,EAC3D,CAKA,kBAAAuc,GACI,OAAOl0B,KAAKiE,cAAciwB,oBAC9B,CAGA,kBAAAC,GACI,IAAK,MAAMzQ,KAAY1jB,KAAKuK,WACxBmZ,EAAS0Q,WAEb,IAAK,MAAMjf,KAAQnV,KAAK2B,OACpBwT,EAAKif,WAELp0B,KAAK2U,oBACL3U,KAAK2U,mBAAmByf,WAE5B,IAAK,MAAMxrB,KAAa5I,KAAK+I,YACzBH,EAAUyrB,UAEd,IAAK,MAAMC,KAAUt0B,KAAKiK,gBACtBqqB,EAAOD,UAEX,GAAIr0B,KAAKu0B,eACL,IAAK,MAAMC,KAAax0B,KAAKu0B,eACzBC,EAAUH,SAGtB,CAEA,gBAAAI,GACI,IAAK,MAAMrN,KAAWpnB,KAAKyK,SACvB2c,EAAQgN,UAAS,GAErBp0B,KAAKiB,wBAAwB,EACjC,CAQA,UAAAyzB,CAAWC,EAAMC,EAAW3Q,GACxB,QAAkB9M,IAAdyd,EAEA,OAAOD,EAEX,MAAME,EAAa,GACnB,IAAK,MAAM1N,KAAKwN,EAAM,CAClB,MAAMnD,EAAOmD,EAAKxN,GACd,KAAQ,IAAK2N,aAAatD,EAAMoD,MAAgB3Q,GAAUA,EAAOuN,KACjEqD,EAAW7rB,KAAKwoB,EAExB,CACA,OAAOqD,CACX,CAOA,eAAAE,CAAgBH,EAAW3Q,GACvB,OAAOjkB,KAAK00B,WAAW10B,KAAK2B,OAAQizB,EAAW3Q,EACnD,CAOA,gBAAA+Q,CAAiBJ,EAAW3Q,GACxB,OAAOjkB,KAAK00B,WAAW10B,KAAK6B,QAAS+yB,EAAW3Q,EACpD,CAOA,eAAAgR,CAAgBL,EAAW3Q,GACvB,OAAOjkB,KAAK00B,WAAW10B,KAAK4B,OAAQgzB,EAAW3Q,EACnD,CAOA,iBAAAiR,CAAkBN,EAAW3Q,GACzB,OAAOjkB,KAAK00B,WAAW10B,KAAKqK,UAAWuqB,EAAW3Q,GAAQviB,OAAO1B,KAAK00B,WAAW10B,KAAKoK,eAAgBwqB,EAAW3Q,GACrH,CAOA,uBAAAkR,CAAwBP,EAAW3Q,GAC/B,OAAOjkB,KAAK00B,WAAW10B,KAAK8B,eAAgB8yB,EAAW3Q,EAC3D,CAUA,iBAAAmR,CAAkBC,EAAkBC,EAAsB,KAAMC,EAAyB,KAAMC,EAA2B,MACtHx1B,KAAKU,kBAAkB00B,kBAAkBC,EAAkBC,EAAqBC,EAAwBC,EAC5G,CASA,iCAAAC,CAAkCJ,EAAkBK,EAAuBC,GAAQ,EAAMC,GAAU,GAC/F51B,KAAKU,kBAAkB+0B,kCAAkCJ,EAAkBK,EAAuBC,EAAOC,EAC7G,CAOA,6BAAAC,CAA8Brd,GAC1B,OAAOxY,KAAKU,kBAAkBm1B,8BAA8Brd,EAChE,CAEA,iCAAAsd,CAAkC51B,GAC9BF,KAAK+T,6BAA+B7T,CACxC,CAEA,+BAAI61B,GACA,OAAO/1B,KAAK+T,4BAChB,CACA,+BAAIgiB,CAA4B71B,GACxBF,KAAK+T,+BAAiC7T,IAG1CF,KAAK+T,6BAA+B7T,EAC/BA,GAEDF,KAAKiB,wBAAwB,IAErC,CAMA,uBAAAA,CAAwB+0B,EAAMzT,GAC1B,IAAIviB,KAAK+T,6BAGT,IAAK,MAAMsC,KAAYrW,KAAKqK,UACpBkY,IAAcA,EAAUlM,IAG5BA,EAAS4f,YAAYD,EAE7B,CAIA,SAAAE,CAAUC,EAAW1O,EAAW2O,EAAYC,EAAmBC,EAAgB5O,EAAS6O,GACpF,MAAMnF,GAAU,QAAS+E,EAAW1O,EAAW2O,EAAYC,EAAoBr2B,KAAKw2B,qBAAkBrf,EAAWmf,EAAgB5O,EAAS6O,GAK1I,OAJAv2B,KAAK0Q,gBAAgB1H,KAAKooB,GAC1BA,EAAQqF,qBAAqB/zB,KAAK0uB,IAC9BpxB,KAAK0Q,gBAAgByK,OAAOnb,KAAK0Q,gBAAgBiJ,QAAQyX,GAAU,EAAE,IAElEA,CACX,CAIA,cAAAsF,CAAeP,EAAWC,EAAYC,EAAmBC,EAAgBC,GACrE,OAAO,IAAI9a,SAAQ,CAACC,EAASib,KACzB32B,KAAKk2B,UAAUC,GAAY/iB,IACvBsI,EAAQtI,EAAK,GACdgjB,EAAYC,EAAmBC,GAAgB,CAAClF,EAASwF,KACxDD,EAAOC,EAAU,GAClBL,EAAS,GAEpB,CAIA,YAAAM,CAAaC,EAAKrP,EAAW2O,EAAYC,EAAmBC,EAAgB5O,EAAS6O,GACjF,MAAMnF,GAAU,QAAY0F,EAAKrP,EAAW2O,EAAYC,EAAoBr2B,KAAKw2B,qBAAkBrf,EAAWmf,EAAgB5O,EAAS6O,GAKvI,OAJAv2B,KAAK0Q,gBAAgB1H,KAAKooB,GAC1BA,EAAQqF,qBAAqB/zB,KAAK0uB,IAC9BpxB,KAAK0Q,gBAAgByK,OAAOnb,KAAK0Q,gBAAgBiJ,QAAQyX,GAAU,EAAE,IAElEA,CACX,CAIA,iBAAA2F,CAAkBD,EAAKV,EAAYC,EAAmBC,EAAgBC,GAClE,OAAO,IAAI9a,SAAQ,CAACC,EAASib,KACzB32B,KAAK62B,aAAaC,GAAM1jB,IACpBsI,EAAQtI,EAAK,GACdgjB,EAAYC,EAAmBC,GAAiBU,IAC/CL,EAAOK,EAAM,GACdT,EAAS,GAEpB,CAIA,SAAAU,CAAUC,EAAMzP,EAAW2O,EAAYE,EAAgB5O,GACnD,MAAM0J,GAAU,QAAS8F,EAAMzP,EAAW2O,EAAYE,EAAgB5O,GAKtE,OAJA1nB,KAAK0Q,gBAAgB1H,KAAKooB,GAC1BA,EAAQqF,qBAAqB/zB,KAAK0uB,IAC9BpxB,KAAK0Q,gBAAgByK,OAAOnb,KAAK0Q,gBAAgBiJ,QAAQyX,GAAU,EAAE,IAElEA,CACX,CAIA,cAAA+F,CAAeD,EAAMd,EAAYE,GAC7B,OAAO,IAAI7a,SAAQ,CAACC,EAASib,KACzB32B,KAAKi3B,UAAUC,GAAO9jB,IAClBsI,EAAQtI,EAAK,GACdgjB,EAAYE,GAAiBU,IAC5BL,EAAOK,EAAM,GACf,GAEV,CAMA,gBAAAI,GACI,MAAM,OAAY,kCACtB,CAQA,mBAAAC,CAAoBrV,GAChB,OAAOhiB,KAAK+hB,oBAAoBC,EACpC,CAOA,eAAAsV,CAAgBtV,GACZ,OAAOhiB,KAAKyiB,gBAAgBT,EAChC,CAOA,mBAAAuV,CAAoBvV,GAChB,OAAOhiB,KAAK2iB,oBAAoBX,EACpC,CAOA,oBAAAwV,CAAqBhW,GACjB,OAAOxhB,KAAK4iB,qBAAqBpB,EACrC,CAOA,aAAAiW,CAAczV,GACV,OAAOhiB,KAAKiiB,cAAcD,EAC9B,CAOA,mBAAA0V,CAAoBlW,GAChB,OAAOxhB,KAAK8iB,oBAAoBtB,EACpC,CAOA,WAAAmW,CAAY3V,GACR,OAAOhiB,KAAK+iB,YAAYf,EAC5B,CAOA,YAAA4V,CAAa5V,GACT,OAAOhiB,KAAKojB,aAAapB,EAC7B,CAOA,kBAAA6V,CAAmBrW,GACf,OAAOxhB,KAAKqjB,mBAAmB7B,EACnC,CAOA,qBAAAsW,CAAsB9V,GAClB,OAAOhiB,KAAKsjB,sBAAsBtB,EACtC,CAOA,eAAA+V,CAAgB/V,GACZ,OAAOhiB,KAAKujB,gBAAgBvB,EAChC,CAOA,WAAAgW,CAAYhW,GACR,OAAOhiB,KAAK+jB,YAAY/B,EAC5B,CAOA,iBAAAiW,CAAkBzW,GACd,OAAOxhB,KAAKqkB,kBAAkB7C,EAClC,CAOA,eAAA0W,CAAgBlW,GACZ,OAAOhiB,KAAKskB,gBAAgBtC,EAChC,CAOA,aAAAmW,CAAcnW,GACV,OAAOhiB,KAAKgkB,cAAchC,EAC9B,CAOA,oBAAAoW,CAAqBpW,GACjB,OAAOhiB,KAAKkkB,qBAAqBlC,EACrC,CAOA,0BAAAqW,CAA2B7W,GACvB,OAAOxhB,KAAKmkB,2BAA2B3C,EAC3C,CAOA,qBAAA8W,CAAsBtW,GAClB,OAAOhiB,KAAKokB,sBAAsBpC,EACtC,CAOA,WAAAuW,CAAYvW,GACR,OAAOhiB,KAAKykB,YAAYzC,EAC5B,CAOA,gBAAAwW,CAAiBxW,GACb,OAAOhiB,KAAKwkB,iBAAiBxC,EACjC,CAOA,mBAAAyW,CAAoBzW,GAChB,OAAOhiB,KAAKglB,oBAAoBhD,EACpC,EAGJriB,EAAM4O,aAAe,EAErB5O,EAAM+4B,YAAc,EAEpB/4B,EAAMg5B,aAAe,EAErBh5B,EAAMi5B,eAAiB,EAKvBj5B,EAAMsvB,aAAe,EAKrBtvB,EAAMyvB,aAAe,KAErB,QAAc,gBAAiBzvB,E","sources":["webpack://@react-babylonjs/docs/../../node_modules/@babylonjs/core/scene.js"],"sourcesContent":["import { Tools } from \"./Misc/tools.js\";\nimport { PrecisionDate } from \"./Misc/precisionDate.js\";\nimport { Observable } from \"./Misc/observable.js\";\nimport { SmartArrayNoDuplicate, SmartArray } from \"./Misc/smartArray.js\";\nimport { StringDictionary } from \"./Misc/stringDictionary.js\";\nimport { Tags } from \"./Misc/tags.js\";\nimport { Vector3, Matrix, TmpVectors } from \"./Maths/math.vector.js\";\nimport { ImageProcessingConfiguration } from \"./Materials/imageProcessingConfiguration.js\";\nimport { UniformBuffer } from \"./Materials/uniformBuffer.js\";\nimport { PickingInfo } from \"./Collisions/pickingInfo.js\";\nimport { ActionEvent } from \"./Actions/actionEvent.js\";\nimport { PostProcessManager } from \"./PostProcesses/postProcessManager.js\";\nimport { RenderingManager } from \"./Rendering/renderingManager.js\";\nimport { Stage } from \"./sceneComponent.js\";\n\nimport { IsWindowObjectExist } from \"./Misc/domManagement.js\";\nimport { EngineStore } from \"./Engines/engineStore.js\";\nimport { _WarnImport } from \"./Misc/devTools.js\";\nimport { InputManager } from \"./Inputs/scene.inputManager.js\";\nimport { PerfCounter } from \"./Misc/perfCounter.js\";\nimport { Color4, Color3 } from \"./Maths/math.color.js\";\nimport { Frustum } from \"./Maths/math.frustum.js\";\nimport { UniqueIdGenerator } from \"./Misc/uniqueIdGenerator.js\";\nimport { ReadFile, RequestFile, LoadFile } from \"./Misc/fileTools.js\";\nimport { LightConstants } from \"./Lights/lightConstants.js\";\nimport { _ObserveArray } from \"./Misc/arrayTools.js\";\nimport { PointerPickingConfiguration } from \"./Inputs/pointerPickingConfiguration.js\";\nimport { Logger } from \"./Misc/logger.js\";\nimport { RegisterClass } from \"./Misc/typeStore.js\";\n/**\n * Define how the scene should favor performance over ease of use\n */\nexport var ScenePerformancePriority;\n(function (ScenePerformancePriority) {\n    /** Default mode. No change. Performance will be treated as less important than backward compatibility */\n    ScenePerformancePriority[ScenePerformancePriority[\"BackwardCompatible\"] = 0] = \"BackwardCompatible\";\n    /** Some performance options will be turned on trying to strike a balance between perf and ease of use */\n    ScenePerformancePriority[ScenePerformancePriority[\"Intermediate\"] = 1] = \"Intermediate\";\n    /** Performance will be top priority */\n    ScenePerformancePriority[ScenePerformancePriority[\"Aggressive\"] = 2] = \"Aggressive\";\n})(ScenePerformancePriority || (ScenePerformancePriority = {}));\n/**\n * Represents a scene to be rendered by the engine.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene\n */\nexport class Scene {\n    // eslint-disable-next-line jsdoc/require-returns-check\n    /**\n     * Factory used to create the default material.\n     * @param scene The scene to create the material for\n     * @returns The default material\n     */\n    static DefaultMaterialFactory(scene) {\n        throw _WarnImport(\"StandardMaterial\");\n    }\n    // eslint-disable-next-line jsdoc/require-returns-check\n    /**\n     * Factory used to create the a collision coordinator.\n     * @returns The collision coordinator\n     */\n    static CollisionCoordinatorFactory() {\n        throw _WarnImport(\"DefaultCollisionCoordinator\");\n    }\n    /**\n     * Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))\n     */\n    get clearColor() {\n        return this._clearColor;\n    }\n    set clearColor(value) {\n        if (value !== this._clearColor) {\n            this._clearColor = value;\n            this.onClearColorChangedObservable.notifyObservers(this._clearColor);\n        }\n    }\n    /**\n     * Default image processing configuration used either in the rendering\n     * Forward main pass or through the imageProcessingPostProcess if present.\n     * As in the majority of the scene they are the same (exception for multi camera),\n     * this is easier to reference from here than from all the materials and post process.\n     *\n     * No setter as we it is a shared configuration, you can set the values instead.\n     */\n    get imageProcessingConfiguration() {\n        return this._imageProcessingConfiguration;\n    }\n    /**\n     * Gets or sets a value indicating how to treat performance relatively to ease of use and backward compatibility\n     */\n    get performancePriority() {\n        return this._performancePriority;\n    }\n    set performancePriority(value) {\n        if (value === this._performancePriority) {\n            return;\n        }\n        this._performancePriority = value;\n        switch (value) {\n            case 0 /* ScenePerformancePriority.BackwardCompatible */:\n                this.skipFrustumClipping = false;\n                this._renderingManager.maintainStateBetweenFrames = false;\n                this.skipPointerMovePicking = false;\n                this.autoClear = true;\n                break;\n            case 1 /* ScenePerformancePriority.Intermediate */:\n                this.skipFrustumClipping = false;\n                this._renderingManager.maintainStateBetweenFrames = false;\n                this.skipPointerMovePicking = true;\n                this.autoClear = false;\n                break;\n            case 2 /* ScenePerformancePriority.Aggressive */:\n                this.skipFrustumClipping = true;\n                this._renderingManager.maintainStateBetweenFrames = true;\n                this.skipPointerMovePicking = true;\n                this.autoClear = false;\n                break;\n        }\n        this.onScenePerformancePriorityChangedObservable.notifyObservers(value);\n    }\n    /**\n     * Gets or sets a boolean indicating if all rendering must be done in wireframe\n     */\n    set forceWireframe(value) {\n        if (this._forceWireframe === value) {\n            return;\n        }\n        this._forceWireframe = value;\n        this.markAllMaterialsAsDirty(16);\n    }\n    get forceWireframe() {\n        return this._forceWireframe;\n    }\n    /**\n     * Gets or sets a boolean indicating if we should skip the frustum clipping part of the active meshes selection\n     */\n    set skipFrustumClipping(value) {\n        if (this._skipFrustumClipping === value) {\n            return;\n        }\n        this._skipFrustumClipping = value;\n    }\n    get skipFrustumClipping() {\n        return this._skipFrustumClipping;\n    }\n    /**\n     * Gets or sets a boolean indicating if all rendering must be done in point cloud\n     */\n    set forcePointsCloud(value) {\n        if (this._forcePointsCloud === value) {\n            return;\n        }\n        this._forcePointsCloud = value;\n        this.markAllMaterialsAsDirty(16);\n    }\n    get forcePointsCloud() {\n        return this._forcePointsCloud;\n    }\n    /**\n     * Texture used in all pbr material as the reflection texture.\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to reference from here than from all the materials.\n     */\n    get environmentTexture() {\n        return this._environmentTexture;\n    }\n    /**\n     * Texture used in all pbr material as the reflection texture.\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to set here than in all the materials.\n     */\n    set environmentTexture(value) {\n        if (this._environmentTexture === value) {\n            return;\n        }\n        this._environmentTexture = value;\n        this.onEnvironmentTextureChangedObservable.notifyObservers(value);\n        this.markAllMaterialsAsDirty(1);\n    }\n    /**\n     * @returns all meshes, lights, cameras, transformNodes and bones\n     */\n    getNodes() {\n        let nodes = [];\n        nodes = nodes.concat(this.meshes);\n        nodes = nodes.concat(this.lights);\n        nodes = nodes.concat(this.cameras);\n        nodes = nodes.concat(this.transformNodes); // dummies\n        this.skeletons.forEach((skeleton) => (nodes = nodes.concat(skeleton.bones)));\n        return nodes;\n    }\n    /**\n     * Gets or sets the animation properties override\n     */\n    get animationPropertiesOverride() {\n        return this._animationPropertiesOverride;\n    }\n    set animationPropertiesOverride(value) {\n        this._animationPropertiesOverride = value;\n    }\n    /** Sets a function to be executed when this scene is disposed. */\n    set onDispose(callback) {\n        if (this._onDisposeObserver) {\n            this.onDisposeObservable.remove(this._onDisposeObserver);\n        }\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    }\n    /** Sets a function to be executed before rendering this scene */\n    set beforeRender(callback) {\n        if (this._onBeforeRenderObserver) {\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n        }\n        if (callback) {\n            this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n        }\n    }\n    /** Sets a function to be executed after rendering this scene */\n    set afterRender(callback) {\n        if (this._onAfterRenderObserver) {\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n        }\n        if (callback) {\n            this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n        }\n    }\n    /** Sets a function to be executed before rendering a camera*/\n    set beforeCameraRender(callback) {\n        if (this._onBeforeCameraRenderObserver) {\n            this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n        }\n        this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);\n    }\n    /** Sets a function to be executed after rendering a camera*/\n    set afterCameraRender(callback) {\n        if (this._onAfterCameraRenderObserver) {\n            this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);\n        }\n        this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);\n    }\n    /**\n     * Gets or sets a predicate used to select candidate meshes for a pointer down event\n     */\n    get pointerDownPredicate() {\n        return this._pointerPickingConfiguration.pointerDownPredicate;\n    }\n    set pointerDownPredicate(value) {\n        this._pointerPickingConfiguration.pointerDownPredicate = value;\n    }\n    /**\n     * Gets or sets a predicate used to select candidate meshes for a pointer up event\n     */\n    get pointerUpPredicate() {\n        return this._pointerPickingConfiguration.pointerUpPredicate;\n    }\n    set pointerUpPredicate(value) {\n        this._pointerPickingConfiguration.pointerUpPredicate = value;\n    }\n    /**\n     * Gets or sets a predicate used to select candidate meshes for a pointer move event\n     */\n    get pointerMovePredicate() {\n        return this._pointerPickingConfiguration.pointerMovePredicate;\n    }\n    set pointerMovePredicate(value) {\n        this._pointerPickingConfiguration.pointerMovePredicate = value;\n    }\n    /**\n     * Gets or sets a predicate used to select candidate meshes for a pointer down event\n     */\n    get pointerDownFastCheck() {\n        return this._pointerPickingConfiguration.pointerDownFastCheck;\n    }\n    set pointerDownFastCheck(value) {\n        this._pointerPickingConfiguration.pointerDownFastCheck = value;\n    }\n    /**\n     * Gets or sets a predicate used to select candidate meshes for a pointer up event\n     */\n    get pointerUpFastCheck() {\n        return this._pointerPickingConfiguration.pointerUpFastCheck;\n    }\n    set pointerUpFastCheck(value) {\n        this._pointerPickingConfiguration.pointerUpFastCheck = value;\n    }\n    /**\n     * Gets or sets a predicate used to select candidate meshes for a pointer move event\n     */\n    get pointerMoveFastCheck() {\n        return this._pointerPickingConfiguration.pointerMoveFastCheck;\n    }\n    set pointerMoveFastCheck(value) {\n        this._pointerPickingConfiguration.pointerMoveFastCheck = value;\n    }\n    /**\n     * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer move event occurs.\n     */\n    get skipPointerMovePicking() {\n        return this._pointerPickingConfiguration.skipPointerMovePicking;\n    }\n    set skipPointerMovePicking(value) {\n        this._pointerPickingConfiguration.skipPointerMovePicking = value;\n    }\n    /**\n     * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer down event occurs.\n     */\n    get skipPointerDownPicking() {\n        return this._pointerPickingConfiguration.skipPointerDownPicking;\n    }\n    set skipPointerDownPicking(value) {\n        this._pointerPickingConfiguration.skipPointerDownPicking = value;\n    }\n    /**\n     * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer up event occurs.  Off by default.\n     */\n    get skipPointerUpPicking() {\n        return this._pointerPickingConfiguration.skipPointerUpPicking;\n    }\n    set skipPointerUpPicking(value) {\n        this._pointerPickingConfiguration.skipPointerUpPicking = value;\n    }\n    /**\n     * Gets the pointer coordinates without any translation (ie. straight out of the pointer event)\n     */\n    get unTranslatedPointer() {\n        return this._inputManager.unTranslatedPointer;\n    }\n    /**\n     * Gets or sets the distance in pixel that you have to move to prevent some events. Default is 10 pixels\n     */\n    static get DragMovementThreshold() {\n        return InputManager.DragMovementThreshold;\n    }\n    static set DragMovementThreshold(value) {\n        InputManager.DragMovementThreshold = value;\n    }\n    /**\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 500 ms\n     */\n    static get LongPressDelay() {\n        return InputManager.LongPressDelay;\n    }\n    static set LongPressDelay(value) {\n        InputManager.LongPressDelay = value;\n    }\n    /**\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 300 ms\n     */\n    static get DoubleClickDelay() {\n        return InputManager.DoubleClickDelay;\n    }\n    static set DoubleClickDelay(value) {\n        InputManager.DoubleClickDelay = value;\n    }\n    /** If you need to check double click without raising a single click at first click, enable this flag */\n    static get ExclusiveDoubleClickMode() {\n        return InputManager.ExclusiveDoubleClickMode;\n    }\n    static set ExclusiveDoubleClickMode(value) {\n        InputManager.ExclusiveDoubleClickMode = value;\n    }\n    /**\n     * Bind the current view position to an effect.\n     * @param effect The effect to be bound\n     * @param variableName name of the shader variable that will hold the eye position\n     * @param isVector3 true to indicates that variableName is a Vector3 and not a Vector4\n     * @returns the computed eye position\n     */\n    bindEyePosition(effect, variableName = \"vEyePosition\", isVector3 = false) {\n        const eyePosition = this._forcedViewPosition\n            ? this._forcedViewPosition\n            : this._mirroredCameraPosition\n                ? this._mirroredCameraPosition\n                : (this.activeCamera?.globalPosition ?? Vector3.ZeroReadOnly);\n        const invertNormal = this.useRightHandedSystem === (this._mirroredCameraPosition != null);\n        TmpVectors.Vector4[0].set(eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);\n        if (effect) {\n            if (isVector3) {\n                effect.setFloat3(variableName, TmpVectors.Vector4[0].x, TmpVectors.Vector4[0].y, TmpVectors.Vector4[0].z);\n            }\n            else {\n                effect.setVector4(variableName, TmpVectors.Vector4[0]);\n            }\n        }\n        return TmpVectors.Vector4[0];\n    }\n    /**\n     * Update the scene ubo before it can be used in rendering processing\n     * @returns the scene UniformBuffer\n     */\n    finalizeSceneUbo() {\n        const ubo = this.getSceneUniformBuffer();\n        const eyePosition = this.bindEyePosition(null);\n        ubo.updateFloat4(\"vEyePosition\", eyePosition.x, eyePosition.y, eyePosition.z, eyePosition.w);\n        ubo.update();\n        return ubo;\n    }\n    /**\n     * Gets or sets a boolean indicating if the scene must use right-handed coordinates system\n     */\n    set useRightHandedSystem(value) {\n        if (this._useRightHandedSystem === value) {\n            return;\n        }\n        this._useRightHandedSystem = value;\n        this.markAllMaterialsAsDirty(16);\n    }\n    get useRightHandedSystem() {\n        return this._useRightHandedSystem;\n    }\n    /**\n     * Sets the step Id used by deterministic lock step\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n     * @param newStepId defines the step Id\n     */\n    setStepId(newStepId) {\n        this._currentStepId = newStepId;\n    }\n    /**\n     * Gets the step Id used by deterministic lock step\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n     * @returns the step Id\n     */\n    getStepId() {\n        return this._currentStepId;\n    }\n    /**\n     * Gets the internal step used by deterministic lock step\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n     * @returns the internal step\n     */\n    getInternalStep() {\n        return this._currentInternalStep;\n    }\n    /**\n     * Gets or sets a boolean indicating if fog is enabled on this scene\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * (Default is true)\n     */\n    set fogEnabled(value) {\n        if (this._fogEnabled === value) {\n            return;\n        }\n        this._fogEnabled = value;\n        this.markAllMaterialsAsDirty(16);\n    }\n    get fogEnabled() {\n        return this._fogEnabled;\n    }\n    /**\n     * Gets or sets the fog mode to use\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n     * | mode | value |\n     * | --- | --- |\n     * | FOGMODE_NONE | 0 |\n     * | FOGMODE_EXP | 1 |\n     * | FOGMODE_EXP2 | 2 |\n     * | FOGMODE_LINEAR | 3 |\n     */\n    set fogMode(value) {\n        if (this._fogMode === value) {\n            return;\n        }\n        this._fogMode = value;\n        this.markAllMaterialsAsDirty(16);\n    }\n    get fogMode() {\n        return this._fogMode;\n    }\n    /**\n     * Flag indicating that the frame buffer binding is handled by another component\n     */\n    get prePass() {\n        return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;\n    }\n    /**\n     * Gets or sets a boolean indicating if shadows are enabled on this scene\n     */\n    set shadowsEnabled(value) {\n        if (this._shadowsEnabled === value) {\n            return;\n        }\n        this._shadowsEnabled = value;\n        this.markAllMaterialsAsDirty(2);\n    }\n    get shadowsEnabled() {\n        return this._shadowsEnabled;\n    }\n    /**\n     * Gets or sets a boolean indicating if lights are enabled on this scene\n     */\n    set lightsEnabled(value) {\n        if (this._lightsEnabled === value) {\n            return;\n        }\n        this._lightsEnabled = value;\n        this.markAllMaterialsAsDirty(2);\n    }\n    get lightsEnabled() {\n        return this._lightsEnabled;\n    }\n    /** All of the active cameras added to this scene. */\n    get activeCameras() {\n        return this._activeCameras;\n    }\n    set activeCameras(cameras) {\n        if (this._unObserveActiveCameras) {\n            this._unObserveActiveCameras();\n            this._unObserveActiveCameras = null;\n        }\n        if (cameras) {\n            this._unObserveActiveCameras = _ObserveArray(cameras, () => {\n                this.onActiveCamerasChanged.notifyObservers(this);\n            });\n        }\n        this._activeCameras = cameras;\n    }\n    /** Gets or sets the current active camera */\n    get activeCamera() {\n        return this._activeCamera;\n    }\n    set activeCamera(value) {\n        if (value === this._activeCamera) {\n            return;\n        }\n        this._activeCamera = value;\n        this.onActiveCameraChanged.notifyObservers(this);\n    }\n    /** The default material used on meshes when no material is affected */\n    get defaultMaterial() {\n        if (!this._defaultMaterial) {\n            this._defaultMaterial = Scene.DefaultMaterialFactory(this);\n        }\n        return this._defaultMaterial;\n    }\n    /** The default material used on meshes when no material is affected */\n    set defaultMaterial(value) {\n        this._defaultMaterial = value;\n    }\n    /**\n     * Gets or sets a boolean indicating if textures are enabled on this scene\n     */\n    set texturesEnabled(value) {\n        if (this._texturesEnabled === value) {\n            return;\n        }\n        this._texturesEnabled = value;\n        this.markAllMaterialsAsDirty(1);\n    }\n    get texturesEnabled() {\n        return this._texturesEnabled;\n    }\n    /**\n     * Gets or sets the frame graph used to render the scene. If set, the scene will use the frame graph to render the scene instead of the default render loop.\n     */\n    get frameGraph() {\n        return this._frameGraph;\n    }\n    set frameGraph(value) {\n        if (this._frameGraph) {\n            this._frameGraph = value;\n            if (!value) {\n                this.customRenderFunction = this._currentCustomRenderFunction;\n            }\n            return;\n        }\n        this._frameGraph = value;\n        if (value) {\n            this._currentCustomRenderFunction = this.customRenderFunction;\n            this.customRenderFunction = this._renderWithFrameGraph;\n        }\n    }\n    /**\n     * Gets or sets a boolean indicating if skeletons are enabled on this scene\n     */\n    set skeletonsEnabled(value) {\n        if (this._skeletonsEnabled === value) {\n            return;\n        }\n        this._skeletonsEnabled = value;\n        this.markAllMaterialsAsDirty(8);\n    }\n    get skeletonsEnabled() {\n        return this._skeletonsEnabled;\n    }\n    /** @internal */\n    get collisionCoordinator() {\n        if (!this._collisionCoordinator) {\n            this._collisionCoordinator = Scene.CollisionCoordinatorFactory();\n            this._collisionCoordinator.init(this);\n        }\n        return this._collisionCoordinator;\n    }\n    /**\n     * Gets the scene's rendering manager\n     */\n    get renderingManager() {\n        return this._renderingManager;\n    }\n    /**\n     * Gets the list of frustum planes (built from the active camera)\n     */\n    get frustumPlanes() {\n        return this._frustumPlanes;\n    }\n    /**\n     * Registers the transient components if needed.\n     */\n    _registerTransientComponents() {\n        // Register components that have been associated lately to the scene.\n        if (this._transientComponents.length > 0) {\n            for (const component of this._transientComponents) {\n                component.register();\n            }\n            this._transientComponents.length = 0;\n        }\n    }\n    /**\n     * @internal\n     * Add a component to the scene.\n     * Note that the ccomponent could be registered on th next frame if this is called after\n     * the register component stage.\n     * @param component Defines the component to add to the scene\n     */\n    _addComponent(component) {\n        this._components.push(component);\n        this._transientComponents.push(component);\n        const serializableComponent = component;\n        if (serializableComponent.addFromContainer && serializableComponent.serialize) {\n            this._serializableComponents.push(serializableComponent);\n        }\n    }\n    /**\n     * @internal\n     * Gets a component from the scene.\n     * @param name defines the name of the component to retrieve\n     * @returns the component or null if not present\n     */\n    _getComponent(name) {\n        for (const component of this._components) {\n            if (component.name === name) {\n                return component;\n            }\n        }\n        return null;\n    }\n    /**\n     * Creates a new Scene\n     * @param engine defines the engine to use to render this scene\n     * @param options defines the scene options\n     */\n    constructor(engine, options) {\n        /** @internal */\n        this._inputManager = new InputManager(this);\n        /** Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position */\n        this.cameraToUseForPointers = null;\n        /** @internal */\n        this._isScene = true;\n        /** @internal */\n        this._blockEntityCollection = false;\n        /**\n         * Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame\n         */\n        this.autoClear = true;\n        /**\n         * Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame\n         */\n        this.autoClearDepthAndStencil = true;\n        this._clearColor = new Color4(0.2, 0.2, 0.3, 1.0);\n        /**\n         * Observable triggered when the performance priority is changed\n         */\n        this.onClearColorChangedObservable = new Observable();\n        /**\n         * Defines the color used to simulate the ambient color (Default is (0, 0, 0))\n         */\n        this.ambientColor = new Color3(0, 0, 0);\n        /**\n         * Intensity of the environment in all pbr material.\n         * This dims or reinforces the IBL lighting overall (reflection and diffuse).\n         * As in the majority of the scene they are the same (exception for multi room and so on),\n         * this is easier to reference from here than from all the materials.\n         */\n        this.environmentIntensity = 1;\n        this._performancePriority = 0 /* ScenePerformancePriority.BackwardCompatible */;\n        /**\n         * Observable triggered when the performance priority is changed\n         */\n        this.onScenePerformancePriorityChangedObservable = new Observable();\n        this._forceWireframe = false;\n        this._skipFrustumClipping = false;\n        this._forcePointsCloud = false;\n        /**\n         * Gets the list of root nodes (ie. nodes with no parent)\n         */\n        this.rootNodes = [];\n        /** All of the cameras added to this scene\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n         */\n        this.cameras = [];\n        /**\n         * All of the lights added to this scene\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n         */\n        this.lights = [];\n        /**\n         * All of the (abstract) meshes added to this scene\n         */\n        this.meshes = [];\n        /**\n         * The list of skeletons added to the scene\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\n         */\n        this.skeletons = [];\n        /**\n         * All of the particle systems added to this scene\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\n         */\n        this.particleSystems = [];\n        /**\n         * Gets a list of Animations associated with the scene\n         */\n        this.animations = [];\n        /**\n         * All of the animation groups added to this scene\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\n         */\n        this.animationGroups = [];\n        /**\n         * All of the multi-materials added to this scene\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/multiMaterials\n         */\n        this.multiMaterials = [];\n        /**\n         * All of the materials added to this scene\n         * In the context of a Scene, it is not supposed to be modified manually.\n         * Any addition or removal should be done using the addMaterial and removeMaterial Scene methods.\n         * Note also that the order of the Material within the array is not significant and might change.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction\n         */\n        this.materials = [];\n        /**\n         * The list of morph target managers added to the scene\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph\n         */\n        this.morphTargetManagers = [];\n        /**\n         * The list of geometries used in the scene.\n         */\n        this.geometries = [];\n        /**\n         * All of the transform nodes added to this scene\n         * In the context of a Scene, it is not supposed to be modified manually.\n         * Any addition or removal should be done using the addTransformNode and removeTransformNode Scene methods.\n         * Note also that the order of the TransformNode within the array is not significant and might change.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/parent_pivot/transform_node\n         */\n        this.transformNodes = [];\n        /**\n         * ActionManagers available on the scene.\n         * @deprecated\n         */\n        this.actionManagers = [];\n        /**\n         * Textures to keep.\n         */\n        this.textures = [];\n        /** @internal */\n        this._environmentTexture = null;\n        /**\n         * The list of postprocesses added to the scene\n         */\n        this.postProcesses = [];\n        /**\n         * The list of effect layers (highlights/glow) added to the scene\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/highlightLayer\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/glowLayer\n         */\n        this.effectLayers = [];\n        /**\n         * The list of sounds used in the scene.\n         */\n        this.sounds = null;\n        /**\n         * The list of layers (background and foreground) of the scene\n         */\n        this.layers = [];\n        /**\n         * The list of lens flare system added to the scene\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\n         */\n        this.lensFlareSystems = [];\n        /**\n         * The list of procedural textures added to the scene\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\n         */\n        this.proceduralTextures = [];\n        /**\n         * Gets or sets a boolean indicating if animations are enabled\n         */\n        this.animationsEnabled = true;\n        this._animationPropertiesOverride = null;\n        /**\n         * Gets or sets a boolean indicating if a constant deltatime has to be used\n         * This is mostly useful for testing purposes when you do not want the animations to scale with the framerate\n         */\n        this.useConstantAnimationDeltaTime = false;\n        /**\n         * Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated\n         * Please note that it requires to run a ray cast through the scene on every frame\n         */\n        this.constantlyUpdateMeshUnderPointer = false;\n        /**\n         * Defines the HTML cursor to use when hovering over interactive elements\n         */\n        this.hoverCursor = \"pointer\";\n        /**\n         * Defines the HTML default cursor to use (empty by default)\n         */\n        this.defaultCursor = \"\";\n        /**\n         * Defines whether cursors are handled by the scene.\n         */\n        this.doNotHandleCursors = false;\n        /**\n         * This is used to call preventDefault() on pointer down\n         * in order to block unwanted artifacts like system double clicks\n         */\n        this.preventDefaultOnPointerDown = true;\n        /**\n         * This is used to call preventDefault() on pointer up\n         * in order to block unwanted artifacts like system double clicks\n         */\n        this.preventDefaultOnPointerUp = true;\n        // Metadata\n        /**\n         * Gets or sets user defined metadata\n         */\n        this.metadata = null;\n        /**\n         * For internal use only. Please do not use.\n         */\n        this.reservedDataStore = null;\n        /**\n         * Use this array to add regular expressions used to disable offline support for specific urls\n         */\n        this.disableOfflineSupportExceptionRules = [];\n        /**\n         * An event triggered when the scene is disposed.\n         */\n        this.onDisposeObservable = new Observable();\n        this._onDisposeObserver = null;\n        /**\n         * An event triggered before rendering the scene (right after animations and physics)\n         */\n        this.onBeforeRenderObservable = new Observable();\n        this._onBeforeRenderObserver = null;\n        /**\n         * An event triggered after rendering the scene\n         */\n        this.onAfterRenderObservable = new Observable();\n        /**\n         * An event triggered after rendering the scene for an active camera (When scene.render is called this will be called after each camera)\n         * This is triggered for each \"sub\" camera in a Camera Rig unlike onAfterCameraRenderObservable\n         */\n        this.onAfterRenderCameraObservable = new Observable();\n        this._onAfterRenderObserver = null;\n        /**\n         * An event triggered before animating the scene\n         */\n        this.onBeforeAnimationsObservable = new Observable();\n        /**\n         * An event triggered after animations processing\n         */\n        this.onAfterAnimationsObservable = new Observable();\n        /**\n         * An event triggered before draw calls are ready to be sent\n         */\n        this.onBeforeDrawPhaseObservable = new Observable();\n        /**\n         * An event triggered after draw calls have been sent\n         */\n        this.onAfterDrawPhaseObservable = new Observable();\n        /**\n         * An event triggered when the scene is ready\n         */\n        this.onReadyObservable = new Observable();\n        /**\n         * An event triggered before rendering a camera\n         */\n        this.onBeforeCameraRenderObservable = new Observable();\n        this._onBeforeCameraRenderObserver = null;\n        /**\n         * An event triggered after rendering a camera\n         * This is triggered for the full rig Camera only unlike onAfterRenderCameraObservable\n         */\n        this.onAfterCameraRenderObservable = new Observable();\n        this._onAfterCameraRenderObserver = null;\n        /**\n         * An event triggered when active meshes evaluation is about to start\n         */\n        this.onBeforeActiveMeshesEvaluationObservable = new Observable();\n        /**\n         * An event triggered when active meshes evaluation is done\n         */\n        this.onAfterActiveMeshesEvaluationObservable = new Observable();\n        /**\n         * An event triggered when particles rendering is about to start\n         * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\n         */\n        this.onBeforeParticlesRenderingObservable = new Observable();\n        /**\n         * An event triggered when particles rendering is done\n         * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\n         */\n        this.onAfterParticlesRenderingObservable = new Observable();\n        /**\n         * An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed\n         */\n        this.onDataLoadedObservable = new Observable();\n        /**\n         * An event triggered when a camera is created\n         */\n        this.onNewCameraAddedObservable = new Observable();\n        /**\n         * An event triggered when a camera is removed\n         */\n        this.onCameraRemovedObservable = new Observable();\n        /**\n         * An event triggered when a light is created\n         */\n        this.onNewLightAddedObservable = new Observable();\n        /**\n         * An event triggered when a light is removed\n         */\n        this.onLightRemovedObservable = new Observable();\n        /**\n         * An event triggered when a geometry is created\n         */\n        this.onNewGeometryAddedObservable = new Observable();\n        /**\n         * An event triggered when a geometry is removed\n         */\n        this.onGeometryRemovedObservable = new Observable();\n        /**\n         * An event triggered when a transform node is created\n         */\n        this.onNewTransformNodeAddedObservable = new Observable();\n        /**\n         * An event triggered when a transform node is removed\n         */\n        this.onTransformNodeRemovedObservable = new Observable();\n        /**\n         * An event triggered when a mesh is created\n         */\n        this.onNewMeshAddedObservable = new Observable();\n        /**\n         * An event triggered when a mesh is removed\n         */\n        this.onMeshRemovedObservable = new Observable();\n        /**\n         * An event triggered when a skeleton is created\n         */\n        this.onNewSkeletonAddedObservable = new Observable();\n        /**\n         * An event triggered when a skeleton is removed\n         */\n        this.onSkeletonRemovedObservable = new Observable();\n        /**\n         * An event triggered when a material is created\n         */\n        this.onNewMaterialAddedObservable = new Observable();\n        /**\n         * An event triggered when a multi material is created\n         */\n        this.onNewMultiMaterialAddedObservable = new Observable();\n        /**\n         * An event triggered when a material is removed\n         */\n        this.onMaterialRemovedObservable = new Observable();\n        /**\n         * An event triggered when a multi material is removed\n         */\n        this.onMultiMaterialRemovedObservable = new Observable();\n        /**\n         * An event triggered when a texture is created\n         */\n        this.onNewTextureAddedObservable = new Observable();\n        /**\n         * An event triggered when a texture is removed\n         */\n        this.onTextureRemovedObservable = new Observable();\n        /**\n         * An event triggered when render targets are about to be rendered\n         * Can happen multiple times per frame.\n         */\n        this.onBeforeRenderTargetsRenderObservable = new Observable();\n        /**\n         * An event triggered when render targets were rendered.\n         * Can happen multiple times per frame.\n         */\n        this.onAfterRenderTargetsRenderObservable = new Observable();\n        /**\n         * An event triggered before calculating deterministic simulation step\n         */\n        this.onBeforeStepObservable = new Observable();\n        /**\n         * An event triggered after calculating deterministic simulation step\n         */\n        this.onAfterStepObservable = new Observable();\n        /**\n         * An event triggered when the activeCamera property is updated\n         */\n        this.onActiveCameraChanged = new Observable();\n        /**\n         * An event triggered when the activeCameras property is updated\n         */\n        this.onActiveCamerasChanged = new Observable();\n        /**\n         * This Observable will be triggered before rendering each renderingGroup of each rendered camera.\n         * The RenderingGroupInfo class contains all the information about the context in which the observable is called\n         * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n         */\n        this.onBeforeRenderingGroupObservable = new Observable();\n        /**\n         * This Observable will be triggered after rendering each renderingGroup of each rendered camera.\n         * The RenderingGroupInfo class contains all the information about the context in which the observable is called\n         * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n         */\n        this.onAfterRenderingGroupObservable = new Observable();\n        /**\n         * This Observable will when a mesh has been imported into the scene.\n         */\n        this.onMeshImportedObservable = new Observable();\n        /**\n         * This Observable will when an animation file has been imported into the scene.\n         */\n        this.onAnimationFileImportedObservable = new Observable();\n        /**\n         * An event triggered when the environmentTexture is changed.\n         */\n        this.onEnvironmentTextureChangedObservable = new Observable();\n        /**\n         * An event triggered when the state of mesh under pointer, for a specific pointerId, changes.\n         */\n        this.onMeshUnderPointerUpdatedObservable = new Observable();\n        // Animations\n        /** @internal */\n        this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);\n        // Pointers\n        this._pointerPickingConfiguration = new PointerPickingConfiguration();\n        /**\n         * This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).\n         * You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true\n         */\n        this.onPrePointerObservable = new Observable();\n        /**\n         * Observable event triggered each time an input event is received from the rendering canvas\n         */\n        this.onPointerObservable = new Observable();\n        // Keyboard\n        /**\n         * This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()\n         * You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true\n         */\n        this.onPreKeyboardObservable = new Observable();\n        /**\n         * Observable event triggered each time an keyboard event is received from the hosting window\n         */\n        this.onKeyboardObservable = new Observable();\n        // Coordinates system\n        this._useRightHandedSystem = false;\n        // Deterministic lockstep\n        this._timeAccumulator = 0;\n        this._currentStepId = 0;\n        this._currentInternalStep = 0;\n        // Fog\n        this._fogEnabled = true;\n        this._fogMode = Scene.FOGMODE_NONE;\n        /**\n         * Gets or sets the fog color to use\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n         * (Default is Color3(0.2, 0.2, 0.3))\n         */\n        this.fogColor = new Color3(0.2, 0.2, 0.3);\n        /**\n         * Gets or sets the fog density to use\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n         * (Default is 0.1)\n         */\n        this.fogDensity = 0.1;\n        /**\n         * Gets or sets the fog start distance to use\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n         * (Default is 0)\n         */\n        this.fogStart = 0;\n        /**\n         * Gets or sets the fog end distance to use\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog\n         * (Default is 1000)\n         */\n        this.fogEnd = 1000.0;\n        /**\n         * Flag indicating if we need to store previous matrices when rendering\n         */\n        this.needsPreviousWorldMatrices = false;\n        // Lights\n        this._shadowsEnabled = true;\n        this._lightsEnabled = true;\n        this._unObserveActiveCameras = null;\n        // Textures\n        this._texturesEnabled = true;\n        this._frameGraph = null;\n        // Physics\n        /**\n         * Gets or sets a boolean indicating if physic engines are enabled on this scene\n         */\n        this.physicsEnabled = true;\n        // Particles\n        /**\n         * Gets or sets a boolean indicating if particles are enabled on this scene\n         */\n        this.particlesEnabled = true;\n        // Sprites\n        /**\n         * Gets or sets a boolean indicating if sprites are enabled on this scene\n         */\n        this.spritesEnabled = true;\n        // Skeletons\n        this._skeletonsEnabled = true;\n        // Lens flares\n        /**\n         * Gets or sets a boolean indicating if lens flares are enabled on this scene\n         */\n        this.lensFlaresEnabled = true;\n        // Collisions\n        /**\n         * Gets or sets a boolean indicating if collisions are enabled on this scene\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\n         */\n        this.collisionsEnabled = true;\n        /**\n         * Defines the gravity applied to this scene (used only for collisions)\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions\n         */\n        this.gravity = new Vector3(0, -9.807, 0);\n        // Postprocesses\n        /**\n         * Gets or sets a boolean indicating if postprocesses are enabled on this scene\n         */\n        this.postProcessesEnabled = true;\n        // Customs render targets\n        /**\n         * Gets or sets a boolean indicating if render targets are enabled on this scene\n         */\n        this.renderTargetsEnabled = true;\n        /**\n         * Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes\n         * We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com\n         */\n        this.dumpNextRenderTargets = false;\n        /**\n         * The list of user defined render targets added to the scene\n         */\n        this.customRenderTargets = [];\n        /**\n         * Gets the list of meshes imported to the scene through SceneLoader\n         */\n        this.importedMeshesFiles = [];\n        // Probes\n        /**\n         * Gets or sets a boolean indicating if probes are enabled on this scene\n         */\n        this.probesEnabled = true;\n        this._meshesForIntersections = new SmartArrayNoDuplicate(256);\n        // Procedural textures\n        /**\n         * Gets or sets a boolean indicating if procedural textures are enabled on this scene\n         */\n        this.proceduralTexturesEnabled = true;\n        // Performance counters\n        this._totalVertices = new PerfCounter();\n        /** @internal */\n        this._activeIndices = new PerfCounter();\n        /** @internal */\n        this._activeParticles = new PerfCounter();\n        /** @internal */\n        this._activeBones = new PerfCounter();\n        /** @internal */\n        this._animationTime = 0;\n        /**\n         * Gets or sets a general scale for animation speed\n         * @see https://www.babylonjs-playground.com/#IBU2W7#3\n         */\n        this.animationTimeScale = 1;\n        this._renderId = 0;\n        this._frameId = 0;\n        this._executeWhenReadyTimeoutId = null;\n        this._intermediateRendering = false;\n        this._defaultFrameBufferCleared = false;\n        this._viewUpdateFlag = -1;\n        this._projectionUpdateFlag = -1;\n        /** @internal */\n        this._toBeDisposed = new Array(256);\n        this._activeRequests = new Array();\n        /** @internal */\n        this._pendingData = new Array();\n        this._isDisposed = false;\n        /**\n         * Gets or sets a boolean indicating that all submeshes of active meshes must be rendered\n         * Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)\n         */\n        this.dispatchAllSubMeshesOfActiveMeshes = false;\n        this._activeMeshes = new SmartArray(256);\n        this._processedMaterials = new SmartArray(256);\n        this._renderTargets = new SmartArrayNoDuplicate(256);\n        this._materialsRenderTargets = new SmartArrayNoDuplicate(256);\n        /** @internal */\n        this._activeParticleSystems = new SmartArray(256);\n        this._activeSkeletons = new SmartArrayNoDuplicate(32);\n        this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);\n        /** @internal */\n        this._activeAnimatables = new Array();\n        this._transformMatrix = Matrix.Zero();\n        /**\n         * Gets or sets a boolean indicating if lights must be sorted by priority (off by default)\n         * This is useful if there are more lights that the maximum simulteanous authorized\n         */\n        this.requireLightSorting = false;\n        /**\n         * @internal\n         * Backing store of defined scene components.\n         */\n        this._components = [];\n        /**\n         * @internal\n         * Backing store of defined scene components.\n         */\n        this._serializableComponents = [];\n        /**\n         * List of components to register on the next registration step.\n         */\n        this._transientComponents = [];\n        /**\n         * @internal\n         * Defines the actions happening before camera updates.\n         */\n        this._beforeCameraUpdateStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening before clear the canvas.\n         */\n        this._beforeClearStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening before clear the canvas.\n         */\n        this._beforeRenderTargetClearStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions when collecting render targets for the frame.\n         */\n        this._gatherRenderTargetsStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening for one camera in the frame.\n         */\n        this._gatherActiveCameraRenderTargetsStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening during the per mesh ready checks.\n         */\n        this._isReadyForMeshStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening before evaluate active mesh checks.\n         */\n        this._beforeEvaluateActiveMeshStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening during the evaluate sub mesh checks.\n         */\n        this._evaluateSubMeshStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening during the active mesh stage.\n         */\n        this._preActiveMeshStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening during the per camera render target step.\n         */\n        this._cameraDrawRenderTargetStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just before the active camera is drawing.\n         */\n        this._beforeCameraDrawStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just before a render target is drawing.\n         */\n        this._beforeRenderTargetDrawStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just before a rendering group is drawing.\n         */\n        this._beforeRenderingGroupDrawStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just before a mesh is drawing.\n         */\n        this._beforeRenderingMeshStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just after a mesh has been drawn.\n         */\n        this._afterRenderingMeshStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just after a rendering group has been drawn.\n         */\n        this._afterRenderingGroupDrawStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just after the active camera has been drawn.\n         */\n        this._afterCameraDrawStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just after the post processing\n         */\n        this._afterCameraPostProcessStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just after a render target has been drawn.\n         */\n        this._afterRenderTargetDrawStage = Stage.Create();\n        /**\n         * Defines the actions happening just after the post processing on a render target\n         */\n        this._afterRenderTargetPostProcessStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening just after rendering all cameras and computing intersections.\n         */\n        this._afterRenderStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening when a pointer move event happens.\n         */\n        this._pointerMoveStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening when a pointer down event happens.\n         */\n        this._pointerDownStage = Stage.Create();\n        /**\n         * @internal\n         * Defines the actions happening when a pointer up event happens.\n         */\n        this._pointerUpStage = Stage.Create();\n        /**\n         * an optional map from Geometry Id to Geometry index in the 'geometries' array\n         */\n        this._geometriesByUniqueId = null;\n        this._defaultMeshCandidates = {\n            data: [],\n            length: 0,\n        };\n        this._defaultSubMeshCandidates = {\n            data: [],\n            length: 0,\n        };\n        this._preventFreeActiveMeshesAndRenderingGroups = false;\n        /** @internal */\n        this._activeMeshesFrozen = false;\n        /** @internal */\n        this._activeMeshesFrozenButKeepClipping = false;\n        this._skipEvaluateActiveMeshesCompletely = false;\n        /** @internal */\n        this._allowPostProcessClearColor = true;\n        /**\n         * User updatable function that will return a deterministic frame time when engine is in deterministic lock step mode\n         * @returns the frame time\n         */\n        this.getDeterministicFrameTime = () => {\n            return this._engine.getTimeStep();\n        };\n        /** @internal */\n        this._registeredActions = 0;\n        this._blockMaterialDirtyMechanism = false;\n        /**\n         * Internal perfCollector instance used for sharing between inspector and playground.\n         * Marked as protected to allow sharing between prototype extensions, but disallow access at toplevel.\n         */\n        this._perfCollector = null;\n        this.activeCameras = [];\n        const fullOptions = {\n            useGeometryUniqueIdsMap: true,\n            useMaterialMeshMap: true,\n            useClonedMeshMap: true,\n            virtual: false,\n            ...options,\n        };\n        engine = this._engine = engine || EngineStore.LastCreatedEngine;\n        if (fullOptions.virtual) {\n            engine._virtualScenes.push(this);\n        }\n        else {\n            EngineStore._LastCreatedScene = this;\n            engine.scenes.push(this);\n        }\n        this._uid = null;\n        this._renderingManager = new RenderingManager(this);\n        if (PostProcessManager) {\n            this.postProcessManager = new PostProcessManager(this);\n        }\n        if (IsWindowObjectExist()) {\n            this.attachControl();\n        }\n        // Uniform Buffer\n        this._createUbo();\n        // Default Image processing definition\n        if (ImageProcessingConfiguration) {\n            this._imageProcessingConfiguration = new ImageProcessingConfiguration();\n        }\n        this.setDefaultCandidateProviders();\n        if (fullOptions.useGeometryUniqueIdsMap) {\n            this._geometriesByUniqueId = {};\n        }\n        this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;\n        this.useClonedMeshMap = fullOptions.useClonedMeshMap;\n        if (!options || !options.virtual) {\n            engine.onNewSceneAddedObservable.notifyObservers(this);\n        }\n    }\n    /**\n     * Gets a string identifying the name of the class\n     * @returns \"Scene\" string\n     */\n    getClassName() {\n        return \"Scene\";\n    }\n    /**\n     * @internal\n     */\n    _getDefaultMeshCandidates() {\n        this._defaultMeshCandidates.data = this.meshes;\n        this._defaultMeshCandidates.length = this.meshes.length;\n        return this._defaultMeshCandidates;\n    }\n    /**\n     * @internal\n     */\n    _getDefaultSubMeshCandidates(mesh) {\n        this._defaultSubMeshCandidates.data = mesh.subMeshes;\n        this._defaultSubMeshCandidates.length = mesh.subMeshes.length;\n        return this._defaultSubMeshCandidates;\n    }\n    /**\n     * Sets the default candidate providers for the scene.\n     * This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates\n     * and getCollidingSubMeshCandidates to their default function\n     */\n    setDefaultCandidateProviders() {\n        this.getActiveMeshCandidates = () => this._getDefaultMeshCandidates();\n        this.getActiveSubMeshCandidates = (mesh) => this._getDefaultSubMeshCandidates(mesh);\n        this.getIntersectingSubMeshCandidates = (mesh, localRay) => this._getDefaultSubMeshCandidates(mesh);\n        this.getCollidingSubMeshCandidates = (mesh, collider) => this._getDefaultSubMeshCandidates(mesh);\n    }\n    /**\n     * Gets the mesh that is currently under the pointer\n     */\n    get meshUnderPointer() {\n        return this._inputManager.meshUnderPointer;\n    }\n    /**\n     * Gets or sets the current on-screen X position of the pointer\n     */\n    get pointerX() {\n        return this._inputManager.pointerX;\n    }\n    set pointerX(value) {\n        this._inputManager.pointerX = value;\n    }\n    /**\n     * Gets or sets the current on-screen Y position of the pointer\n     */\n    get pointerY() {\n        return this._inputManager.pointerY;\n    }\n    set pointerY(value) {\n        this._inputManager.pointerY = value;\n    }\n    /**\n     * Gets the cached material (ie. the latest rendered one)\n     * @returns the cached material\n     */\n    getCachedMaterial() {\n        return this._cachedMaterial;\n    }\n    /**\n     * Gets the cached effect (ie. the latest rendered one)\n     * @returns the cached effect\n     */\n    getCachedEffect() {\n        return this._cachedEffect;\n    }\n    /**\n     * Gets the cached visibility state (ie. the latest rendered one)\n     * @returns the cached visibility state\n     */\n    getCachedVisibility() {\n        return this._cachedVisibility;\n    }\n    /**\n     * Gets a boolean indicating if the current material / effect / visibility must be bind again\n     * @param material defines the current material\n     * @param effect defines the current effect\n     * @param visibility defines the current visibility state\n     * @returns true if one parameter is not cached\n     */\n    isCachedMaterialInvalid(material, effect, visibility = 1) {\n        return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;\n    }\n    /**\n     * Gets the engine associated with the scene\n     * @returns an Engine\n     */\n    getEngine() {\n        return this._engine;\n    }\n    /**\n     * Gets the total number of vertices rendered per frame\n     * @returns the total number of vertices rendered per frame\n     */\n    getTotalVertices() {\n        return this._totalVertices.current;\n    }\n    /**\n     * Gets the performance counter for total vertices\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n     */\n    get totalVerticesPerfCounter() {\n        return this._totalVertices;\n    }\n    /**\n     * Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)\n     * @returns the total number of active indices rendered per frame\n     */\n    getActiveIndices() {\n        return this._activeIndices.current;\n    }\n    /**\n     * Gets the performance counter for active indices\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n     */\n    get totalActiveIndicesPerfCounter() {\n        return this._activeIndices;\n    }\n    /**\n     * Gets the total number of active particles rendered per frame\n     * @returns the total number of active particles rendered per frame\n     */\n    getActiveParticles() {\n        return this._activeParticles.current;\n    }\n    /**\n     * Gets the performance counter for active particles\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n     */\n    get activeParticlesPerfCounter() {\n        return this._activeParticles;\n    }\n    /**\n     * Gets the total number of active bones rendered per frame\n     * @returns the total number of active bones rendered per frame\n     */\n    getActiveBones() {\n        return this._activeBones.current;\n    }\n    /**\n     * Gets the performance counter for active bones\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation\n     */\n    get activeBonesPerfCounter() {\n        return this._activeBones;\n    }\n    /**\n     * Gets the array of active meshes\n     * @returns an array of AbstractMesh\n     */\n    getActiveMeshes() {\n        return this._activeMeshes;\n    }\n    /**\n     * Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)\n     * @returns a number\n     */\n    getAnimationRatio() {\n        return this._animationRatio !== undefined ? this._animationRatio : 1;\n    }\n    /**\n     * Gets an unique Id for the current render phase\n     * @returns a number\n     */\n    getRenderId() {\n        return this._renderId;\n    }\n    /**\n     * Gets an unique Id for the current frame\n     * @returns a number\n     */\n    getFrameId() {\n        return this._frameId;\n    }\n    /** Call this function if you want to manually increment the render Id*/\n    incrementRenderId() {\n        this._renderId++;\n    }\n    _createUbo() {\n        this.setSceneUniformBuffer(this.createSceneUniformBuffer());\n    }\n    /**\n     * Use this method to simulate a pointer move on a mesh\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n     * @returns the current scene\n     */\n    simulatePointerMove(pickResult, pointerEventInit) {\n        this._inputManager.simulatePointerMove(pickResult, pointerEventInit);\n        return this;\n    }\n    /**\n     * Use this method to simulate a pointer down on a mesh\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n     * @returns the current scene\n     */\n    simulatePointerDown(pickResult, pointerEventInit) {\n        this._inputManager.simulatePointerDown(pickResult, pointerEventInit);\n        return this;\n    }\n    /**\n     * Use this method to simulate a pointer up on a mesh\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n     * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)\n     * @returns the current scene\n     */\n    simulatePointerUp(pickResult, pointerEventInit, doubleTap) {\n        this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);\n        return this;\n    }\n    /**\n     * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\n     * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)\n     * @returns true if the pointer was captured\n     */\n    isPointerCaptured(pointerId = 0) {\n        return this._inputManager.isPointerCaptured(pointerId);\n    }\n    /**\n     * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\n     * @param attachUp defines if you want to attach events to pointerup\n     * @param attachDown defines if you want to attach events to pointerdown\n     * @param attachMove defines if you want to attach events to pointermove\n     */\n    attachControl(attachUp = true, attachDown = true, attachMove = true) {\n        this._inputManager.attachControl(attachUp, attachDown, attachMove);\n    }\n    /** Detaches all event handlers*/\n    detachControl() {\n        this._inputManager.detachControl();\n    }\n    /**\n     * This function will check if the scene can be rendered (textures are loaded, shaders are compiled)\n     * Delay loaded resources are not taking in account\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: true)\n     * @returns true if all required resources are ready\n     */\n    isReady(checkRenderTargets = true) {\n        if (this._isDisposed) {\n            return false;\n        }\n        let index;\n        const engine = this.getEngine();\n        const currentRenderPassId = engine.currentRenderPassId;\n        engine.currentRenderPassId = this.activeCamera?.renderPassId ?? currentRenderPassId;\n        let isReady = true;\n        // Pending data\n        if (this._pendingData.length > 0) {\n            isReady = false;\n        }\n        // Ensures that the pre-pass renderer is enabled if it is to be enabled.\n        this.prePassRenderer?.update();\n        // OIT\n        if (this.useOrderIndependentTransparency && this.depthPeelingRenderer) {\n            isReady && (isReady = this.depthPeelingRenderer.isReady());\n        }\n        // Meshes\n        if (checkRenderTargets) {\n            this._processedMaterials.reset();\n            this._materialsRenderTargets.reset();\n        }\n        for (index = 0; index < this.meshes.length; index++) {\n            const mesh = this.meshes[index];\n            if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n                continue;\n            }\n            // Do not stop at the first encountered \"unready\" object as we want to ensure\n            // all materials are starting off their compilation in parallel.\n            if (!mesh.isReady(true)) {\n                isReady = false;\n                continue;\n            }\n            const hardwareInstancedRendering = mesh.hasThinInstances ||\n                mesh.getClassName() === \"InstancedMesh\" ||\n                mesh.getClassName() === \"InstancedLinesMesh\" ||\n                (engine.getCaps().instancedArrays && mesh.instances.length > 0);\n            // Is Ready For Mesh\n            for (const step of this._isReadyForMeshStage) {\n                if (!step.action(mesh, hardwareInstancedRendering)) {\n                    isReady = false;\n                }\n            }\n            if (!checkRenderTargets) {\n                continue;\n            }\n            const mat = mesh.material || this.defaultMaterial;\n            if (mat) {\n                if (mat._storeEffectOnSubMeshes) {\n                    for (const subMesh of mesh.subMeshes) {\n                        const material = subMesh.getMaterial();\n                        if (material && material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n                            if (this._processedMaterials.indexOf(material) === -1) {\n                                this._processedMaterials.push(material);\n                                this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (mat.hasRenderTargetTextures && mat.getRenderTargetTextures != null) {\n                        if (this._processedMaterials.indexOf(mat) === -1) {\n                            this._processedMaterials.push(mat);\n                            this._materialsRenderTargets.concatWithNoDuplicate(mat.getRenderTargetTextures());\n                        }\n                    }\n                }\n            }\n        }\n        // Render targets\n        if (checkRenderTargets) {\n            for (index = 0; index < this._materialsRenderTargets.length; ++index) {\n                const rtt = this._materialsRenderTargets.data[index];\n                if (!rtt.isReadyForRendering()) {\n                    isReady = false;\n                }\n            }\n        }\n        // Geometries\n        for (index = 0; index < this.geometries.length; index++) {\n            const geometry = this.geometries[index];\n            if (geometry.delayLoadState === 2) {\n                isReady = false;\n            }\n        }\n        // Post-processes\n        if (this.activeCameras && this.activeCameras.length > 0) {\n            for (const camera of this.activeCameras) {\n                if (!camera.isReady(true)) {\n                    isReady = false;\n                }\n            }\n        }\n        else if (this.activeCamera) {\n            if (!this.activeCamera.isReady(true)) {\n                isReady = false;\n            }\n        }\n        // Particles\n        for (const particleSystem of this.particleSystems) {\n            if (!particleSystem.isReady()) {\n                isReady = false;\n            }\n        }\n        // Layers\n        if (this.layers) {\n            for (const layer of this.layers) {\n                if (!layer.isReady()) {\n                    isReady = false;\n                }\n            }\n        }\n        // Effects\n        if (!engine.areAllEffectsReady()) {\n            isReady = false;\n        }\n        engine.currentRenderPassId = currentRenderPassId;\n        return isReady;\n    }\n    /** Resets all cached information relative to material (including effect and visibility) */\n    resetCachedMaterial() {\n        this._cachedMaterial = null;\n        this._cachedEffect = null;\n        this._cachedVisibility = null;\n    }\n    /**\n     * Registers a function to be called before every frame render\n     * @param func defines the function to register\n     */\n    registerBeforeRender(func) {\n        this.onBeforeRenderObservable.add(func);\n    }\n    /**\n     * Unregisters a function called before every frame render\n     * @param func defines the function to unregister\n     */\n    unregisterBeforeRender(func) {\n        this.onBeforeRenderObservable.removeCallback(func);\n    }\n    /**\n     * Registers a function to be called after every frame render\n     * @param func defines the function to register\n     */\n    registerAfterRender(func) {\n        this.onAfterRenderObservable.add(func);\n    }\n    /**\n     * Unregisters a function called after every frame render\n     * @param func defines the function to unregister\n     */\n    unregisterAfterRender(func) {\n        this.onAfterRenderObservable.removeCallback(func);\n    }\n    _executeOnceBeforeRender(func) {\n        const execFunc = () => {\n            func();\n            setTimeout(() => {\n                this.unregisterBeforeRender(execFunc);\n            });\n        };\n        this.registerBeforeRender(execFunc);\n    }\n    /**\n     * The provided function will run before render once and will be disposed afterwards.\n     * A timeout delay can be provided so that the function will be executed in N ms.\n     * The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.\n     * @param func The function to be executed.\n     * @param timeout optional delay in ms\n     */\n    executeOnceBeforeRender(func, timeout) {\n        if (timeout !== undefined) {\n            setTimeout(() => {\n                this._executeOnceBeforeRender(func);\n            }, timeout);\n        }\n        else {\n            this._executeOnceBeforeRender(func);\n        }\n    }\n    /**\n     * This function can help adding any object to the list of data awaited to be ready in order to check for a complete scene loading.\n     * @param data defines the object to wait for\n     */\n    addPendingData(data) {\n        this._pendingData.push(data);\n    }\n    /**\n     * Remove a pending data from the loading list which has previously been added with addPendingData.\n     * @param data defines the object to remove from the pending list\n     */\n    removePendingData(data) {\n        const wasLoading = this.isLoading;\n        const index = this._pendingData.indexOf(data);\n        if (index !== -1) {\n            this._pendingData.splice(index, 1);\n        }\n        if (wasLoading && !this.isLoading) {\n            this.onDataLoadedObservable.notifyObservers(this);\n        }\n    }\n    /**\n     * Returns the number of items waiting to be loaded\n     * @returns the number of items waiting to be loaded\n     */\n    getWaitingItemsCount() {\n        return this._pendingData.length;\n    }\n    /**\n     * Returns a boolean indicating if the scene is still loading data\n     */\n    get isLoading() {\n        return this._pendingData.length > 0;\n    }\n    /**\n     * Registers a function to be executed when the scene is ready\n     * @param func - the function to be executed\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\n     */\n    executeWhenReady(func, checkRenderTargets = false) {\n        this.onReadyObservable.addOnce(func);\n        if (this._executeWhenReadyTimeoutId !== null) {\n            return;\n        }\n        this._checkIsReady(checkRenderTargets);\n    }\n    /**\n     * Returns a promise that resolves when the scene is ready\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\n     * @returns A promise that resolves when the scene is ready\n     */\n    whenReadyAsync(checkRenderTargets = false) {\n        return new Promise((resolve) => {\n            this.executeWhenReady(() => {\n                resolve();\n            }, checkRenderTargets);\n        });\n    }\n    /**\n     * @internal\n     */\n    _checkIsReady(checkRenderTargets = false) {\n        this._registerTransientComponents();\n        if (this.isReady(checkRenderTargets)) {\n            this.onReadyObservable.notifyObservers(this);\n            this.onReadyObservable.clear();\n            this._executeWhenReadyTimeoutId = null;\n            return;\n        }\n        if (this._isDisposed) {\n            this.onReadyObservable.clear();\n            this._executeWhenReadyTimeoutId = null;\n            return;\n        }\n        this._executeWhenReadyTimeoutId = setTimeout(() => {\n            // Ensure materials effects are checked outside render loops\n            this.incrementRenderId();\n            this._checkIsReady(checkRenderTargets);\n        }, 100);\n    }\n    /**\n     * Gets all animatable attached to the scene\n     */\n    get animatables() {\n        return this._activeAnimatables;\n    }\n    /**\n     * Resets the last animation time frame.\n     * Useful to override when animations start running when loading a scene for the first time.\n     */\n    resetLastAnimationTimeFrame() {\n        this._animationTimeLast = PrecisionDate.Now;\n    }\n    // Matrix\n    /**\n     * Gets the current view matrix\n     * @returns a Matrix\n     */\n    getViewMatrix() {\n        return this._viewMatrix;\n    }\n    /**\n     * Gets the current projection matrix\n     * @returns a Matrix\n     */\n    getProjectionMatrix() {\n        return this._projectionMatrix;\n    }\n    /**\n     * Gets the current transform matrix\n     * @returns a Matrix made of View * Projection\n     */\n    getTransformMatrix() {\n        return this._transformMatrix;\n    }\n    /**\n     * Sets the current transform matrix\n     * @param viewL defines the View matrix to use\n     * @param projectionL defines the Projection matrix to use\n     * @param viewR defines the right View matrix to use (if provided)\n     * @param projectionR defines the right Projection matrix to use (if provided)\n     */\n    setTransformMatrix(viewL, projectionL, viewR, projectionR) {\n        // clear the multiviewSceneUbo if no viewR and projectionR are defined\n        if (!viewR && !projectionR && this._multiviewSceneUbo) {\n            this._multiviewSceneUbo.dispose();\n            this._multiviewSceneUbo = null;\n        }\n        if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {\n            return;\n        }\n        this._viewUpdateFlag = viewL.updateFlag;\n        this._projectionUpdateFlag = projectionL.updateFlag;\n        this._viewMatrix = viewL;\n        this._projectionMatrix = projectionL;\n        this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\n        // Update frustum\n        if (!this._frustumPlanes) {\n            this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);\n        }\n        else {\n            Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\n        }\n        if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {\n            this._updateMultiviewUbo(viewR, projectionR);\n        }\n        else if (this._sceneUbo.useUbo) {\n            this._sceneUbo.updateMatrix(\"viewProjection\", this._transformMatrix);\n            this._sceneUbo.updateMatrix(\"view\", this._viewMatrix);\n            this._sceneUbo.updateMatrix(\"projection\", this._projectionMatrix);\n        }\n    }\n    /**\n     * Gets the uniform buffer used to store scene data\n     * @returns a UniformBuffer\n     */\n    getSceneUniformBuffer() {\n        return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;\n    }\n    /**\n     * Creates a scene UBO\n     * @param name name of the uniform buffer (optional, for debugging purpose only)\n     * @returns a new ubo\n     */\n    createSceneUniformBuffer(name) {\n        const sceneUbo = new UniformBuffer(this._engine, undefined, false, name ?? \"scene\");\n        sceneUbo.addUniform(\"viewProjection\", 16);\n        sceneUbo.addUniform(\"view\", 16);\n        sceneUbo.addUniform(\"projection\", 16);\n        sceneUbo.addUniform(\"vEyePosition\", 4);\n        return sceneUbo;\n    }\n    /**\n     * Sets the scene ubo\n     * @param ubo the ubo to set for the scene\n     */\n    setSceneUniformBuffer(ubo) {\n        this._sceneUbo = ubo;\n        this._viewUpdateFlag = -1;\n        this._projectionUpdateFlag = -1;\n    }\n    /**\n     * Gets an unique (relatively to the current scene) Id\n     * @returns an unique number for the scene\n     */\n    getUniqueId() {\n        return UniqueIdGenerator.UniqueId;\n    }\n    /**\n     * Add a mesh to the list of scene's meshes\n     * @param newMesh defines the mesh to add\n     * @param recursive if all child meshes should also be added to the scene\n     */\n    addMesh(newMesh, recursive = false) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.meshes.push(newMesh);\n        newMesh._resyncLightSources();\n        if (!newMesh.parent) {\n            newMesh._addToSceneRootNodes();\n        }\n        Tools.SetImmediate(() => {\n            this.onNewMeshAddedObservable.notifyObservers(newMesh);\n        });\n        if (recursive) {\n            newMesh.getChildMeshes().forEach((m) => {\n                this.addMesh(m);\n            });\n        }\n    }\n    /**\n     * Remove a mesh for the list of scene's meshes\n     * @param toRemove defines the mesh to remove\n     * @param recursive if all child meshes should also be removed from the scene\n     * @returns the index where the mesh was in the mesh list\n     */\n    removeMesh(toRemove, recursive = false) {\n        const index = this.meshes.indexOf(toRemove);\n        if (index !== -1) {\n            // Remove from the scene if the mesh found\n            this.meshes.splice(index, 1);\n            if (!toRemove.parent) {\n                toRemove._removeFromSceneRootNodes();\n            }\n        }\n        this._inputManager._invalidateMesh(toRemove);\n        this.onMeshRemovedObservable.notifyObservers(toRemove);\n        if (recursive) {\n            toRemove.getChildMeshes().forEach((m) => {\n                this.removeMesh(m);\n            });\n        }\n        return index;\n    }\n    /**\n     * Add a transform node to the list of scene's transform nodes\n     * @param newTransformNode defines the transform node to add\n     */\n    addTransformNode(newTransformNode) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        if (newTransformNode.getScene() === this && newTransformNode._indexInSceneTransformNodesArray !== -1) {\n            // Already there?\n            return;\n        }\n        newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;\n        this.transformNodes.push(newTransformNode);\n        if (!newTransformNode.parent) {\n            newTransformNode._addToSceneRootNodes();\n        }\n        this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);\n    }\n    /**\n     * Remove a transform node for the list of scene's transform nodes\n     * @param toRemove defines the transform node to remove\n     * @returns the index where the transform node was in the transform node list\n     */\n    removeTransformNode(toRemove) {\n        const index = toRemove._indexInSceneTransformNodesArray;\n        if (index !== -1) {\n            if (index !== this.transformNodes.length - 1) {\n                const lastNode = this.transformNodes[this.transformNodes.length - 1];\n                this.transformNodes[index] = lastNode;\n                lastNode._indexInSceneTransformNodesArray = index;\n            }\n            toRemove._indexInSceneTransformNodesArray = -1;\n            this.transformNodes.pop();\n            if (!toRemove.parent) {\n                toRemove._removeFromSceneRootNodes();\n            }\n        }\n        this.onTransformNodeRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Remove a skeleton for the list of scene's skeletons\n     * @param toRemove defines the skeleton to remove\n     * @returns the index where the skeleton was in the skeleton list\n     */\n    removeSkeleton(toRemove) {\n        const index = this.skeletons.indexOf(toRemove);\n        if (index !== -1) {\n            // Remove from the scene if found\n            this.skeletons.splice(index, 1);\n            this.onSkeletonRemovedObservable.notifyObservers(toRemove);\n            // Clean active container\n            this._executeActiveContainerCleanup(this._activeSkeletons);\n        }\n        return index;\n    }\n    /**\n     * Remove a morph target for the list of scene's morph targets\n     * @param toRemove defines the morph target to remove\n     * @returns the index where the morph target was in the morph target list\n     */\n    removeMorphTargetManager(toRemove) {\n        const index = this.morphTargetManagers.indexOf(toRemove);\n        if (index !== -1) {\n            // Remove from the scene if found\n            this.morphTargetManagers.splice(index, 1);\n        }\n        return index;\n    }\n    /**\n     * Remove a light for the list of scene's lights\n     * @param toRemove defines the light to remove\n     * @returns the index where the light was in the light list\n     */\n    removeLight(toRemove) {\n        const index = this.lights.indexOf(toRemove);\n        if (index !== -1) {\n            // Remove from meshes\n            for (const mesh of this.meshes) {\n                mesh._removeLightSource(toRemove, false);\n            }\n            // Remove from the scene if mesh found\n            this.lights.splice(index, 1);\n            this.sortLightsByPriority();\n            if (!toRemove.parent) {\n                toRemove._removeFromSceneRootNodes();\n            }\n        }\n        this.onLightRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Remove a camera for the list of scene's cameras\n     * @param toRemove defines the camera to remove\n     * @returns the index where the camera was in the camera list\n     */\n    removeCamera(toRemove) {\n        const index = this.cameras.indexOf(toRemove);\n        if (index !== -1) {\n            // Remove from the scene if mesh found\n            this.cameras.splice(index, 1);\n            if (!toRemove.parent) {\n                toRemove._removeFromSceneRootNodes();\n            }\n        }\n        // Remove from activeCameras\n        if (this.activeCameras) {\n            const index2 = this.activeCameras.indexOf(toRemove);\n            if (index2 !== -1) {\n                // Remove from the scene if mesh found\n                this.activeCameras.splice(index2, 1);\n            }\n        }\n        // Reset the activeCamera\n        if (this.activeCamera === toRemove) {\n            if (this.cameras.length > 0) {\n                this.activeCamera = this.cameras[0];\n            }\n            else {\n                this.activeCamera = null;\n            }\n        }\n        this.onCameraRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Remove a particle system for the list of scene's particle systems\n     * @param toRemove defines the particle system to remove\n     * @returns the index where the particle system was in the particle system list\n     */\n    removeParticleSystem(toRemove) {\n        const index = this.particleSystems.indexOf(toRemove);\n        if (index !== -1) {\n            this.particleSystems.splice(index, 1);\n            // Clean active container\n            this._executeActiveContainerCleanup(this._activeParticleSystems);\n        }\n        return index;\n    }\n    /**\n     * Remove a animation for the list of scene's animations\n     * @param toRemove defines the animation to remove\n     * @returns the index where the animation was in the animation list\n     */\n    removeAnimation(toRemove) {\n        const index = this.animations.indexOf(toRemove);\n        if (index !== -1) {\n            this.animations.splice(index, 1);\n        }\n        return index;\n    }\n    /**\n     * Will stop the animation of the given target\n     * @param target - the target\n     * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\n     * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n     */\n    stopAnimation(target, animationName, targetMask) {\n        // Do nothing as code will be provided by animation component\n    }\n    /**\n     * Removes the given animation group from this scene.\n     * @param toRemove The animation group to remove\n     * @returns The index of the removed animation group\n     */\n    removeAnimationGroup(toRemove) {\n        const index = this.animationGroups.indexOf(toRemove);\n        if (index !== -1) {\n            this.animationGroups.splice(index, 1);\n        }\n        return index;\n    }\n    /**\n     * Removes the given multi-material from this scene.\n     * @param toRemove The multi-material to remove\n     * @returns The index of the removed multi-material\n     */\n    removeMultiMaterial(toRemove) {\n        const index = this.multiMaterials.indexOf(toRemove);\n        if (index !== -1) {\n            this.multiMaterials.splice(index, 1);\n        }\n        this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Removes the given material from this scene.\n     * @param toRemove The material to remove\n     * @returns The index of the removed material\n     */\n    removeMaterial(toRemove) {\n        const index = toRemove._indexInSceneMaterialArray;\n        if (index !== -1 && index < this.materials.length) {\n            if (index !== this.materials.length - 1) {\n                const lastMaterial = this.materials[this.materials.length - 1];\n                this.materials[index] = lastMaterial;\n                lastMaterial._indexInSceneMaterialArray = index;\n            }\n            toRemove._indexInSceneMaterialArray = -1;\n            this.materials.pop();\n        }\n        this.onMaterialRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Removes the given action manager from this scene.\n     * @deprecated\n     * @param toRemove The action manager to remove\n     * @returns The index of the removed action manager\n     */\n    removeActionManager(toRemove) {\n        const index = this.actionManagers.indexOf(toRemove);\n        if (index !== -1) {\n            this.actionManagers.splice(index, 1);\n        }\n        return index;\n    }\n    /**\n     * Removes the given texture from this scene.\n     * @param toRemove The texture to remove\n     * @returns The index of the removed texture\n     */\n    removeTexture(toRemove) {\n        const index = this.textures.indexOf(toRemove);\n        if (index !== -1) {\n            this.textures.splice(index, 1);\n        }\n        this.onTextureRemovedObservable.notifyObservers(toRemove);\n        return index;\n    }\n    /**\n     * Adds the given light to this scene\n     * @param newLight The light to add\n     */\n    addLight(newLight) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.lights.push(newLight);\n        this.sortLightsByPriority();\n        if (!newLight.parent) {\n            newLight._addToSceneRootNodes();\n        }\n        // Add light to all meshes (To support if the light is removed and then re-added)\n        for (const mesh of this.meshes) {\n            if (mesh.lightSources.indexOf(newLight) === -1) {\n                mesh.lightSources.push(newLight);\n                mesh._resyncLightSources();\n            }\n        }\n        Tools.SetImmediate(() => {\n            this.onNewLightAddedObservable.notifyObservers(newLight);\n        });\n    }\n    /**\n     * Sorts the list list based on light priorities\n     */\n    sortLightsByPriority() {\n        if (this.requireLightSorting) {\n            this.lights.sort(LightConstants.CompareLightsPriority);\n        }\n    }\n    /**\n     * Adds the given camera to this scene\n     * @param newCamera The camera to add\n     */\n    addCamera(newCamera) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.cameras.push(newCamera);\n        Tools.SetImmediate(() => {\n            this.onNewCameraAddedObservable.notifyObservers(newCamera);\n        });\n        if (!newCamera.parent) {\n            newCamera._addToSceneRootNodes();\n        }\n    }\n    /**\n     * Adds the given skeleton to this scene\n     * @param newSkeleton The skeleton to add\n     */\n    addSkeleton(newSkeleton) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.skeletons.push(newSkeleton);\n        Tools.SetImmediate(() => {\n            this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);\n        });\n    }\n    /**\n     * Adds the given particle system to this scene\n     * @param newParticleSystem The particle system to add\n     */\n    addParticleSystem(newParticleSystem) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.particleSystems.push(newParticleSystem);\n    }\n    /**\n     * Adds the given animation to this scene\n     * @param newAnimation The animation to add\n     */\n    addAnimation(newAnimation) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.animations.push(newAnimation);\n    }\n    /**\n     * Adds the given animation group to this scene.\n     * @param newAnimationGroup The animation group to add\n     */\n    addAnimationGroup(newAnimationGroup) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.animationGroups.push(newAnimationGroup);\n    }\n    /**\n     * Adds the given multi-material to this scene\n     * @param newMultiMaterial The multi-material to add\n     */\n    addMultiMaterial(newMultiMaterial) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.multiMaterials.push(newMultiMaterial);\n        Tools.SetImmediate(() => {\n            this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);\n        });\n    }\n    /**\n     * Adds the given material to this scene\n     * @param newMaterial The material to add\n     */\n    addMaterial(newMaterial) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        if (newMaterial.getScene() === this && newMaterial._indexInSceneMaterialArray !== -1) {\n            // Already there??\n            return;\n        }\n        newMaterial._indexInSceneMaterialArray = this.materials.length;\n        this.materials.push(newMaterial);\n        Tools.SetImmediate(() => {\n            this.onNewMaterialAddedObservable.notifyObservers(newMaterial);\n        });\n    }\n    /**\n     * Adds the given morph target to this scene\n     * @param newMorphTargetManager The morph target to add\n     */\n    addMorphTargetManager(newMorphTargetManager) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.morphTargetManagers.push(newMorphTargetManager);\n    }\n    /**\n     * Adds the given geometry to this scene\n     * @param newGeometry The geometry to add\n     */\n    addGeometry(newGeometry) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        if (this._geometriesByUniqueId) {\n            this._geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;\n        }\n        this.geometries.push(newGeometry);\n    }\n    /**\n     * Adds the given action manager to this scene\n     * @deprecated\n     * @param newActionManager The action manager to add\n     */\n    addActionManager(newActionManager) {\n        this.actionManagers.push(newActionManager);\n    }\n    /**\n     * Adds the given texture to this scene.\n     * @param newTexture The texture to add\n     */\n    addTexture(newTexture) {\n        if (this._blockEntityCollection) {\n            return;\n        }\n        this.textures.push(newTexture);\n        this.onNewTextureAddedObservable.notifyObservers(newTexture);\n    }\n    /**\n     * Switch active camera\n     * @param newCamera defines the new active camera\n     * @param attachControl defines if attachControl must be called for the new active camera (default: true)\n     */\n    switchActiveCamera(newCamera, attachControl = true) {\n        const canvas = this._engine.getInputElement();\n        if (!canvas) {\n            return;\n        }\n        if (this.activeCamera) {\n            this.activeCamera.detachControl();\n        }\n        this.activeCamera = newCamera;\n        if (attachControl) {\n            newCamera.attachControl();\n        }\n    }\n    /**\n     * sets the active camera of the scene using its Id\n     * @param id defines the camera's Id\n     * @returns the new active camera or null if none found.\n     */\n    setActiveCameraById(id) {\n        const camera = this.getCameraById(id);\n        if (camera) {\n            this.activeCamera = camera;\n            return camera;\n        }\n        return null;\n    }\n    /**\n     * sets the active camera of the scene using its name\n     * @param name defines the camera's name\n     * @returns the new active camera or null if none found.\n     */\n    setActiveCameraByName(name) {\n        const camera = this.getCameraByName(name);\n        if (camera) {\n            this.activeCamera = camera;\n            return camera;\n        }\n        return null;\n    }\n    /**\n     * get an animation group using its name\n     * @param name defines the material's name\n     * @returns the animation group or null if none found.\n     */\n    getAnimationGroupByName(name) {\n        for (let index = 0; index < this.animationGroups.length; index++) {\n            if (this.animationGroups[index].name === name) {\n                return this.animationGroups[index];\n            }\n        }\n        return null;\n    }\n    _getMaterial(allowMultiMaterials, predicate) {\n        for (let index = 0; index < this.materials.length; index++) {\n            const material = this.materials[index];\n            if (predicate(material)) {\n                return material;\n            }\n        }\n        if (allowMultiMaterials) {\n            for (let index = 0; index < this.multiMaterials.length; index++) {\n                const material = this.multiMaterials[index];\n                if (predicate(material)) {\n                    return material;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Get a material using its unique id\n     * @param uniqueId defines the material's unique id\n     * @param allowMultiMaterials determines whether multimaterials should be considered\n     * @returns the material or null if none found.\n     */\n    getMaterialByUniqueID(uniqueId, allowMultiMaterials = false) {\n        return this._getMaterial(allowMultiMaterials, (m) => m.uniqueId === uniqueId);\n    }\n    /**\n     * get a material using its id\n     * @param id defines the material's Id\n     * @param allowMultiMaterials determines whether multimaterials should be considered\n     * @returns the material or null if none found.\n     */\n    getMaterialById(id, allowMultiMaterials = false) {\n        return this._getMaterial(allowMultiMaterials, (m) => m.id === id);\n    }\n    /**\n     * Gets a material using its name\n     * @param name defines the material's name\n     * @param allowMultiMaterials determines whether multimaterials should be considered\n     * @returns the material or null if none found.\n     */\n    getMaterialByName(name, allowMultiMaterials = false) {\n        return this._getMaterial(allowMultiMaterials, (m) => m.name === name);\n    }\n    /**\n     * Gets a last added material using a given id\n     * @param id defines the material's id\n     * @param allowMultiMaterials determines whether multimaterials should be considered\n     * @returns the last material with the given id or null if none found.\n     */\n    getLastMaterialById(id, allowMultiMaterials = false) {\n        for (let index = this.materials.length - 1; index >= 0; index--) {\n            if (this.materials[index].id === id) {\n                return this.materials[index];\n            }\n        }\n        if (allowMultiMaterials) {\n            for (let index = this.multiMaterials.length - 1; index >= 0; index--) {\n                if (this.multiMaterials[index].id === id) {\n                    return this.multiMaterials[index];\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Get a texture using its unique id\n     * @param uniqueId defines the texture's unique id\n     * @returns the texture or null if none found.\n     */\n    getTextureByUniqueId(uniqueId) {\n        for (let index = 0; index < this.textures.length; index++) {\n            if (this.textures[index].uniqueId === uniqueId) {\n                return this.textures[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a texture using its name\n     * @param name defines the texture's name\n     * @returns the texture or null if none found.\n     */\n    getTextureByName(name) {\n        for (let index = 0; index < this.textures.length; index++) {\n            if (this.textures[index].name === name) {\n                return this.textures[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a camera using its Id\n     * @param id defines the Id to look for\n     * @returns the camera or null if not found\n     */\n    getCameraById(id) {\n        for (let index = 0; index < this.cameras.length; index++) {\n            if (this.cameras[index].id === id) {\n                return this.cameras[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a camera using its unique Id\n     * @param uniqueId defines the unique Id to look for\n     * @returns the camera or null if not found\n     */\n    getCameraByUniqueId(uniqueId) {\n        for (let index = 0; index < this.cameras.length; index++) {\n            if (this.cameras[index].uniqueId === uniqueId) {\n                return this.cameras[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a camera using its name\n     * @param name defines the camera's name\n     * @returns the camera or null if none found.\n     */\n    getCameraByName(name) {\n        for (let index = 0; index < this.cameras.length; index++) {\n            if (this.cameras[index].name === name) {\n                return this.cameras[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a bone using its Id\n     * @param id defines the bone's Id\n     * @returns the bone or null if not found\n     */\n    getBoneById(id) {\n        for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n            const skeleton = this.skeletons[skeletonIndex];\n            for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n                if (skeleton.bones[boneIndex].id === id) {\n                    return skeleton.bones[boneIndex];\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a bone using its id\n     * @param name defines the bone's name\n     * @returns the bone or null if not found\n     */\n    getBoneByName(name) {\n        for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n            const skeleton = this.skeletons[skeletonIndex];\n            for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n                if (skeleton.bones[boneIndex].name === name) {\n                    return skeleton.bones[boneIndex];\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a light node using its name\n     * @param name defines the light's name\n     * @returns the light or null if none found.\n     */\n    getLightByName(name) {\n        for (let index = 0; index < this.lights.length; index++) {\n            if (this.lights[index].name === name) {\n                return this.lights[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a light node using its Id\n     * @param id defines the light's Id\n     * @returns the light or null if none found.\n     */\n    getLightById(id) {\n        for (let index = 0; index < this.lights.length; index++) {\n            if (this.lights[index].id === id) {\n                return this.lights[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a light node using its scene-generated unique Id\n     * @param uniqueId defines the light's unique Id\n     * @returns the light or null if none found.\n     */\n    getLightByUniqueId(uniqueId) {\n        for (let index = 0; index < this.lights.length; index++) {\n            if (this.lights[index].uniqueId === uniqueId) {\n                return this.lights[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a particle system by Id\n     * @param id defines the particle system Id\n     * @returns the corresponding system or null if none found\n     */\n    getParticleSystemById(id) {\n        for (let index = 0; index < this.particleSystems.length; index++) {\n            if (this.particleSystems[index].id === id) {\n                return this.particleSystems[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a geometry using its Id\n     * @param id defines the geometry's Id\n     * @returns the geometry or null if none found.\n     */\n    getGeometryById(id) {\n        for (let index = 0; index < this.geometries.length; index++) {\n            if (this.geometries[index].id === id) {\n                return this.geometries[index];\n            }\n        }\n        return null;\n    }\n    _getGeometryByUniqueId(uniqueId) {\n        if (this._geometriesByUniqueId) {\n            const index = this._geometriesByUniqueId[uniqueId];\n            if (index !== undefined) {\n                return this.geometries[index];\n            }\n        }\n        else {\n            for (let index = 0; index < this.geometries.length; index++) {\n                if (this.geometries[index].uniqueId === uniqueId) {\n                    return this.geometries[index];\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Add a new geometry to this scene\n     * @param geometry defines the geometry to be added to the scene.\n     * @param force defines if the geometry must be pushed even if a geometry with this id already exists\n     * @returns a boolean defining if the geometry was added or not\n     */\n    pushGeometry(geometry, force) {\n        if (!force && this._getGeometryByUniqueId(geometry.uniqueId)) {\n            return false;\n        }\n        this.addGeometry(geometry);\n        Tools.SetImmediate(() => {\n            this.onNewGeometryAddedObservable.notifyObservers(geometry);\n        });\n        return true;\n    }\n    /**\n     * Removes an existing geometry\n     * @param geometry defines the geometry to be removed from the scene\n     * @returns a boolean defining if the geometry was removed or not\n     */\n    removeGeometry(geometry) {\n        let index;\n        if (this._geometriesByUniqueId) {\n            index = this._geometriesByUniqueId[geometry.uniqueId];\n            if (index === undefined) {\n                return false;\n            }\n        }\n        else {\n            index = this.geometries.indexOf(geometry);\n            if (index < 0) {\n                return false;\n            }\n        }\n        if (index !== this.geometries.length - 1) {\n            const lastGeometry = this.geometries[this.geometries.length - 1];\n            if (lastGeometry) {\n                this.geometries[index] = lastGeometry;\n                if (this._geometriesByUniqueId) {\n                    this._geometriesByUniqueId[lastGeometry.uniqueId] = index;\n                }\n            }\n        }\n        if (this._geometriesByUniqueId) {\n            this._geometriesByUniqueId[geometry.uniqueId] = undefined;\n        }\n        this.geometries.pop();\n        this.onGeometryRemovedObservable.notifyObservers(geometry);\n        return true;\n    }\n    /**\n     * Gets the list of geometries attached to the scene\n     * @returns an array of Geometry\n     */\n    getGeometries() {\n        return this.geometries;\n    }\n    /**\n     * Gets the first added mesh found of a given Id\n     * @param id defines the Id to search for\n     * @returns the mesh found or null if not found at all\n     */\n    getMeshById(id) {\n        for (let index = 0; index < this.meshes.length; index++) {\n            if (this.meshes[index].id === id) {\n                return this.meshes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a list of meshes using their Id\n     * @param id defines the Id to search for\n     * @returns a list of meshes\n     */\n    getMeshesById(id) {\n        return this.meshes.filter(function (m) {\n            return m.id === id;\n        });\n    }\n    /**\n     * Gets the first added transform node found of a given Id\n     * @param id defines the Id to search for\n     * @returns the found transform node or null if not found at all.\n     */\n    getTransformNodeById(id) {\n        for (let index = 0; index < this.transformNodes.length; index++) {\n            if (this.transformNodes[index].id === id) {\n                return this.transformNodes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a transform node with its auto-generated unique Id\n     * @param uniqueId defines the unique Id to search for\n     * @returns the found transform node or null if not found at all.\n     */\n    getTransformNodeByUniqueId(uniqueId) {\n        for (let index = 0; index < this.transformNodes.length; index++) {\n            if (this.transformNodes[index].uniqueId === uniqueId) {\n                return this.transformNodes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a list of transform nodes using their Id\n     * @param id defines the Id to search for\n     * @returns a list of transform nodes\n     */\n    getTransformNodesById(id) {\n        return this.transformNodes.filter(function (m) {\n            return m.id === id;\n        });\n    }\n    /**\n     * Gets a mesh with its auto-generated unique Id\n     * @param uniqueId defines the unique Id to search for\n     * @returns the found mesh or null if not found at all.\n     */\n    getMeshByUniqueId(uniqueId) {\n        for (let index = 0; index < this.meshes.length; index++) {\n            if (this.meshes[index].uniqueId === uniqueId) {\n                return this.meshes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a the last added mesh using a given Id\n     * @param id defines the Id to search for\n     * @returns the found mesh or null if not found at all.\n     */\n    getLastMeshById(id) {\n        for (let index = this.meshes.length - 1; index >= 0; index--) {\n            if (this.meshes[index].id === id) {\n                return this.meshes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a the last transform node using a given Id\n     * @param id defines the Id to search for\n     * @returns the found mesh or null if not found at all.\n     */\n    getLastTransformNodeById(id) {\n        for (let index = this.transformNodes.length - 1; index >= 0; index--) {\n            if (this.transformNodes[index].id === id) {\n                return this.transformNodes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a the last added node (Mesh, Camera, Light) using a given Id\n     * @param id defines the Id to search for\n     * @returns the found node or null if not found at all\n     */\n    getLastEntryById(id) {\n        let index;\n        for (index = this.meshes.length - 1; index >= 0; index--) {\n            if (this.meshes[index].id === id) {\n                return this.meshes[index];\n            }\n        }\n        for (index = this.transformNodes.length - 1; index >= 0; index--) {\n            if (this.transformNodes[index].id === id) {\n                return this.transformNodes[index];\n            }\n        }\n        for (index = this.cameras.length - 1; index >= 0; index--) {\n            if (this.cameras[index].id === id) {\n                return this.cameras[index];\n            }\n        }\n        for (index = this.lights.length - 1; index >= 0; index--) {\n            if (this.lights[index].id === id) {\n                return this.lights[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a node (Mesh, Camera, Light) using a given Id\n     * @param id defines the Id to search for\n     * @returns the found node or null if not found at all\n     */\n    getNodeById(id) {\n        const mesh = this.getMeshById(id);\n        if (mesh) {\n            return mesh;\n        }\n        const transformNode = this.getTransformNodeById(id);\n        if (transformNode) {\n            return transformNode;\n        }\n        const light = this.getLightById(id);\n        if (light) {\n            return light;\n        }\n        const camera = this.getCameraById(id);\n        if (camera) {\n            return camera;\n        }\n        const bone = this.getBoneById(id);\n        if (bone) {\n            return bone;\n        }\n        return null;\n    }\n    /**\n     * Gets a node (Mesh, Camera, Light) using a given name\n     * @param name defines the name to search for\n     * @returns the found node or null if not found at all.\n     */\n    getNodeByName(name) {\n        const mesh = this.getMeshByName(name);\n        if (mesh) {\n            return mesh;\n        }\n        const transformNode = this.getTransformNodeByName(name);\n        if (transformNode) {\n            return transformNode;\n        }\n        const light = this.getLightByName(name);\n        if (light) {\n            return light;\n        }\n        const camera = this.getCameraByName(name);\n        if (camera) {\n            return camera;\n        }\n        const bone = this.getBoneByName(name);\n        if (bone) {\n            return bone;\n        }\n        return null;\n    }\n    /**\n     * Gets a mesh using a given name\n     * @param name defines the name to search for\n     * @returns the found mesh or null if not found at all.\n     */\n    getMeshByName(name) {\n        for (let index = 0; index < this.meshes.length; index++) {\n            if (this.meshes[index].name === name) {\n                return this.meshes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a transform node using a given name\n     * @param name defines the name to search for\n     * @returns the found transform node or null if not found at all.\n     */\n    getTransformNodeByName(name) {\n        for (let index = 0; index < this.transformNodes.length; index++) {\n            if (this.transformNodes[index].name === name) {\n                return this.transformNodes[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a skeleton using a given Id (if many are found, this function will pick the last one)\n     * @param id defines the Id to search for\n     * @returns the found skeleton or null if not found at all.\n     */\n    getLastSkeletonById(id) {\n        for (let index = this.skeletons.length - 1; index >= 0; index--) {\n            if (this.skeletons[index].id === id) {\n                return this.skeletons[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a skeleton using a given auto generated unique id\n     * @param  uniqueId defines the unique id to search for\n     * @returns the found skeleton or null if not found at all.\n     */\n    getSkeletonByUniqueId(uniqueId) {\n        for (let index = 0; index < this.skeletons.length; index++) {\n            if (this.skeletons[index].uniqueId === uniqueId) {\n                return this.skeletons[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a skeleton using a given id (if many are found, this function will pick the first one)\n     * @param id defines the id to search for\n     * @returns the found skeleton or null if not found at all.\n     */\n    getSkeletonById(id) {\n        for (let index = 0; index < this.skeletons.length; index++) {\n            if (this.skeletons[index].id === id) {\n                return this.skeletons[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a skeleton using a given name\n     * @param name defines the name to search for\n     * @returns the found skeleton or null if not found at all.\n     */\n    getSkeletonByName(name) {\n        for (let index = 0; index < this.skeletons.length; index++) {\n            if (this.skeletons[index].name === name) {\n                return this.skeletons[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a morph target manager  using a given id (if many are found, this function will pick the last one)\n     * @param id defines the id to search for\n     * @returns the found morph target manager or null if not found at all.\n     */\n    getMorphTargetManagerById(id) {\n        for (let index = 0; index < this.morphTargetManagers.length; index++) {\n            if (this.morphTargetManagers[index].uniqueId === id) {\n                return this.morphTargetManagers[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a morph target using a given id (if many are found, this function will pick the first one)\n     * @param id defines the id to search for\n     * @returns the found morph target or null if not found at all.\n     */\n    getMorphTargetById(id) {\n        for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n            const morphTargetManager = this.morphTargetManagers[managerIndex];\n            for (let index = 0; index < morphTargetManager.numTargets; ++index) {\n                const target = morphTargetManager.getTarget(index);\n                if (target.id === id) {\n                    return target;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a morph target using a given name (if many are found, this function will pick the first one)\n     * @param name defines the name to search for\n     * @returns the found morph target or null if not found at all.\n     */\n    getMorphTargetByName(name) {\n        for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n            const morphTargetManager = this.morphTargetManagers[managerIndex];\n            for (let index = 0; index < morphTargetManager.numTargets; ++index) {\n                const target = morphTargetManager.getTarget(index);\n                if (target.name === name) {\n                    return target;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a post process using a given name (if many are found, this function will pick the first one)\n     * @param name defines the name to search for\n     * @returns the found post process or null if not found at all.\n     */\n    getPostProcessByName(name) {\n        for (let postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {\n            const postProcess = this.postProcesses[postProcessIndex];\n            if (postProcess.name === name) {\n                return postProcess;\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets a boolean indicating if the given mesh is active\n     * @param mesh defines the mesh to look for\n     * @returns true if the mesh is in the active list\n     */\n    isActiveMesh(mesh) {\n        return this._activeMeshes.indexOf(mesh) !== -1;\n    }\n    /**\n     * Return a unique id as a string which can serve as an identifier for the scene\n     */\n    get uid() {\n        if (!this._uid) {\n            this._uid = Tools.RandomId();\n        }\n        return this._uid;\n    }\n    /**\n     * Add an externally attached data from its key.\n     * This method call will fail and return false, if such key already exists.\n     * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.\n     * @param key the unique key that identifies the data\n     * @param data the data object to associate to the key for this Engine instance\n     * @returns true if no such key were already present and the data was added successfully, false otherwise\n     */\n    addExternalData(key, data) {\n        if (!this._externalData) {\n            this._externalData = new StringDictionary();\n        }\n        return this._externalData.add(key, data);\n    }\n    /**\n     * Get an externally attached data from its key\n     * @param key the unique key that identifies the data\n     * @returns the associated data, if present (can be null), or undefined if not present\n     */\n    getExternalData(key) {\n        if (!this._externalData) {\n            return null;\n        }\n        return this._externalData.get(key);\n    }\n    /**\n     * Get an externally attached data from its key, create it using a factory if it's not already present\n     * @param key the unique key that identifies the data\n     * @param factory the factory that will be called to create the instance if and only if it doesn't exists\n     * @returns the associated data, can be null if the factory returned null.\n     */\n    getOrAddExternalDataWithFactory(key, factory) {\n        if (!this._externalData) {\n            this._externalData = new StringDictionary();\n        }\n        return this._externalData.getOrAddWithFactory(key, factory);\n    }\n    /**\n     * Remove an externally attached data from the Engine instance\n     * @param key the unique key that identifies the data\n     * @returns true if the data was successfully removed, false if it doesn't exist\n     */\n    removeExternalData(key) {\n        return this._externalData.remove(key);\n    }\n    _evaluateSubMesh(subMesh, mesh, initialMesh, forcePush) {\n        if (forcePush || subMesh.isInFrustum(this._frustumPlanes)) {\n            for (const step of this._evaluateSubMeshStage) {\n                step.action(mesh, subMesh);\n            }\n            const material = subMesh.getMaterial();\n            if (material !== null && material !== undefined) {\n                // Render targets\n                if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n                    if (this._processedMaterials.indexOf(material) === -1) {\n                        this._processedMaterials.push(material);\n                        this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n                    }\n                }\n                // Dispatch\n                this._renderingManager.dispatch(subMesh, mesh, material);\n            }\n        }\n    }\n    /**\n     * Clear the processed materials smart array preventing retention point in material dispose.\n     */\n    freeProcessedMaterials() {\n        this._processedMaterials.dispose();\n    }\n    /** Gets or sets a boolean blocking all the calls to freeActiveMeshes and freeRenderingGroups\n     * It can be used in order to prevent going through methods freeRenderingGroups and freeActiveMeshes several times to improve performance\n     * when disposing several meshes in a row or a hierarchy of meshes.\n     * When used, it is the responsibility of the user to blockfreeActiveMeshesAndRenderingGroups back to false.\n     */\n    get blockfreeActiveMeshesAndRenderingGroups() {\n        return this._preventFreeActiveMeshesAndRenderingGroups;\n    }\n    set blockfreeActiveMeshesAndRenderingGroups(value) {\n        if (this._preventFreeActiveMeshesAndRenderingGroups === value) {\n            return;\n        }\n        if (value) {\n            this.freeActiveMeshes();\n            this.freeRenderingGroups();\n        }\n        this._preventFreeActiveMeshesAndRenderingGroups = value;\n    }\n    /**\n     * Clear the active meshes smart array preventing retention point in mesh dispose.\n     */\n    freeActiveMeshes() {\n        if (this.blockfreeActiveMeshesAndRenderingGroups) {\n            return;\n        }\n        this._activeMeshes.dispose();\n        if (this.activeCamera && this.activeCamera._activeMeshes) {\n            this.activeCamera._activeMeshes.dispose();\n        }\n        if (this.activeCameras) {\n            for (let i = 0; i < this.activeCameras.length; i++) {\n                const activeCamera = this.activeCameras[i];\n                if (activeCamera && activeCamera._activeMeshes) {\n                    activeCamera._activeMeshes.dispose();\n                }\n            }\n        }\n    }\n    /**\n     * Clear the info related to rendering groups preventing retention points during dispose.\n     */\n    freeRenderingGroups() {\n        if (this.blockfreeActiveMeshesAndRenderingGroups) {\n            return;\n        }\n        if (this._renderingManager) {\n            this._renderingManager.freeRenderingGroups();\n        }\n        if (this.textures) {\n            for (let i = 0; i < this.textures.length; i++) {\n                const texture = this.textures[i];\n                if (texture && texture.renderList) {\n                    texture.freeRenderingGroups();\n                }\n            }\n        }\n    }\n    /** @internal */\n    _isInIntermediateRendering() {\n        return this._intermediateRendering;\n    }\n    /**\n     * Use this function to stop evaluating active meshes. The current list will be keep alive between frames\n     * @param skipEvaluateActiveMeshes defines an optional boolean indicating that the evaluate active meshes step must be completely skipped\n     * @param onSuccess optional success callback\n     * @param onError optional error callback\n     * @param freezeMeshes defines if meshes should be frozen (true by default)\n     * @param keepFrustumCulling defines if you want to keep running the frustum clipping (false by default)\n     * @returns the current scene\n     */\n    freezeActiveMeshes(skipEvaluateActiveMeshes = false, onSuccess, onError, freezeMeshes = true, keepFrustumCulling = false) {\n        this.executeWhenReady(() => {\n            if (!this.activeCamera) {\n                onError && onError(\"No active camera found\");\n                return;\n            }\n            if (!this._frustumPlanes) {\n                this.updateTransformMatrix();\n            }\n            this._evaluateActiveMeshes();\n            this._activeMeshesFrozen = true;\n            this._activeMeshesFrozenButKeepClipping = keepFrustumCulling;\n            this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;\n            if (freezeMeshes) {\n                for (let index = 0; index < this._activeMeshes.length; index++) {\n                    this._activeMeshes.data[index]._freeze();\n                }\n            }\n            onSuccess && onSuccess();\n        });\n        return this;\n    }\n    /**\n     * Use this function to restart evaluating active meshes on every frame\n     * @returns the current scene\n     */\n    unfreezeActiveMeshes() {\n        for (let index = 0; index < this.meshes.length; index++) {\n            const mesh = this.meshes[index];\n            if (mesh._internalAbstractMeshDataInfo) {\n                mesh._internalAbstractMeshDataInfo._isActive = false;\n            }\n        }\n        for (let index = 0; index < this._activeMeshes.length; index++) {\n            this._activeMeshes.data[index]._unFreeze();\n        }\n        this._activeMeshesFrozen = false;\n        return this;\n    }\n    _executeActiveContainerCleanup(container) {\n        const isInFastMode = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;\n        if (!isInFastMode && this._activeMeshesFrozen && this._activeMeshes.length) {\n            return; // Do not execute in frozen mode\n        }\n        // We need to ensure we are not in the rendering loop\n        this.onBeforeRenderObservable.addOnce(() => container.dispose());\n    }\n    _evaluateActiveMeshes() {\n        if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {\n            if (this._activeMeshes.length > 0) {\n                this.activeCamera?._activeMeshes.reset();\n                this._activeMeshes.reset();\n                this._renderingManager.reset();\n                this._processedMaterials.reset();\n                this._activeParticleSystems.reset();\n                this._activeSkeletons.reset();\n                this._softwareSkinnedMeshes.reset();\n            }\n            return;\n        }\n        if (this._activeMeshesFrozen && this._activeMeshes.length) {\n            if (!this._skipEvaluateActiveMeshesCompletely) {\n                const len = this._activeMeshes.length;\n                for (let i = 0; i < len; i++) {\n                    const mesh = this._activeMeshes.data[i];\n                    mesh.computeWorldMatrix();\n                }\n            }\n            if (this._activeParticleSystems) {\n                const psLength = this._activeParticleSystems.length;\n                for (let i = 0; i < psLength; i++) {\n                    this._activeParticleSystems.data[i].animate();\n                }\n            }\n            this._renderingManager.resetSprites();\n            return;\n        }\n        if (!this.activeCamera) {\n            return;\n        }\n        this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);\n        this.activeCamera._activeMeshes.reset();\n        this._activeMeshes.reset();\n        this._renderingManager.reset();\n        this._processedMaterials.reset();\n        this._activeParticleSystems.reset();\n        this._activeSkeletons.reset();\n        this._softwareSkinnedMeshes.reset();\n        this._materialsRenderTargets.reset();\n        for (const step of this._beforeEvaluateActiveMeshStage) {\n            step.action();\n        }\n        // Determine mesh candidates\n        const meshes = this.getActiveMeshCandidates();\n        // Check each mesh\n        const len = meshes.length;\n        for (let i = 0; i < len; i++) {\n            const mesh = meshes.data[i];\n            mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;\n            if (mesh.isBlocked) {\n                continue;\n            }\n            this._totalVertices.addCount(mesh.getTotalVertices(), false);\n            if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.hasAZeroComponent) {\n                continue;\n            }\n            mesh.computeWorldMatrix();\n            // Intersections\n            if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {\n                this._meshesForIntersections.pushNoDuplicate(mesh);\n            }\n            // Switch to current LOD\n            let meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);\n            mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;\n            mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\n            if (meshToRender === undefined || meshToRender === null) {\n                continue;\n            }\n            // Compute world matrix if LOD is billboard\n            if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {\n                meshToRender.computeWorldMatrix();\n            }\n            mesh._preActivate();\n            if (mesh.isVisible &&\n                mesh.visibility > 0 &&\n                (mesh.layerMask & this.activeCamera.layerMask) !== 0 &&\n                (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {\n                this._activeMeshes.push(mesh);\n                this.activeCamera._activeMeshes.push(mesh);\n                if (meshToRender !== mesh) {\n                    meshToRender._activate(this._renderId, false);\n                }\n                for (const step of this._preActiveMeshStage) {\n                    step.action(mesh);\n                }\n                if (mesh._activate(this._renderId, false)) {\n                    if (!mesh.isAnInstance) {\n                        meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;\n                    }\n                    else {\n                        if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\n                            meshToRender = mesh;\n                        }\n                    }\n                    meshToRender._internalAbstractMeshDataInfo._isActive = true;\n                    this._activeMesh(mesh, meshToRender);\n                }\n                mesh._postActivate();\n            }\n        }\n        this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this);\n        // Particle systems\n        if (this.particlesEnabled) {\n            this.onBeforeParticlesRenderingObservable.notifyObservers(this);\n            for (let particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {\n                const particleSystem = this.particleSystems[particleIndex];\n                if (!particleSystem.isStarted() || !particleSystem.emitter) {\n                    continue;\n                }\n                const emitter = particleSystem.emitter;\n                if (!emitter.position || emitter.isEnabled()) {\n                    this._activeParticleSystems.push(particleSystem);\n                    particleSystem.animate();\n                    this._renderingManager.dispatchParticles(particleSystem);\n                }\n            }\n            this.onAfterParticlesRenderingObservable.notifyObservers(this);\n        }\n    }\n    /** @internal */\n    _prepareSkeleton(mesh) {\n        if (!this._skeletonsEnabled || !mesh.skeleton) {\n            return;\n        }\n        if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {\n            mesh.skeleton.prepare();\n            this._activeBones.addCount(mesh.skeleton.bones.length, false);\n        }\n        if (!mesh.computeBonesUsingShaders) {\n            if (this._softwareSkinnedMeshes.pushNoDuplicate(mesh) && this.frameGraph) {\n                mesh.applySkeleton(mesh.skeleton);\n            }\n        }\n    }\n    _activeMesh(sourceMesh, mesh) {\n        this._prepareSkeleton(mesh);\n        let forcePush = sourceMesh.hasInstances || sourceMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh;\n        if (mesh && mesh.subMeshes && mesh.subMeshes.length > 0) {\n            const subMeshes = this.getActiveSubMeshCandidates(mesh);\n            const len = subMeshes.length;\n            forcePush = forcePush || len === 1;\n            for (let i = 0; i < len; i++) {\n                const subMesh = subMeshes.data[i];\n                this._evaluateSubMesh(subMesh, mesh, sourceMesh, forcePush);\n            }\n        }\n    }\n    /**\n     * Update the transform matrix to update from the current active camera\n     * @param force defines a boolean used to force the update even if cache is up to date\n     */\n    updateTransformMatrix(force) {\n        const activeCamera = this.activeCamera;\n        if (!activeCamera) {\n            return;\n        }\n        if (activeCamera._renderingMultiview) {\n            const leftCamera = activeCamera._rigCameras[0];\n            const rightCamera = activeCamera._rigCameras[1];\n            this.setTransformMatrix(leftCamera.getViewMatrix(), leftCamera.getProjectionMatrix(force), rightCamera.getViewMatrix(), rightCamera.getProjectionMatrix(force));\n        }\n        else {\n            this.setTransformMatrix(activeCamera.getViewMatrix(), activeCamera.getProjectionMatrix(force));\n        }\n    }\n    _bindFrameBuffer(camera, clear = true) {\n        if (camera && camera._multiviewTexture) {\n            camera._multiviewTexture._bindFrameBuffer();\n        }\n        else if (camera && camera.outputRenderTarget) {\n            camera.outputRenderTarget._bindFrameBuffer();\n        }\n        else {\n            if (!this._engine._currentFrameBufferIsDefaultFrameBuffer()) {\n                this._engine.restoreDefaultFramebuffer();\n            }\n        }\n        if (clear) {\n            this._clearFrameBuffer(camera);\n        }\n    }\n    _clearFrameBuffer(camera) {\n        // we assume the framebuffer currently bound is the right one\n        if (camera && camera._multiviewTexture) {\n            // no clearing\n        }\n        else if (camera && camera.outputRenderTarget && !camera._renderingMultiview) {\n            const rtt = camera.outputRenderTarget;\n            if (rtt.onClearObservable.hasObservers()) {\n                rtt.onClearObservable.notifyObservers(this._engine);\n            }\n            else if (!rtt.skipInitialClear && !camera.isRightCamera) {\n                if (this.autoClear) {\n                    this._engine.clear(rtt.clearColor || this._clearColor, !rtt._cleared, true, true);\n                }\n                rtt._cleared = true;\n            }\n        }\n        else {\n            if (!this._defaultFrameBufferCleared) {\n                this._defaultFrameBufferCleared = true;\n                this._clear();\n            }\n            else {\n                this._engine.clear(null, false, true, true);\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    _renderForCamera(camera, rigParent, bindFrameBuffer = true) {\n        if (camera && camera._skipRendering) {\n            return;\n        }\n        const engine = this._engine;\n        // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n        this._activeCamera = camera;\n        if (!this.activeCamera) {\n            throw new Error(\"Active camera not set\");\n        }\n        // Viewport\n        engine.setViewport(this.activeCamera.viewport);\n        // Camera\n        this.resetCachedMaterial();\n        this._renderId++;\n        if (!this.prePass && bindFrameBuffer) {\n            let skipInitialClear = true;\n            if (camera._renderingMultiview && camera.outputRenderTarget) {\n                skipInitialClear = camera.outputRenderTarget.skipInitialClear;\n                if (this.autoClear) {\n                    this._defaultFrameBufferCleared = false;\n                    camera.outputRenderTarget.skipInitialClear = false;\n                }\n            }\n            this._bindFrameBuffer(this._activeCamera);\n            if (camera._renderingMultiview && camera.outputRenderTarget) {\n                camera.outputRenderTarget.skipInitialClear = skipInitialClear;\n            }\n        }\n        this.updateTransformMatrix();\n        this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);\n        // Meshes\n        this._evaluateActiveMeshes();\n        // Software skinning\n        for (let softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {\n            const mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];\n            mesh.applySkeleton(mesh.skeleton);\n        }\n        // Render targets\n        this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n        this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets);\n        if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {\n            this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);\n        }\n        if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {\n            this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);\n        }\n        if (this.environmentTexture && this.environmentTexture.isRenderTarget) {\n            this._renderTargets.pushNoDuplicate(this.environmentTexture);\n        }\n        // Collects render targets from external components.\n        for (const step of this._gatherActiveCameraRenderTargetsStage) {\n            step.action(this._renderTargets);\n        }\n        let needRebind = false;\n        if (this.renderTargetsEnabled) {\n            this._intermediateRendering = true;\n            if (this._renderTargets.length > 0) {\n                Tools.StartPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n                for (let renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {\n                    const renderTarget = this._renderTargets.data[renderIndex];\n                    if (renderTarget._shouldRender()) {\n                        this._renderId++;\n                        const hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;\n                        renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);\n                        needRebind = true;\n                    }\n                }\n                Tools.EndPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n                this._renderId++;\n            }\n            for (const step of this._cameraDrawRenderTargetStage) {\n                needRebind = step.action(this.activeCamera) || needRebind;\n            }\n            this._intermediateRendering = false;\n        }\n        this._engine.currentRenderPassId = camera.outputRenderTarget?.renderPassId ?? camera.renderPassId ?? 0;\n        // Restore framebuffer after rendering to targets\n        if (needRebind && !this.prePass) {\n            this._bindFrameBuffer(this._activeCamera, false);\n            this.updateTransformMatrix();\n        }\n        this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\n        // Prepare Frame\n        if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {\n            this.postProcessManager._prepareFrame();\n        }\n        // Before Camera Draw\n        for (const step of this._beforeCameraDrawStage) {\n            step.action(this.activeCamera);\n        }\n        // Render\n        this.onBeforeDrawPhaseObservable.notifyObservers(this);\n        if (engine.snapshotRendering && engine.snapshotRenderingMode === 1) {\n            this.finalizeSceneUbo();\n        }\n        this._renderingManager.render(null, null, true, true);\n        this.onAfterDrawPhaseObservable.notifyObservers(this);\n        // After Camera Draw\n        for (const step of this._afterCameraDrawStage) {\n            step.action(this.activeCamera);\n        }\n        // Finalize frame\n        if (this.postProcessManager && !camera._multiviewTexture) {\n            // if the camera has an output render target, render the post process to the render target\n            const texture = camera.outputRenderTarget ? camera.outputRenderTarget.renderTarget : undefined;\n            this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);\n        }\n        // After post process\n        for (const step of this._afterCameraPostProcessStage) {\n            step.action(this.activeCamera);\n        }\n        // Reset some special arrays\n        this._renderTargets.reset();\n        this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);\n    }\n    _processSubCameras(camera, bindFrameBuffer = true) {\n        if (camera.cameraRigMode === 0 || camera._renderingMultiview) {\n            if (camera._renderingMultiview && !this._multiviewSceneUbo) {\n                this._createMultiviewUbo();\n            }\n            this._renderForCamera(camera, undefined, bindFrameBuffer);\n            this.onAfterRenderCameraObservable.notifyObservers(camera);\n            return;\n        }\n        if (camera._useMultiviewToSingleView) {\n            this._renderMultiviewToSingleView(camera);\n        }\n        else {\n            // rig cameras\n            this.onBeforeCameraRenderObservable.notifyObservers(camera);\n            for (let index = 0; index < camera._rigCameras.length; index++) {\n                this._renderForCamera(camera._rigCameras[index], camera);\n            }\n        }\n        // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n        this._activeCamera = camera;\n        this.updateTransformMatrix();\n        this.onAfterRenderCameraObservable.notifyObservers(camera);\n    }\n    _checkIntersections() {\n        for (let index = 0; index < this._meshesForIntersections.length; index++) {\n            const sourceMesh = this._meshesForIntersections.data[index];\n            if (!sourceMesh.actionManager) {\n                continue;\n            }\n            for (let actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {\n                const action = sourceMesh.actionManager.actions[actionIndex];\n                if (action.trigger === 12 || action.trigger === 13) {\n                    const parameters = action.getTriggerParameter();\n                    const otherMesh = parameters.mesh ? parameters.mesh : parameters;\n                    const areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);\n                    const currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);\n                    if (areIntersecting && currentIntersectionInProgress === -1) {\n                        if (action.trigger === 12) {\n                            action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n                            sourceMesh._intersectionsInProgress.push(otherMesh);\n                        }\n                        else if (action.trigger === 13) {\n                            sourceMesh._intersectionsInProgress.push(otherMesh);\n                        }\n                    }\n                    else if (!areIntersecting && currentIntersectionInProgress > -1) {\n                        //They intersected, and now they don't.\n                        //is this trigger an exit trigger? execute an event.\n                        if (action.trigger === 13) {\n                            action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n                        }\n                        //if this is an exit trigger, or no exit trigger exists, remove the id from the intersection in progress array.\n                        if (!sourceMesh.actionManager.hasSpecificTrigger(13, (parameter) => {\n                            const parameterMesh = parameter.mesh ? parameter.mesh : parameter;\n                            return otherMesh === parameterMesh;\n                        }) ||\n                            action.trigger === 13) {\n                            sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    _advancePhysicsEngineStep(step) {\n        // Do nothing. Code will be replaced if physics engine component is referenced\n    }\n    /** @internal */\n    _animate(customDeltaTime) {\n        // Nothing to do as long as Animatable have not been imported.\n    }\n    /** Execute all animations (for a frame) */\n    animate() {\n        if (this._engine.isDeterministicLockStep()) {\n            let deltaTime = Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime)) + this._timeAccumulator;\n            const defaultFrameTime = this._engine.getTimeStep();\n            const defaultFPS = 1000.0 / defaultFrameTime / 1000.0;\n            let stepsTaken = 0;\n            const maxSubSteps = this._engine.getLockstepMaxSteps();\n            let internalSteps = Math.floor(deltaTime / defaultFrameTime);\n            internalSteps = Math.min(internalSteps, maxSubSteps);\n            while (deltaTime > 0 && stepsTaken < internalSteps) {\n                this.onBeforeStepObservable.notifyObservers(this);\n                // Animations\n                this._animationRatio = defaultFrameTime * defaultFPS;\n                this._animate(defaultFrameTime);\n                this.onAfterAnimationsObservable.notifyObservers(this);\n                // Physics\n                if (this.physicsEnabled) {\n                    this._advancePhysicsEngineStep(defaultFrameTime);\n                }\n                this.onAfterStepObservable.notifyObservers(this);\n                this._currentStepId++;\n                stepsTaken++;\n                deltaTime -= defaultFrameTime;\n            }\n            this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;\n        }\n        else {\n            // Animations\n            const deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime));\n            this._animationRatio = deltaTime * (60.0 / 1000.0);\n            this._animate();\n            this.onAfterAnimationsObservable.notifyObservers(this);\n            // Physics\n            if (this.physicsEnabled) {\n                this._advancePhysicsEngineStep(deltaTime);\n            }\n        }\n    }\n    _clear() {\n        if (this.autoClearDepthAndStencil || this.autoClear) {\n            this._engine.clear(this._clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);\n        }\n    }\n    _checkCameraRenderTarget(camera) {\n        if (camera?.outputRenderTarget && !camera?.isRigCamera) {\n            camera.outputRenderTarget._cleared = false;\n        }\n        if (camera?.rigCameras?.length) {\n            for (let i = 0; i < camera.rigCameras.length; ++i) {\n                const rtt = camera.rigCameras[i].outputRenderTarget;\n                if (rtt) {\n                    rtt._cleared = false;\n                }\n            }\n        }\n    }\n    /**\n     * Resets the draw wrappers cache of all meshes\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n     */\n    resetDrawCache(passId) {\n        if (!this.meshes) {\n            return;\n        }\n        for (const mesh of this.meshes) {\n            mesh.resetDrawCache(passId);\n        }\n    }\n    _renderWithFrameGraph(updateCameras = true, ignoreAnimations = false) {\n        this.activeCamera = null;\n        this._activeParticleSystems.reset();\n        this._activeSkeletons.reset();\n        // Update Cameras\n        if (updateCameras) {\n            for (const camera of this.cameras) {\n                camera.update();\n                if (camera.cameraRigMode !== 0) {\n                    // rig cameras\n                    for (let index = 0; index < camera._rigCameras.length; index++) {\n                        camera._rigCameras[index].update();\n                    }\n                }\n            }\n        }\n        // We must keep these steps because the procedural texture component relies on them.\n        // TODO: move the procedural texture component to the frame graph.\n        for (const step of this._beforeClearStage) {\n            step.action();\n        }\n        // Process meshes\n        const meshes = this.getActiveMeshCandidates();\n        const len = meshes.length;\n        for (let i = 0; i < len; i++) {\n            const mesh = meshes.data[i];\n            if (mesh.isBlocked) {\n                continue;\n            }\n            this._totalVertices.addCount(mesh.getTotalVertices(), false);\n            if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.hasAZeroComponent) {\n                continue;\n            }\n            mesh.computeWorldMatrix();\n            if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {\n                this._meshesForIntersections.pushNoDuplicate(mesh);\n            }\n        }\n        // Animate Particle systems\n        if (this.particlesEnabled) {\n            for (let particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {\n                const particleSystem = this.particleSystems[particleIndex];\n                if (!particleSystem.isStarted() || !particleSystem.emitter) {\n                    continue;\n                }\n                const emitter = particleSystem.emitter;\n                if (!emitter.position || emitter.isEnabled()) {\n                    this._activeParticleSystems.push(particleSystem);\n                    particleSystem.animate();\n                }\n            }\n        }\n        // Render the graph\n        this.frameGraph?.execute();\n    }\n    /**\n     * Render the scene\n     * @param updateCameras defines a boolean indicating if cameras must update according to their inputs (true by default)\n     * @param ignoreAnimations defines a boolean indicating if animations should not be executed (false by default)\n     */\n    render(updateCameras = true, ignoreAnimations = false) {\n        if (this.isDisposed) {\n            return;\n        }\n        if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null) {\n            this._checkIsReady();\n        }\n        this._frameId++;\n        this._defaultFrameBufferCleared = false;\n        this._checkCameraRenderTarget(this.activeCamera);\n        if (this.activeCameras?.length) {\n            this.activeCameras.forEach(this._checkCameraRenderTarget);\n        }\n        // Register components that have been associated lately to the scene.\n        this._registerTransientComponents();\n        this._activeParticles.fetchNewFrame();\n        this._totalVertices.fetchNewFrame();\n        this._activeIndices.fetchNewFrame();\n        this._activeBones.fetchNewFrame();\n        this._meshesForIntersections.reset();\n        this.resetCachedMaterial();\n        this.onBeforeAnimationsObservable.notifyObservers(this);\n        // Actions\n        if (this.actionManager) {\n            this.actionManager.processTrigger(11);\n        }\n        // Animations\n        if (!ignoreAnimations) {\n            this.animate();\n        }\n        // Before camera update steps\n        for (const step of this._beforeCameraUpdateStage) {\n            step.action();\n        }\n        // Update Cameras\n        if (updateCameras) {\n            if (this.activeCameras && this.activeCameras.length > 0) {\n                for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n                    const camera = this.activeCameras[cameraIndex];\n                    camera.update();\n                    if (camera.cameraRigMode !== 0) {\n                        // rig cameras\n                        for (let index = 0; index < camera._rigCameras.length; index++) {\n                            camera._rigCameras[index].update();\n                        }\n                    }\n                }\n            }\n            else if (this.activeCamera) {\n                this.activeCamera.update();\n                if (this.activeCamera.cameraRigMode !== 0) {\n                    // rig cameras\n                    for (let index = 0; index < this.activeCamera._rigCameras.length; index++) {\n                        this.activeCamera._rigCameras[index].update();\n                    }\n                }\n            }\n        }\n        // Before render\n        this.onBeforeRenderObservable.notifyObservers(this);\n        // Custom render function?\n        if (this.customRenderFunction) {\n            this._renderId++;\n            this._engine.currentRenderPassId = 0;\n            this.customRenderFunction(updateCameras, ignoreAnimations);\n        }\n        else {\n            const engine = this.getEngine();\n            // Customs render targets\n            this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n            const currentActiveCamera = this.activeCameras?.length ? this.activeCameras[0] : this.activeCamera;\n            if (this.renderTargetsEnabled) {\n                Tools.StartPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n                this._intermediateRendering = true;\n                for (let customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {\n                    const renderTarget = this.customRenderTargets[customIndex];\n                    if (renderTarget._shouldRender()) {\n                        this._renderId++;\n                        this.activeCamera = renderTarget.activeCamera || this.activeCamera;\n                        if (!this.activeCamera) {\n                            throw new Error(\"Active camera not set\");\n                        }\n                        // Viewport\n                        engine.setViewport(this.activeCamera.viewport);\n                        // Camera\n                        this.updateTransformMatrix();\n                        renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);\n                    }\n                }\n                Tools.EndPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n                this._intermediateRendering = false;\n                this._renderId++;\n            }\n            this._engine.currentRenderPassId = currentActiveCamera?.renderPassId ?? 0;\n            // Restore back buffer\n            this.activeCamera = currentActiveCamera;\n            if (this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass) {\n                this._bindFrameBuffer(this._activeCamera, false);\n            }\n            this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\n            for (const step of this._beforeClearStage) {\n                step.action();\n            }\n            // Clear\n            this._clearFrameBuffer(this.activeCamera);\n            // Collects render targets from external components.\n            for (const step of this._gatherRenderTargetsStage) {\n                step.action(this._renderTargets);\n            }\n            // Multi-cameras?\n            if (this.activeCameras && this.activeCameras.length > 0) {\n                for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n                    this._processSubCameras(this.activeCameras[cameraIndex], cameraIndex > 0);\n                }\n            }\n            else {\n                if (!this.activeCamera) {\n                    throw new Error(\"No camera defined\");\n                }\n                this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);\n            }\n        }\n        // Intersection checks\n        this._checkIntersections();\n        // Executes the after render stage actions.\n        for (const step of this._afterRenderStage) {\n            step.action();\n        }\n        // After render\n        if (this.afterRender) {\n            this.afterRender();\n        }\n        this.onAfterRenderObservable.notifyObservers(this);\n        // Cleaning\n        if (this._toBeDisposed.length) {\n            for (let index = 0; index < this._toBeDisposed.length; index++) {\n                const data = this._toBeDisposed[index];\n                if (data) {\n                    data.dispose();\n                }\n            }\n            this._toBeDisposed.length = 0;\n        }\n        if (this.dumpNextRenderTargets) {\n            this.dumpNextRenderTargets = false;\n        }\n        this._activeBones.addCount(0, true);\n        this._activeIndices.addCount(0, true);\n        this._activeParticles.addCount(0, true);\n        this._engine.restoreDefaultFramebuffer();\n    }\n    /**\n     * Freeze all materials\n     * A frozen material will not be updatable but should be faster to render\n     * Note: multimaterials will not be frozen, but their submaterials will\n     */\n    freezeMaterials() {\n        for (let i = 0; i < this.materials.length; i++) {\n            this.materials[i].freeze();\n        }\n    }\n    /**\n     * Unfreeze all materials\n     * A frozen material will not be updatable but should be faster to render\n     */\n    unfreezeMaterials() {\n        for (let i = 0; i < this.materials.length; i++) {\n            this.materials[i].unfreeze();\n        }\n    }\n    /**\n     * Releases all held resources\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.beforeRender = null;\n        this.afterRender = null;\n        this.metadata = null;\n        this.skeletons.length = 0;\n        this.morphTargetManagers.length = 0;\n        this._transientComponents.length = 0;\n        this._isReadyForMeshStage.clear();\n        this._beforeEvaluateActiveMeshStage.clear();\n        this._evaluateSubMeshStage.clear();\n        this._preActiveMeshStage.clear();\n        this._cameraDrawRenderTargetStage.clear();\n        this._beforeCameraDrawStage.clear();\n        this._beforeRenderTargetDrawStage.clear();\n        this._beforeRenderingGroupDrawStage.clear();\n        this._beforeRenderingMeshStage.clear();\n        this._afterRenderingMeshStage.clear();\n        this._afterRenderingGroupDrawStage.clear();\n        this._afterCameraDrawStage.clear();\n        this._afterRenderTargetDrawStage.clear();\n        this._afterRenderStage.clear();\n        this._beforeCameraUpdateStage.clear();\n        this._beforeClearStage.clear();\n        this._gatherRenderTargetsStage.clear();\n        this._gatherActiveCameraRenderTargetsStage.clear();\n        this._pointerMoveStage.clear();\n        this._pointerDownStage.clear();\n        this._pointerUpStage.clear();\n        this.importedMeshesFiles = [];\n        if (this._activeAnimatables && this.stopAllAnimations) {\n            // Ensures that no animatable notifies a callback that could start a new animation group, constantly adding new animatables to the active list...\n            this._activeAnimatables.forEach((animatable) => {\n                animatable.onAnimationEndObservable.clear();\n                animatable.onAnimationEnd = null;\n            });\n            this.stopAllAnimations();\n        }\n        this.resetCachedMaterial();\n        // Smart arrays\n        if (this.activeCamera) {\n            this.activeCamera._activeMeshes.dispose();\n            this.activeCamera = null;\n        }\n        this.activeCameras = null;\n        this._activeMeshes.dispose();\n        this._renderingManager.dispose();\n        this._processedMaterials.dispose();\n        this._activeParticleSystems.dispose();\n        this._activeSkeletons.dispose();\n        this._softwareSkinnedMeshes.dispose();\n        this._renderTargets.dispose();\n        this._materialsRenderTargets.dispose();\n        this._registeredForLateAnimationBindings.dispose();\n        this._meshesForIntersections.dispose();\n        this._toBeDisposed.length = 0;\n        // Abort active requests\n        const activeRequests = this._activeRequests.slice();\n        for (const request of activeRequests) {\n            request.abort();\n        }\n        this._activeRequests.length = 0;\n        // Events\n        try {\n            this.onDisposeObservable.notifyObservers(this);\n        }\n        catch (e) {\n            Logger.Error(\"An error occurred while calling onDisposeObservable!\", e);\n        }\n        this.detachControl();\n        // Detach cameras\n        const canvas = this._engine.getInputElement();\n        if (canvas) {\n            for (let index = 0; index < this.cameras.length; index++) {\n                this.cameras[index].detachControl();\n            }\n        }\n        // Release animation groups\n        this._disposeList(this.animationGroups);\n        // Release lights\n        this._disposeList(this.lights);\n        // Release materials\n        if (this._defaultMaterial) {\n            this._defaultMaterial.dispose();\n        }\n        this._disposeList(this.multiMaterials);\n        this._disposeList(this.materials);\n        // Release meshes\n        this._disposeList(this.meshes, (item) => item.dispose(true));\n        this._disposeList(this.transformNodes, (item) => item.dispose(true));\n        // Release cameras\n        const cameras = this.cameras;\n        this._disposeList(cameras);\n        // Release particles\n        this._disposeList(this.particleSystems);\n        // Release postProcesses\n        this._disposeList(this.postProcesses);\n        // Release textures\n        this._disposeList(this.textures);\n        // Release morph targets\n        this._disposeList(this.morphTargetManagers);\n        // Release UBO\n        this._sceneUbo.dispose();\n        if (this._multiviewSceneUbo) {\n            this._multiviewSceneUbo.dispose();\n        }\n        // Post-processes\n        this.postProcessManager.dispose();\n        // Components\n        this._disposeList(this._components);\n        // Remove from engine\n        let index = this._engine.scenes.indexOf(this);\n        if (index > -1) {\n            this._engine.scenes.splice(index, 1);\n        }\n        if (EngineStore._LastCreatedScene === this) {\n            if (this._engine.scenes.length > 0) {\n                EngineStore._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1];\n            }\n            else {\n                EngineStore._LastCreatedScene = null;\n            }\n        }\n        index = this._engine._virtualScenes.indexOf(this);\n        if (index > -1) {\n            this._engine._virtualScenes.splice(index, 1);\n        }\n        this._engine.wipeCaches(true);\n        this.onDisposeObservable.clear();\n        this.onBeforeRenderObservable.clear();\n        this.onAfterRenderObservable.clear();\n        this.onBeforeRenderTargetsRenderObservable.clear();\n        this.onAfterRenderTargetsRenderObservable.clear();\n        this.onAfterStepObservable.clear();\n        this.onBeforeStepObservable.clear();\n        this.onBeforeActiveMeshesEvaluationObservable.clear();\n        this.onAfterActiveMeshesEvaluationObservable.clear();\n        this.onBeforeParticlesRenderingObservable.clear();\n        this.onAfterParticlesRenderingObservable.clear();\n        this.onBeforeDrawPhaseObservable.clear();\n        this.onAfterDrawPhaseObservable.clear();\n        this.onBeforeAnimationsObservable.clear();\n        this.onAfterAnimationsObservable.clear();\n        this.onDataLoadedObservable.clear();\n        this.onBeforeRenderingGroupObservable.clear();\n        this.onAfterRenderingGroupObservable.clear();\n        this.onMeshImportedObservable.clear();\n        this.onBeforeCameraRenderObservable.clear();\n        this.onAfterCameraRenderObservable.clear();\n        this.onAfterRenderCameraObservable.clear();\n        this.onReadyObservable.clear();\n        this.onNewCameraAddedObservable.clear();\n        this.onCameraRemovedObservable.clear();\n        this.onNewLightAddedObservable.clear();\n        this.onLightRemovedObservable.clear();\n        this.onNewGeometryAddedObservable.clear();\n        this.onGeometryRemovedObservable.clear();\n        this.onNewTransformNodeAddedObservable.clear();\n        this.onTransformNodeRemovedObservable.clear();\n        this.onNewMeshAddedObservable.clear();\n        this.onMeshRemovedObservable.clear();\n        this.onNewSkeletonAddedObservable.clear();\n        this.onSkeletonRemovedObservable.clear();\n        this.onNewMaterialAddedObservable.clear();\n        this.onNewMultiMaterialAddedObservable.clear();\n        this.onMaterialRemovedObservable.clear();\n        this.onMultiMaterialRemovedObservable.clear();\n        this.onNewTextureAddedObservable.clear();\n        this.onTextureRemovedObservable.clear();\n        this.onPrePointerObservable.clear();\n        this.onPointerObservable.clear();\n        this.onPreKeyboardObservable.clear();\n        this.onKeyboardObservable.clear();\n        this.onActiveCameraChanged.clear();\n        this.onScenePerformancePriorityChangedObservable.clear();\n        this.onClearColorChangedObservable.clear();\n        this.onEnvironmentTextureChangedObservable.clear();\n        this.onMeshUnderPointerUpdatedObservable.clear();\n        this._isDisposed = true;\n    }\n    _disposeList(items, callback) {\n        const itemsCopy = items.slice(0);\n        callback = callback ?? ((item) => item.dispose());\n        for (const item of itemsCopy) {\n            callback(item);\n        }\n        items.length = 0;\n    }\n    /**\n     * Gets if the scene is already disposed\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Call this function to reduce memory footprint of the scene.\n     * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\n     */\n    clearCachedVertexData() {\n        for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n            const mesh = this.meshes[meshIndex];\n            const geometry = mesh.geometry;\n            if (geometry) {\n                geometry.clearCachedData();\n            }\n        }\n    }\n    /**\n     * This function will remove the local cached buffer data from texture.\n     * It will save memory but will prevent the texture from being rebuilt\n     */\n    cleanCachedTextureBuffer() {\n        for (const baseTexture of this.textures) {\n            const buffer = baseTexture._buffer;\n            if (buffer) {\n                baseTexture._buffer = null;\n            }\n        }\n    }\n    /**\n     * Get the world extend vectors with an optional filter\n     *\n     * @param filterPredicate the predicate - which meshes should be included when calculating the world size\n     * @returns {{ min: Vector3; max: Vector3 }} min and max vectors\n     */\n    getWorldExtends(filterPredicate) {\n        const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n        filterPredicate = filterPredicate || (() => true);\n        this.meshes.filter(filterPredicate).forEach((mesh) => {\n            mesh.computeWorldMatrix(true);\n            if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {\n                return;\n            }\n            const boundingInfo = mesh.getBoundingInfo();\n            const minBox = boundingInfo.boundingBox.minimumWorld;\n            const maxBox = boundingInfo.boundingBox.maximumWorld;\n            Vector3.CheckExtends(minBox, min, max);\n            Vector3.CheckExtends(maxBox, min, max);\n        });\n        return {\n            min: min,\n            max: max,\n        };\n    }\n    // Picking\n    // eslint-disable-next-line jsdoc/require-returns-check\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n     * @param camera defines the camera to use for the picking\n     * @param cameraViewSpace defines if picking will be done in view space (false by default)\n     * @returns a Ray\n     */\n    createPickingRay(x, y, world, camera, cameraViewSpace = false) {\n        throw _WarnImport(\"Ray\");\n    }\n    // eslint-disable-next-line jsdoc/require-returns-check\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n     * @param result defines the ray where to store the picking ray\n     * @param camera defines the camera to use for the picking\n     * @param cameraViewSpace defines if picking will be done in view space (false by default)\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\n     * @returns the current scene\n     */\n    createPickingRayToRef(x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {\n        throw _WarnImport(\"Ray\");\n    }\n    // eslint-disable-next-line jsdoc/require-returns-check\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param camera defines the camera to use for the picking\n     * @returns a Ray\n     */\n    createPickingRayInCameraSpace(x, y, camera) {\n        throw _WarnImport(\"Ray\");\n    }\n    // eslint-disable-next-line jsdoc/require-returns-check\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param result defines the ray where to store the picking ray\n     * @param camera defines the camera to use for the picking\n     * @returns the current scene\n     */\n    createPickingRayInCameraSpaceToRef(x, y, result, camera) {\n        throw _WarnImport(\"Ray\");\n    }\n    /** Launch a ray to try to pick a mesh in the scene\n     * @param x position on screen\n     * @param y position on screen\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns a PickingInfo\n     */\n    pick(x, y, predicate, fastCheck, camera, trianglePredicate) {\n        const warn = _WarnImport(\"Ray\", true);\n        if (warn) {\n            Logger.Warn(warn);\n        }\n        // Dummy info if picking as not been imported\n        return new PickingInfo();\n    }\n    /** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)\n     * @param x position on screen\n     * @param y position on screen\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n     * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)\n     */\n    pickWithBoundingInfo(x, y, predicate, fastCheck, camera) {\n        const warn = _WarnImport(\"Ray\", true);\n        if (warn) {\n            Logger.Warn(warn);\n        }\n        // Dummy info if picking as not been imported\n        return new PickingInfo();\n    }\n    // eslint-disable-next-line jsdoc/require-returns-check\n    /**\n     * Use the given ray to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\n     * irrespective of orientation.\n     * @param ray The ray to use to pick meshes\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns a PickingInfo\n     */\n    pickWithRay(ray, predicate, fastCheck, trianglePredicate) {\n        throw _WarnImport(\"Ray\");\n    }\n    // eslint-disable-next-line jsdoc/require-returns-check\n    /**\n     * Launch a ray to try to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\n     * irrespective of orientation.\n     * @param x X position on screen\n     * @param y Y position on screen\n     * @param predicate Predicate function used to determine eligible meshes and instances. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\n     * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns an array of PickingInfo\n     */\n    multiPick(x, y, predicate, camera, trianglePredicate) {\n        throw _WarnImport(\"Ray\");\n    }\n    // eslint-disable-next-line jsdoc/require-returns-check\n    /**\n     * Launch a ray to try to pick a mesh in the scene\n     * @param ray Ray to use\n     * @param predicate Predicate function used to determine eligible meshes and instances. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns an array of PickingInfo\n     */\n    multiPickWithRay(ray, predicate, trianglePredicate) {\n        throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Force the value of meshUnderPointer\n     * @param mesh defines the mesh to use\n     * @param pointerId optional pointer id when using more than one pointer\n     * @param pickResult optional pickingInfo data used to find mesh\n     */\n    setPointerOverMesh(mesh, pointerId, pickResult) {\n        this._inputManager.setPointerOverMesh(mesh, pointerId, pickResult);\n    }\n    /**\n     * Gets the mesh under the pointer\n     * @returns a Mesh or null if no mesh is under the pointer\n     */\n    getPointerOverMesh() {\n        return this._inputManager.getPointerOverMesh();\n    }\n    // Misc.\n    /** @internal */\n    _rebuildGeometries() {\n        for (const geometry of this.geometries) {\n            geometry._rebuild();\n        }\n        for (const mesh of this.meshes) {\n            mesh._rebuild();\n        }\n        if (this.postProcessManager) {\n            this.postProcessManager._rebuild();\n        }\n        for (const component of this._components) {\n            component.rebuild();\n        }\n        for (const system of this.particleSystems) {\n            system.rebuild();\n        }\n        if (this.spriteManagers) {\n            for (const spriteMgr of this.spriteManagers) {\n                spriteMgr.rebuild();\n            }\n        }\n    }\n    /** @internal */\n    _rebuildTextures() {\n        for (const texture of this.textures) {\n            texture._rebuild(true);\n        }\n        this.markAllMaterialsAsDirty(1);\n    }\n    /**\n     * Get from a list of objects by tags\n     * @param list the list of objects to use\n     * @param tagsQuery the query to use\n     * @param filter a predicate to filter for tags\n     * @returns\n     */\n    _getByTags(list, tagsQuery, filter) {\n        if (tagsQuery === undefined) {\n            // returns the complete list (could be done with Tags.MatchesQuery but no need to have a for-loop here)\n            return list;\n        }\n        const listByTags = [];\n        for (const i in list) {\n            const item = list[i];\n            if (Tags && Tags.MatchesQuery(item, tagsQuery) && (!filter || filter(item))) {\n                listByTags.push(item);\n            }\n        }\n        return listByTags;\n    }\n    /**\n     * Get a list of meshes by tags\n     * @param tagsQuery defines the tags query to use\n     * @param filter defines a predicate used to filter results\n     * @returns an array of Mesh\n     */\n    getMeshesByTags(tagsQuery, filter) {\n        return this._getByTags(this.meshes, tagsQuery, filter);\n    }\n    /**\n     * Get a list of cameras by tags\n     * @param tagsQuery defines the tags query to use\n     * @param filter defines a predicate used to filter results\n     * @returns an array of Camera\n     */\n    getCamerasByTags(tagsQuery, filter) {\n        return this._getByTags(this.cameras, tagsQuery, filter);\n    }\n    /**\n     * Get a list of lights by tags\n     * @param tagsQuery defines the tags query to use\n     * @param filter defines a predicate used to filter results\n     * @returns an array of Light\n     */\n    getLightsByTags(tagsQuery, filter) {\n        return this._getByTags(this.lights, tagsQuery, filter);\n    }\n    /**\n     * Get a list of materials by tags\n     * @param tagsQuery defines the tags query to use\n     * @param filter defines a predicate used to filter results\n     * @returns an array of Material\n     */\n    getMaterialByTags(tagsQuery, filter) {\n        return this._getByTags(this.materials, tagsQuery, filter).concat(this._getByTags(this.multiMaterials, tagsQuery, filter));\n    }\n    /**\n     * Get a list of transform nodes by tags\n     * @param tagsQuery defines the tags query to use\n     * @param filter defines a predicate used to filter results\n     * @returns an array of TransformNode\n     */\n    getTransformNodesByTags(tagsQuery, filter) {\n        return this._getByTags(this.transformNodes, tagsQuery, filter);\n    }\n    /**\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\n     * This allowed control for front to back rendering or reversly depending of the special needs.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n     */\n    setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {\n        this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\n    }\n    /**\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\n     */\n    setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth = true, stencil = true) {\n        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);\n    }\n    /**\n     * Gets the current auto clear configuration for one rendering group of the rendering\n     * manager.\n     * @param index the rendering group index to get the information for\n     * @returns The auto clear setup for the requested rendering group\n     */\n    getAutoClearDepthStencilSetup(index) {\n        return this._renderingManager.getAutoClearDepthStencilSetup(index);\n    }\n    /** @internal */\n    _forceBlockMaterialDirtyMechanism(value) {\n        this._blockMaterialDirtyMechanism = value;\n    }\n    /** Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync) */\n    get blockMaterialDirtyMechanism() {\n        return this._blockMaterialDirtyMechanism;\n    }\n    set blockMaterialDirtyMechanism(value) {\n        if (this._blockMaterialDirtyMechanism === value) {\n            return;\n        }\n        this._blockMaterialDirtyMechanism = value;\n        if (!value) {\n            // Do a complete update\n            this.markAllMaterialsAsDirty(63);\n        }\n    }\n    /**\n     * Will flag all materials as dirty to trigger new shader compilation\n     * @param flag defines the flag used to specify which material part must be marked as dirty\n     * @param predicate If not null, it will be used to specify if a material has to be marked as dirty\n     */\n    markAllMaterialsAsDirty(flag, predicate) {\n        if (this._blockMaterialDirtyMechanism) {\n            return;\n        }\n        for (const material of this.materials) {\n            if (predicate && !predicate(material)) {\n                continue;\n            }\n            material.markAsDirty(flag);\n        }\n    }\n    /**\n     * @internal\n     */\n    _loadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {\n        const request = LoadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n        this._activeRequests.push(request);\n        request.onCompleteObservable.add((request) => {\n            this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\n        });\n        return request;\n    }\n    /**\n     * @internal\n     */\n    _loadFileAsync(fileOrUrl, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {\n        return new Promise((resolve, reject) => {\n            this._loadFile(fileOrUrl, (data) => {\n                resolve(data);\n            }, onProgress, useOfflineSupport, useArrayBuffer, (request, exception) => {\n                reject(exception);\n            }, onOpened);\n        });\n    }\n    /**\n     * @internal\n     */\n    _requestFile(url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {\n        const request = RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n        this._activeRequests.push(request);\n        request.onCompleteObservable.add((request) => {\n            this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\n        });\n        return request;\n    }\n    /**\n     * @internal\n     */\n    _requestFileAsync(url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {\n        return new Promise((resolve, reject) => {\n            this._requestFile(url, (data) => {\n                resolve(data);\n            }, onProgress, useOfflineSupport, useArrayBuffer, (error) => {\n                reject(error);\n            }, onOpened);\n        });\n    }\n    /**\n     * @internal\n     */\n    _readFile(file, onSuccess, onProgress, useArrayBuffer, onError) {\n        const request = ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);\n        this._activeRequests.push(request);\n        request.onCompleteObservable.add((request) => {\n            this._activeRequests.splice(this._activeRequests.indexOf(request), 1);\n        });\n        return request;\n    }\n    /**\n     * @internal\n     */\n    _readFileAsync(file, onProgress, useArrayBuffer) {\n        return new Promise((resolve, reject) => {\n            this._readFile(file, (data) => {\n                resolve(data);\n            }, onProgress, useArrayBuffer, (error) => {\n                reject(error);\n            });\n        });\n    }\n    // eslint-disable-next-line jsdoc/require-returns-check\n    /**\n     * This method gets the performance collector belonging to the scene, which is generally shared with the inspector.\n     * @returns the perf collector belonging to the scene.\n     */\n    getPerfCollector() {\n        throw _WarnImport(\"performanceViewerSceneExtension\");\n    }\n    // deprecated\n    /**\n     * Sets the active camera of the scene using its Id\n     * @param id defines the camera's Id\n     * @returns the new active camera or null if none found.\n     * @deprecated Please use setActiveCameraById instead\n     */\n    setActiveCameraByID(id) {\n        return this.setActiveCameraById(id);\n    }\n    /**\n     * Get a material using its id\n     * @param id defines the material's Id\n     * @returns the material or null if none found.\n     * @deprecated Please use getMaterialById instead\n     */\n    getMaterialByID(id) {\n        return this.getMaterialById(id);\n    }\n    /**\n     * Gets a the last added material using a given id\n     * @param id defines the material's Id\n     * @returns the last material with the given id or null if none found.\n     * @deprecated Please use getLastMaterialById instead\n     */\n    getLastMaterialByID(id) {\n        return this.getLastMaterialById(id);\n    }\n    /**\n     * Get a texture using its unique id\n     * @param uniqueId defines the texture's unique id\n     * @returns the texture or null if none found.\n     * @deprecated Please use getTextureByUniqueId instead\n     */\n    getTextureByUniqueID(uniqueId) {\n        return this.getTextureByUniqueId(uniqueId);\n    }\n    /**\n     * Gets a camera using its Id\n     * @param id defines the Id to look for\n     * @returns the camera or null if not found\n     * @deprecated Please use getCameraById instead\n     */\n    getCameraByID(id) {\n        return this.getCameraById(id);\n    }\n    /**\n     * Gets a camera using its unique Id\n     * @param uniqueId defines the unique Id to look for\n     * @returns the camera or null if not found\n     * @deprecated Please use getCameraByUniqueId instead\n     */\n    getCameraByUniqueID(uniqueId) {\n        return this.getCameraByUniqueId(uniqueId);\n    }\n    /**\n     * Gets a bone using its Id\n     * @param id defines the bone's Id\n     * @returns the bone or null if not found\n     * @deprecated Please use getBoneById instead\n     */\n    getBoneByID(id) {\n        return this.getBoneById(id);\n    }\n    /**\n     * Gets a light node using its Id\n     * @param id defines the light's Id\n     * @returns the light or null if none found.\n     * @deprecated Please use getLightById instead\n     */\n    getLightByID(id) {\n        return this.getLightById(id);\n    }\n    /**\n     * Gets a light node using its scene-generated unique Id\n     * @param uniqueId defines the light's unique Id\n     * @returns the light or null if none found.\n     * @deprecated Please use getLightByUniqueId instead\n     */\n    getLightByUniqueID(uniqueId) {\n        return this.getLightByUniqueId(uniqueId);\n    }\n    /**\n     * Gets a particle system by Id\n     * @param id defines the particle system Id\n     * @returns the corresponding system or null if none found\n     * @deprecated Please use getParticleSystemById instead\n     */\n    getParticleSystemByID(id) {\n        return this.getParticleSystemById(id);\n    }\n    /**\n     * Gets a geometry using its Id\n     * @param id defines the geometry's Id\n     * @returns the geometry or null if none found.\n     * @deprecated Please use getGeometryById instead\n     */\n    getGeometryByID(id) {\n        return this.getGeometryById(id);\n    }\n    /**\n     * Gets the first added mesh found of a given Id\n     * @param id defines the Id to search for\n     * @returns the mesh found or null if not found at all\n     * @deprecated Please use getMeshById instead\n     */\n    getMeshByID(id) {\n        return this.getMeshById(id);\n    }\n    /**\n     * Gets a mesh with its auto-generated unique Id\n     * @param uniqueId defines the unique Id to search for\n     * @returns the found mesh or null if not found at all.\n     * @deprecated Please use getMeshByUniqueId instead\n     */\n    getMeshByUniqueID(uniqueId) {\n        return this.getMeshByUniqueId(uniqueId);\n    }\n    /**\n     * Gets a the last added mesh using a given Id\n     * @param id defines the Id to search for\n     * @returns the found mesh or null if not found at all.\n     * @deprecated Please use getLastMeshById instead\n     */\n    getLastMeshByID(id) {\n        return this.getLastMeshById(id);\n    }\n    /**\n     * Gets a list of meshes using their Id\n     * @param id defines the Id to search for\n     * @returns a list of meshes\n     * @deprecated Please use getMeshesById instead\n     */\n    getMeshesByID(id) {\n        return this.getMeshesById(id);\n    }\n    /**\n     * Gets the first added transform node found of a given Id\n     * @param id defines the Id to search for\n     * @returns the found transform node or null if not found at all.\n     * @deprecated Please use getTransformNodeById instead\n     */\n    getTransformNodeByID(id) {\n        return this.getTransformNodeById(id);\n    }\n    /**\n     * Gets a transform node with its auto-generated unique Id\n     * @param uniqueId defines the unique Id to search for\n     * @returns the found transform node or null if not found at all.\n     * @deprecated Please use getTransformNodeByUniqueId instead\n     */\n    getTransformNodeByUniqueID(uniqueId) {\n        return this.getTransformNodeByUniqueId(uniqueId);\n    }\n    /**\n     * Gets a list of transform nodes using their Id\n     * @param id defines the Id to search for\n     * @returns a list of transform nodes\n     * @deprecated Please use getTransformNodesById instead\n     */\n    getTransformNodesByID(id) {\n        return this.getTransformNodesById(id);\n    }\n    /**\n     * Gets a node (Mesh, Camera, Light) using a given Id\n     * @param id defines the Id to search for\n     * @returns the found node or null if not found at all\n     * @deprecated Please use getNodeById instead\n     */\n    getNodeByID(id) {\n        return this.getNodeById(id);\n    }\n    /**\n     * Gets a the last added node (Mesh, Camera, Light) using a given Id\n     * @param id defines the Id to search for\n     * @returns the found node or null if not found at all\n     * @deprecated Please use getLastEntryById instead\n     */\n    getLastEntryByID(id) {\n        return this.getLastEntryById(id);\n    }\n    /**\n     * Gets a skeleton using a given Id (if many are found, this function will pick the last one)\n     * @param id defines the Id to search for\n     * @returns the found skeleton or null if not found at all.\n     * @deprecated Please use getLastSkeletonById instead\n     */\n    getLastSkeletonByID(id) {\n        return this.getLastSkeletonById(id);\n    }\n}\n/** The fog is deactivated */\nScene.FOGMODE_NONE = 0;\n/** The fog density is following an exponential function */\nScene.FOGMODE_EXP = 1;\n/** The fog density is following an exponential function faster than FOGMODE_EXP */\nScene.FOGMODE_EXP2 = 2;\n/** The fog density is following a linear function. */\nScene.FOGMODE_LINEAR = 3;\n/**\n * Gets or sets the minimum deltatime when deterministic lock step is enabled\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n */\nScene.MinDeltaTime = 1.0;\n/**\n * Gets or sets the maximum deltatime when deterministic lock step is enabled\n * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n */\nScene.MaxDeltaTime = 1000.0;\n// Register Class Name\nRegisterClass(\"BABYLON.Scene\", Scene);\n//# sourceMappingURL=scene.js.map"],"names":["ScenePerformancePriority","Scene","DefaultMaterialFactory","scene","CollisionCoordinatorFactory","clearColor","this","_clearColor","value","onClearColorChangedObservable","notifyObservers","imageProcessingConfiguration","_imageProcessingConfiguration","performancePriority","_performancePriority","skipFrustumClipping","_renderingManager","maintainStateBetweenFrames","skipPointerMovePicking","autoClear","onScenePerformancePriorityChangedObservable","forceWireframe","_forceWireframe","markAllMaterialsAsDirty","_skipFrustumClipping","forcePointsCloud","_forcePointsCloud","environmentTexture","_environmentTexture","onEnvironmentTextureChangedObservable","getNodes","nodes","concat","meshes","lights","cameras","transformNodes","skeletons","forEach","skeleton","bones","animationPropertiesOverride","_animationPropertiesOverride","onDispose","callback","_onDisposeObserver","onDisposeObservable","remove","add","beforeRender","_onBeforeRenderObserver","onBeforeRenderObservable","afterRender","_onAfterRenderObserver","onAfterRenderObservable","beforeCameraRender","_onBeforeCameraRenderObserver","onBeforeCameraRenderObservable","afterCameraRender","_onAfterCameraRenderObserver","onAfterCameraRenderObservable","pointerDownPredicate","_pointerPickingConfiguration","pointerUpPredicate","pointerMovePredicate","pointerDownFastCheck","pointerUpFastCheck","pointerMoveFastCheck","skipPointerDownPicking","skipPointerUpPicking","unTranslatedPointer","_inputManager","DragMovementThreshold","LongPressDelay","DoubleClickDelay","ExclusiveDoubleClickMode","bindEyePosition","effect","variableName","isVector3","eyePosition","_forcedViewPosition","_mirroredCameraPosition","activeCamera","globalPosition","ZeroReadOnly","invertNormal","useRightHandedSystem","Vector4","set","x","y","z","setFloat3","setVector4","finalizeSceneUbo","ubo","getSceneUniformBuffer","updateFloat4","w","update","_useRightHandedSystem","setStepId","newStepId","_currentStepId","getStepId","getInternalStep","_currentInternalStep","fogEnabled","_fogEnabled","fogMode","_fogMode","prePass","prePassRenderer","defaultRT","enabled","shadowsEnabled","_shadowsEnabled","lightsEnabled","_lightsEnabled","activeCameras","_activeCameras","_unObserveActiveCameras","onActiveCamerasChanged","_activeCamera","onActiveCameraChanged","defaultMaterial","_defaultMaterial","texturesEnabled","_texturesEnabled","frameGraph","_frameGraph","customRenderFunction","_currentCustomRenderFunction","_renderWithFrameGraph","skeletonsEnabled","_skeletonsEnabled","collisionCoordinator","_collisionCoordinator","init","renderingManager","frustumPlanes","_frustumPlanes","_registerTransientComponents","_transientComponents","length","component","register","_addComponent","_components","push","serializableComponent","addFromContainer","serialize","_serializableComponents","_getComponent","name","constructor","engine","options","cameraToUseForPointers","_isScene","_blockEntityCollection","autoClearDepthAndStencil","ambientColor","environmentIntensity","rootNodes","particleSystems","animations","animationGroups","multiMaterials","materials","morphTargetManagers","geometries","actionManagers","textures","postProcesses","effectLayers","sounds","layers","lensFlareSystems","proceduralTextures","animationsEnabled","useConstantAnimationDeltaTime","constantlyUpdateMeshUnderPointer","hoverCursor","defaultCursor","doNotHandleCursors","preventDefaultOnPointerDown","preventDefaultOnPointerUp","metadata","reservedDataStore","disableOfflineSupportExceptionRules","onAfterRenderCameraObservable","onBeforeAnimationsObservable","onAfterAnimationsObservable","onBeforeDrawPhaseObservable","onAfterDrawPhaseObservable","onReadyObservable","onBeforeActiveMeshesEvaluationObservable","onAfterActiveMeshesEvaluationObservable","onBeforeParticlesRenderingObservable","onAfterParticlesRenderingObservable","onDataLoadedObservable","onNewCameraAddedObservable","onCameraRemovedObservable","onNewLightAddedObservable","onLightRemovedObservable","onNewGeometryAddedObservable","onGeometryRemovedObservable","onNewTransformNodeAddedObservable","onTransformNodeRemovedObservable","onNewMeshAddedObservable","onMeshRemovedObservable","onNewSkeletonAddedObservable","onSkeletonRemovedObservable","onNewMaterialAddedObservable","onNewMultiMaterialAddedObservable","onMaterialRemovedObservable","onMultiMaterialRemovedObservable","onNewTextureAddedObservable","onTextureRemovedObservable","onBeforeRenderTargetsRenderObservable","onAfterRenderTargetsRenderObservable","onBeforeStepObservable","onAfterStepObservable","onBeforeRenderingGroupObservable","onAfterRenderingGroupObservable","onMeshImportedObservable","onAnimationFileImportedObservable","onMeshUnderPointerUpdatedObservable","_registeredForLateAnimationBindings","onPrePointerObservable","onPointerObservable","onPreKeyboardObservable","onKeyboardObservable","_timeAccumulator","FOGMODE_NONE","fogColor","fogDensity","fogStart","fogEnd","needsPreviousWorldMatrices","physicsEnabled","particlesEnabled","spritesEnabled","lensFlaresEnabled","collisionsEnabled","gravity","postProcessesEnabled","renderTargetsEnabled","dumpNextRenderTargets","customRenderTargets","importedMeshesFiles","probesEnabled","_meshesForIntersections","proceduralTexturesEnabled","_totalVertices","_activeIndices","_activeParticles","_activeBones","_animationTime","animationTimeScale","_renderId","_frameId","_executeWhenReadyTimeoutId","_intermediateRendering","_defaultFrameBufferCleared","_viewUpdateFlag","_projectionUpdateFlag","_toBeDisposed","Array","_activeRequests","_pendingData","_isDisposed","dispatchAllSubMeshesOfActiveMeshes","_activeMeshes","_processedMaterials","_renderTargets","_materialsRenderTargets","_activeParticleSystems","_activeSkeletons","_softwareSkinnedMeshes","_activeAnimatables","_transformMatrix","Zero","requireLightSorting","_beforeCameraUpdateStage","Create","_beforeClearStage","_beforeRenderTargetClearStage","_gatherRenderTargetsStage","_gatherActiveCameraRenderTargetsStage","_isReadyForMeshStage","_beforeEvaluateActiveMeshStage","_evaluateSubMeshStage","_preActiveMeshStage","_cameraDrawRenderTargetStage","_beforeCameraDrawStage","_beforeRenderTargetDrawStage","_beforeRenderingGroupDrawStage","_beforeRenderingMeshStage","_afterRenderingMeshStage","_afterRenderingGroupDrawStage","_afterCameraDrawStage","_afterCameraPostProcessStage","_afterRenderTargetDrawStage","_afterRenderTargetPostProcessStage","_afterRenderStage","_pointerMoveStage","_pointerDownStage","_pointerUpStage","_geometriesByUniqueId","_defaultMeshCandidates","data","_defaultSubMeshCandidates","_preventFreeActiveMeshesAndRenderingGroups","_activeMeshesFrozen","_activeMeshesFrozenButKeepClipping","_skipEvaluateActiveMeshesCompletely","_allowPostProcessClearColor","getDeterministicFrameTime","_engine","getTimeStep","_registeredActions","_blockMaterialDirtyMechanism","_perfCollector","fullOptions","useGeometryUniqueIdsMap","useMaterialMeshMap","useClonedMeshMap","virtual","LastCreatedEngine","_virtualScenes","_LastCreatedScene","scenes","_uid","postProcessManager","attachControl","_createUbo","setDefaultCandidateProviders","onNewSceneAddedObservable","getClassName","_getDefaultMeshCandidates","_getDefaultSubMeshCandidates","mesh","subMeshes","getActiveMeshCandidates","getActiveSubMeshCandidates","getIntersectingSubMeshCandidates","localRay","getCollidingSubMeshCandidates","collider","meshUnderPointer","pointerX","pointerY","getCachedMaterial","_cachedMaterial","getCachedEffect","_cachedEffect","getCachedVisibility","_cachedVisibility","isCachedMaterialInvalid","material","visibility","getEngine","getTotalVertices","current","totalVerticesPerfCounter","getActiveIndices","totalActiveIndicesPerfCounter","getActiveParticles","activeParticlesPerfCounter","getActiveBones","activeBonesPerfCounter","getActiveMeshes","getAnimationRatio","undefined","_animationRatio","getRenderId","getFrameId","incrementRenderId","setSceneUniformBuffer","createSceneUniformBuffer","simulatePointerMove","pickResult","pointerEventInit","simulatePointerDown","simulatePointerUp","doubleTap","isPointerCaptured","pointerId","attachUp","attachDown","attachMove","detachControl","isReady","checkRenderTargets","index","currentRenderPassId","renderPassId","useOrderIndependentTransparency","depthPeelingRenderer","reset","hardwareInstancedRendering","hasThinInstances","getCaps","instancedArrays","instances","step","action","mat","_storeEffectOnSubMeshes","subMesh","getMaterial","hasRenderTargetTextures","getRenderTargetTextures","indexOf","concatWithNoDuplicate","isReadyForRendering","delayLoadState","camera","particleSystem","layer","areAllEffectsReady","resetCachedMaterial","registerBeforeRender","func","unregisterBeforeRender","removeCallback","registerAfterRender","unregisterAfterRender","_executeOnceBeforeRender","execFunc","setTimeout","executeOnceBeforeRender","timeout","addPendingData","removePendingData","wasLoading","isLoading","splice","getWaitingItemsCount","executeWhenReady","addOnce","_checkIsReady","whenReadyAsync","Promise","resolve","clear","animatables","resetLastAnimationTimeFrame","_animationTimeLast","Now","getViewMatrix","_viewMatrix","getProjectionMatrix","_projectionMatrix","getTransformMatrix","setTransformMatrix","viewL","projectionL","viewR","projectionR","_multiviewSceneUbo","dispose","updateFlag","multiplyToRef","GetPlanesToRef","GetPlanes","useUbo","_updateMultiviewUbo","_sceneUbo","updateMatrix","sceneUbo","addUniform","getUniqueId","UniqueId","addMesh","newMesh","recursive","_resyncLightSources","parent","_addToSceneRootNodes","SetImmediate","getChildMeshes","m","removeMesh","toRemove","_removeFromSceneRootNodes","_invalidateMesh","addTransformNode","newTransformNode","getScene","_indexInSceneTransformNodesArray","removeTransformNode","lastNode","pop","removeSkeleton","_executeActiveContainerCleanup","removeMorphTargetManager","removeLight","_removeLightSource","sortLightsByPriority","removeCamera","index2","removeParticleSystem","removeAnimation","stopAnimation","target","animationName","targetMask","removeAnimationGroup","removeMultiMaterial","removeMaterial","_indexInSceneMaterialArray","lastMaterial","removeActionManager","removeTexture","addLight","newLight","lightSources","sort","CompareLightsPriority","addCamera","newCamera","addSkeleton","newSkeleton","addParticleSystem","newParticleSystem","addAnimation","newAnimation","addAnimationGroup","newAnimationGroup","addMultiMaterial","newMultiMaterial","addMaterial","newMaterial","addMorphTargetManager","newMorphTargetManager","addGeometry","newGeometry","uniqueId","addActionManager","newActionManager","addTexture","newTexture","switchActiveCamera","getInputElement","setActiveCameraById","id","getCameraById","setActiveCameraByName","getCameraByName","getAnimationGroupByName","_getMaterial","allowMultiMaterials","predicate","getMaterialByUniqueID","getMaterialById","getMaterialByName","getLastMaterialById","getTextureByUniqueId","getTextureByName","getCameraByUniqueId","getBoneById","skeletonIndex","boneIndex","getBoneByName","getLightByName","getLightById","getLightByUniqueId","getParticleSystemById","getGeometryById","_getGeometryByUniqueId","pushGeometry","geometry","force","removeGeometry","lastGeometry","getGeometries","getMeshById","getMeshesById","filter","getTransformNodeById","getTransformNodeByUniqueId","getTransformNodesById","getMeshByUniqueId","getLastMeshById","getLastTransformNodeById","getLastEntryById","getNodeById","transformNode","light","bone","getNodeByName","getMeshByName","getTransformNodeByName","getLastSkeletonById","getSkeletonByUniqueId","getSkeletonById","getSkeletonByName","getMorphTargetManagerById","getMorphTargetById","managerIndex","morphTargetManager","numTargets","getTarget","getMorphTargetByName","getPostProcessByName","postProcessIndex","postProcess","isActiveMesh","uid","RandomId","addExternalData","key","_externalData","getExternalData","get","getOrAddExternalDataWithFactory","factory","getOrAddWithFactory","removeExternalData","_evaluateSubMesh","initialMesh","forcePush","isInFrustum","dispatch","freeProcessedMaterials","blockfreeActiveMeshesAndRenderingGroups","freeActiveMeshes","freeRenderingGroups","i","texture","renderList","_isInIntermediateRendering","freezeActiveMeshes","skipEvaluateActiveMeshes","onSuccess","onError","freezeMeshes","keepFrustumCulling","updateTransformMatrix","_evaluateActiveMeshes","_freeze","unfreezeActiveMeshes","_internalAbstractMeshDataInfo","_isActive","_unFreeze","container","snapshotRendering","snapshotRenderingMode","len","computeWorldMatrix","psLength","animate","resetSprites","_currentLODIsUpToDate","isBlocked","addCount","isEnabled","scaling","hasAZeroComponent","actionManager","hasSpecificTriggers2","pushNoDuplicate","meshToRender","customLODSelector","getLOD","_currentLOD","billboardMode","_preActivate","isVisible","layerMask","alwaysSelectAsActiveMesh","_activate","isAnInstance","_actAsRegularMesh","_onlyForInstances","_activeMesh","_postActivate","particleIndex","isStarted","emitter","position","dispatchParticles","_prepareSkeleton","prepare","computeBonesUsingShaders","applySkeleton","sourceMesh","hasInstances","_renderingMultiview","leftCamera","_rigCameras","rightCamera","_bindFrameBuffer","_multiviewTexture","outputRenderTarget","_currentFrameBufferIsDefaultFrameBuffer","restoreDefaultFramebuffer","_clearFrameBuffer","rtt","onClearObservable","hasObservers","skipInitialClear","isRightCamera","_cleared","_clear","_renderForCamera","rigParent","bindFrameBuffer","_skipRendering","Error","setViewport","viewport","softwareSkinnedMeshIndex","isRenderTarget","needRebind","StartPerformanceCounter","renderIndex","renderTarget","_shouldRender","hasSpecialRenderTargetCamera","render","EndPerformanceCounter","_prepareFrame","_finalizeFrame","isIntermediate","_processSubCameras","cameraRigMode","_createMultiviewUbo","_useMultiviewToSingleView","_renderMultiviewToSingleView","_checkIntersections","actionIndex","actions","trigger","parameters","getTriggerParameter","otherMesh","areIntersecting","intersectsMesh","usePreciseIntersection","currentIntersectionInProgress","_intersectionsInProgress","_executeCurrent","CreateNew","hasSpecificTrigger","parameter","parameterMesh","_advancePhysicsEngineStep","_animate","customDeltaTime","isDeterministicLockStep","deltaTime","Math","max","MinDeltaTime","min","getDeltaTime","MaxDeltaTime","defaultFrameTime","defaultFPS","stepsTaken","maxSubSteps","getLockstepMaxSteps","internalSteps","floor","_checkCameraRenderTarget","isRigCamera","rigCameras","resetDrawCache","passId","updateCameras","ignoreAnimations","execute","isDisposed","fetchNewFrame","processTrigger","cameraIndex","currentActiveCamera","customIndex","freezeMaterials","freeze","unfreezeMaterials","unfreeze","stopAllAnimations","animatable","onAnimationEndObservable","onAnimationEnd","activeRequests","slice","request","abort","e","_disposeList","item","wipeCaches","items","itemsCopy","clearCachedVertexData","meshIndex","clearCachedData","cleanCachedTextureBuffer","baseTexture","_buffer","getWorldExtends","filterPredicate","Number","MAX_VALUE","infiniteDistance","boundingInfo","getBoundingInfo","minBox","boundingBox","minimumWorld","maxBox","maximumWorld","CheckExtends","createPickingRay","world","cameraViewSpace","createPickingRayToRef","result","enableDistantPicking","createPickingRayInCameraSpace","createPickingRayInCameraSpaceToRef","pick","fastCheck","trianglePredicate","warn","Warn","pickWithBoundingInfo","pickWithRay","ray","multiPick","multiPickWithRay","setPointerOverMesh","getPointerOverMesh","_rebuildGeometries","_rebuild","rebuild","system","spriteManagers","spriteMgr","_rebuildTextures","_getByTags","list","tagsQuery","listByTags","MatchesQuery","getMeshesByTags","getCamerasByTags","getLightsByTags","getMaterialByTags","getTransformNodesByTags","setRenderingOrder","renderingGroupId","opaqueSortCompareFn","alphaTestSortCompareFn","transparentSortCompareFn","setRenderingAutoClearDepthStencil","autoClearDepthStencil","depth","stencil","getAutoClearDepthStencilSetup","_forceBlockMaterialDirtyMechanism","blockMaterialDirtyMechanism","flag","markAsDirty","_loadFile","fileOrUrl","onProgress","useOfflineSupport","useArrayBuffer","onOpened","offlineProvider","onCompleteObservable","_loadFileAsync","reject","exception","_requestFile","url","_requestFileAsync","error","_readFile","file","_readFileAsync","getPerfCollector","setActiveCameraByID","getMaterialByID","getLastMaterialByID","getTextureByUniqueID","getCameraByID","getCameraByUniqueID","getBoneByID","getLightByID","getLightByUniqueID","getParticleSystemByID","getGeometryByID","getMeshByID","getMeshByUniqueID","getLastMeshByID","getMeshesByID","getTransformNodeByID","getTransformNodeByUniqueID","getTransformNodesByID","getNodeByID","getLastEntryByID","getLastSkeletonByID","FOGMODE_EXP","FOGMODE_EXP2","FOGMODE_LINEAR"],"sourceRoot":""}