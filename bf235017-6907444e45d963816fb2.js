"use strict";(self.webpackChunk_react_babylonjs_docs=self.webpackChunk_react_babylonjs_docs||[]).push([[309],{84562:function(t,e,r){r.d(e,{FM:function(){return _},Lt:function(){return u},P:function(){return l},_f:function(){return y},jp:function(){return R},y3:function(){return m}});var s=r(61287),i=r(41306),o=r(72209),n=r(46275),a=r(47736),h=r(38962);const c=t=>parseInt(t.toString().replace(/\W/g,""));class _{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=t,this.y=e}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let t=c(this.x);return t=397*t^c(this.y),t}toArray(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[e]=this.x,t[e+1]=this.y,this}fromArray(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return _.FromArrayToRef(t,e,this),this}asArray(){const t=new Array;return this.toArray(t,0),t}copyFrom(t){return this.x=t.x,this.y=t.y,this}copyFromFloats(t,e){return this.x=t,this.y=e,this}set(t,e){return this.copyFromFloats(t,e)}add(t){return new this.constructor(this.x+t.x,this.y+t.y)}addToRef(t,e){return e.x=this.x+t.x,e.y=this.y+t.y,e}addInPlace(t){return this.x+=t.x,this.y+=t.y,this}addVector3(t){return new this.constructor(this.x+t.x,this.y+t.y)}subtract(t){return new this.constructor(this.x-t.x,this.y-t.y)}subtractToRef(t,e){return e.x=this.x-t.x,e.y=this.y-t.y,e}subtractInPlace(t){return this.x-=t.x,this.y-=t.y,this}multiplyInPlace(t){return this.x*=t.x,this.y*=t.y,this}multiply(t){return new this.constructor(this.x*t.x,this.y*t.y)}multiplyToRef(t,e){return e.x=this.x*t.x,e.y=this.y*t.y,e}multiplyByFloats(t,e){return new this.constructor(this.x*t,this.y*e)}divide(t){return new this.constructor(this.x/t.x,this.y/t.y)}divideToRef(t,e){return e.x=this.x/t.x,e.y=this.y/t.y,e}divideInPlace(t){return this.divideToRef(t,this)}negate(){return new this.constructor(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(t){return t.copyFromFloats(-1*this.x,-1*this.y)}scaleInPlace(t){return this.x*=t,this.y*=t,this}scale(t){const e=new this.constructor(0,0);return this.scaleToRef(t,e),e}scaleToRef(t,e){return e.x=this.x*t,e.y=this.y*t,e}scaleAndAddToRef(t,e){return e.x+=this.x*t,e.y+=this.y*t,e}equals(t){return t&&this.x===t.x&&this.y===t.y}equalsWithEpsilon(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:i.kn;return t&&s.R.WithinEpsilon(this.x,t.x,e)&&s.R.WithinEpsilon(this.y,t.y,e)}floor(){return new this.constructor(Math.floor(this.x),Math.floor(this.y))}fract(){return new this.constructor(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}rotateToRef(t,e){const r=Math.cos(t),s=Math.sin(t),i=r*this.x-s*this.y,o=s*this.x+r*this.y;return e.x=i,e.y=o,e}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return _.NormalizeToRef(this,this),this}clone(){return new this.constructor(this.x,this.y)}static Zero(){return new _(0,0)}static One(){return new _(1,1)}static Random(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new _(s.R.RandomRange(t,e),s.R.RandomRange(t,e))}static get ZeroReadOnly(){return _._ZeroReadOnly}static FromArray(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new _(t[e],t[e+1])}static FromArrayToRef(t,e,r){return r.x=t[e],r.y=t[e+1],r}static CatmullRom(t,e,r,s,i){const o=i*i,n=i*o,a=.5*(2*e.x+(-t.x+r.x)*i+(2*t.x-5*e.x+4*r.x-s.x)*o+(-t.x+3*e.x-3*r.x+s.x)*n),h=.5*(2*e.y+(-t.y+r.y)*i+(2*t.y-5*e.y+4*r.y-s.y)*o+(-t.y+3*e.y-3*r.y+s.y)*n);return new t.constructor(a,h)}static Clamp(t,e,r){let s=t.x;s=s>r.x?r.x:s,s=s<e.x?e.x:s;let i=t.y;return i=i>r.y?r.y:i,i=i<e.y?e.y:i,new t.constructor(s,i)}static Hermite(t,e,r,s,i){const o=i*i,n=i*o,a=2*n-3*o+1,h=-2*n+3*o,c=n-2*o+i,_=n-o,l=t.x*a+r.x*h+e.x*c+s.x*_,u=t.y*a+r.y*h+e.y*c+s.y*_;return new t.constructor(l,u)}static Hermite1stDerivative(t,e,r,s,i){const o=new t.constructor;return this.Hermite1stDerivativeToRef(t,e,r,s,i,o),o}static Hermite1stDerivativeToRef(t,e,r,s,i,o){const n=i*i;return o.x=6*(n-i)*t.x+(3*n-4*i+1)*e.x+6*(-n+i)*r.x+(3*n-2*i)*s.x,o.y=6*(n-i)*t.y+(3*n-4*i+1)*e.y+6*(-n+i)*r.y+(3*n-2*i)*s.y,o}static Lerp(t,e,r){const s=t.x+(e.x-t.x)*r,i=t.y+(e.y-t.y)*r;return new t.constructor(s,i)}static Dot(t,e){return t.x*e.x+t.y*e.y}static Normalize(t){const e=new t.constructor;return this.NormalizeToRef(t,e),e}static NormalizeToRef(t,e){const r=t.length();return 0===r||(e.x=t.x/r,e.y=t.y/r),e}static Minimize(t,e){const r=t.x<e.x?t.x:e.x,s=t.y<e.y?t.y:e.y;return new t.constructor(r,s)}static Maximize(t,e){const r=t.x>e.x?t.x:e.x,s=t.y>e.y?t.y:e.y;return new t.constructor(r,s)}static Transform(t,e){const r=new t.constructor;return _.TransformToRef(t,e,r),r}static TransformToRef(t,e,r){const s=e.m,i=t.x*s[0]+t.y*s[4]+s[12],o=t.x*s[1]+t.y*s[5]+s[13];return r.x=i,r.y=o,r}static PointInTriangle(t,e,r,s){const i=.5*(-r.y*s.x+e.y*(-r.x+s.x)+e.x*(r.y-s.y)+r.x*s.y),o=i<0?-1:1,n=(e.y*s.x-e.x*s.y+(s.y-e.y)*t.x+(e.x-s.x)*t.y)*o,a=(e.x*r.y-e.y*r.x+(e.y-r.y)*t.x+(r.x-e.x)*t.y)*o;return n>0&&a>0&&n+a<2*i*o}static Distance(t,e){return Math.sqrt(_.DistanceSquared(t,e))}static DistanceSquared(t,e){const r=t.x-e.x,s=t.y-e.y;return r*r+s*s}static Center(t,e){const r=new t.constructor;return _.CenterToRef(t,e,r)}static CenterToRef(t,e,r){return r.copyFromFloats((t.x+e.x)/2,(t.y+e.y)/2)}static DistanceOfPointFromSegment(t,e,r){const s=_.DistanceSquared(e,r);if(0===s)return _.Distance(t,e);const i=r.subtract(e),o=Math.max(0,Math.min(1,_.Dot(t.subtract(e),i)/s)),n=e.add(i.multiplyByFloats(o,o));return _.Distance(t,n)}}_._ZeroReadOnly=_.Zero();class l{get x(){return this._x}set x(t){this._x=t,this._isDirty=!0}get y(){return this._y}set y(t){this._y=t,this._isDirty=!0}get z(){return this._z}set z(t){this._z=t,this._isDirty=!0}constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=t,this._y=e,this._z=r}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Vector3"}getHashCode(){let t=c(this._x);return t=397*t^c(this._y),t=397*t^c(this._z),t}asArray(){const t=[];return this.toArray(t,0),t}toArray(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,this}fromArray(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l.FromArrayToRef(t,e,this),this}toQuaternion(){return y.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(t){return this.addInPlaceFromFloats(t._x,t._y,t._z)}addInPlaceFromFloats(t,e,r){return this._x+=t,this._y+=e,this._z+=r,this._isDirty=!0,this}add(t){return new this.constructor(this._x+t._x,this._y+t._y,this._z+t._z)}addToRef(t,e){return e.copyFromFloats(this._x+t._x,this._y+t._y,this._z+t._z)}subtractInPlace(t){return this._x-=t._x,this._y-=t._y,this._z-=t._z,this._isDirty=!0,this}subtract(t){return new this.constructor(this._x-t._x,this._y-t._y,this._z-t._z)}subtractToRef(t,e){return this.subtractFromFloatsToRef(t._x,t._y,t._z,e)}subtractFromFloats(t,e,r){return new this.constructor(this._x-t,this._y-e,this._z-r)}subtractFromFloatsToRef(t,e,r,s){return s.copyFromFloats(this._x-t,this._y-e,this._z-r)}negate(){return new this.constructor(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(t){return t.copyFromFloats(-1*this._x,-1*this._y,-1*this._z)}scaleInPlace(t){return this._x*=t,this._y*=t,this._z*=t,this._isDirty=!0,this}scale(t){return new this.constructor(this._x*t,this._y*t,this._z*t)}scaleToRef(t,e){return e.copyFromFloats(this._x*t,this._y*t,this._z*t)}getNormalToRef(t){const e=this.length();let r=Math.acos(this.y/e);const s=Math.atan2(this.z,this.x);r>Math.PI/2?r-=Math.PI/2:r+=Math.PI/2;const i=e*Math.sin(r)*Math.cos(s),o=e*Math.cos(r),n=e*Math.sin(r)*Math.sin(s);return t.set(i,o,n),t}applyRotationQuaternionToRef(t,e){const r=this._x,s=this._y,i=this._z,o=t._x,n=t._y,a=t._z,h=t._w,c=2*(n*i-a*s),_=2*(a*r-o*i),l=2*(o*s-n*r);return e._x=r+h*c+n*l-a*_,e._y=s+h*_+a*c-o*l,e._z=i+h*l+o*_-n*c,e._isDirty=!0,e}applyRotationQuaternionInPlace(t){return this.applyRotationQuaternionToRef(t,this)}applyRotationQuaternion(t){return this.applyRotationQuaternionToRef(t,new this.constructor)}scaleAndAddToRef(t,e){return e.addInPlaceFromFloats(this._x*t,this._y*t,this._z*t)}projectOnPlane(t,e){const r=new this.constructor;return this.projectOnPlaneToRef(t,e,r),r}projectOnPlaneToRef(t,e,r){const s=t.normal,i=t.d,o=x.Vector3[0];this.subtractToRef(e,o),o.normalize();const n=l.Dot(o,s);if(Math.abs(n)<Math.pow(10,-10))r.setAll(1/0);else{const t=-(l.Dot(e,s)+i)/n,a=o.scaleInPlace(t);e.addToRef(a,r)}return r}equals(t){return t&&this._x===t._x&&this._y===t._y&&this._z===t._z}equalsWithEpsilon(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:i.kn;return t&&s.R.WithinEpsilon(this._x,t._x,e)&&s.R.WithinEpsilon(this._y,t._y,e)&&s.R.WithinEpsilon(this._z,t._z,e)}equalsToFloats(t,e,r){return this._x===t&&this._y===e&&this._z===r}multiplyInPlace(t){return this._x*=t._x,this._y*=t._y,this._z*=t._z,this._isDirty=!0,this}multiply(t){return this.multiplyByFloats(t._x,t._y,t._z)}multiplyToRef(t,e){return e.copyFromFloats(this._x*t._x,this._y*t._y,this._z*t._z)}multiplyByFloats(t,e,r){return new this.constructor(this._x*t,this._y*e,this._z*r)}divide(t){return new this.constructor(this._x/t._x,this._y/t._y,this._z/t._z)}divideToRef(t,e){return e.copyFromFloats(this._x/t._x,this._y/t._y,this._z/t._z)}divideInPlace(t){return this.divideToRef(t,this)}minimizeInPlace(t){return this.minimizeInPlaceFromFloats(t._x,t._y,t._z)}maximizeInPlace(t){return this.maximizeInPlaceFromFloats(t._x,t._y,t._z)}minimizeInPlaceFromFloats(t,e,r){return t<this._x&&(this.x=t),e<this._y&&(this.y=e),r<this._z&&(this.z=r),this}maximizeInPlaceFromFloats(t,e,r){return t>this._x&&(this.x=t),e>this._y&&(this.y=e),r>this._z&&(this.z=r),this}isNonUniformWithinEpsilon(t){const e=Math.abs(this._x),r=Math.abs(this._y);if(!s.R.WithinEpsilon(e,r,t))return!0;const i=Math.abs(this._z);return!s.R.WithinEpsilon(e,i,t)||!s.R.WithinEpsilon(r,i,t)}get isNonUniform(){const t=Math.abs(this._x);if(t!==Math.abs(this._y))return!0;return t!==Math.abs(this._z)}floor(){return new this.constructor(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fract(){return new this.constructor(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z==0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(t){return"xyz"===(t=t.toLowerCase())||(x.Vector3[0].copyFrom(this),["x","y","z"].forEach(((e,r)=>{this[e]=x.Vector3[0][t[r]]}))),this}rotateByQuaternionToRef(t,e){return t.toRotationMatrix(x.Matrix[0]),l.TransformCoordinatesToRef(this,x.Matrix[0],e),e}rotateByQuaternionAroundPointToRef(t,e,r){return this.subtractToRef(e,x.Vector3[0]),x.Vector3[0].rotateByQuaternionToRef(t,x.Vector3[0]),e.addToRef(x.Vector3[0],r),r}cross(t){const e=new this.constructor;return l.CrossToRef(this,t,e)}normalizeFromLength(t){return 0===t||1===t?this:this.scaleInPlace(1/t)}normalizeToNew(){const t=new this.constructor(0,0,0);return this.normalizeToRef(t),t}normalizeToRef(t){const e=this.length();return 0===e||1===e?t.copyFromFloats(this._x,this._y,this._z):this.scaleToRef(1/e,t)}clone(){return new this.constructor(this._x,this._y,this._z)}copyFrom(t){return this.copyFromFloats(t._x,t._y,t._z)}copyFromFloats(t,e,r){return this._x=t,this._y=e,this._z=r,this._isDirty=!0,this}set(t,e,r){return this.copyFromFloats(t,e,r)}setAll(t){return this._x=this._y=this._z=t,this._isDirty=!0,this}static GetClipFactor(t,e,r,s){const i=l.Dot(t,r)-s;return i/(i-(l.Dot(e,r)-s))}static GetAngleBetweenVectors(t,e,r){const i=t.normalizeToRef(x.Vector3[1]),o=e.normalizeToRef(x.Vector3[2]);let n=l.Dot(i,o);n=s.R.Clamp(n,-1,1);const a=Math.acos(n),h=x.Vector3[3];return l.CrossToRef(i,o,h),l.Dot(h,r)>0?isNaN(a)?0:a:isNaN(a)?-Math.PI:-Math.acos(n)}static GetAngleBetweenVectorsOnPlane(t,e,r){x.Vector3[0].copyFrom(t);const i=x.Vector3[0];x.Vector3[1].copyFrom(e);const o=x.Vector3[1];x.Vector3[2].copyFrom(r);const n=x.Vector3[2],a=x.Vector3[3],h=x.Vector3[4];i.normalize(),o.normalize(),n.normalize(),l.CrossToRef(n,i,a),l.CrossToRef(a,n,h);const c=Math.atan2(l.Dot(o,a),l.Dot(o,h));return s.R.NormalizeRadians(c)}static PitchYawRollToMoveBetweenPointsToRef(t,e,r){const s=R.Vector3[0];return e.subtractToRef(t,s),r._y=Math.atan2(s.x,s.z)||0,r._x=Math.atan2(Math.sqrt(s.x**2+s.z**2),s.y)||0,r._z=0,r._isDirty=!0,r}static PitchYawRollToMoveBetweenPoints(t,e){const r=l.Zero();return l.PitchYawRollToMoveBetweenPointsToRef(t,e,r)}static SlerpToRef(t,e,r,o){r=s.R.Clamp(r,0,1);const n=x.Vector3[0],a=x.Vector3[1];n.copyFrom(t);const h=n.length();n.normalizeFromLength(h),a.copyFrom(e);const c=a.length();a.normalizeFromLength(c);const _=l.Dot(n,a);let u,y;if(_<1-i.kn){const t=Math.acos(_),e=1/Math.sin(t);u=Math.sin((1-r)*t)*e,y=Math.sin(r*t)*e}else u=1-r,y=r;return n.scaleInPlace(u),a.scaleInPlace(y),o.copyFrom(n).addInPlace(a),o.scaleInPlace(s.R.Lerp(h,c,r)),o}static SmoothToRef(t,e,r,s,i){return l.SlerpToRef(t,e,0===s?1:r/s,i),i}static FromArray(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new l(t[e],t[e+1],t[e+2])}static FromFloatArray(t,e){return l.FromArray(t,e)}static FromArrayToRef(t,e,r){return r._x=t[e],r._y=t[e+1],r._z=t[e+2],r._isDirty=!0,r}static FromFloatArrayToRef(t,e,r){return l.FromArrayToRef(t,e,r)}static FromFloatsToRef(t,e,r,s){return s.copyFromFloats(t,e,r),s}static Zero(){return new l(0,0,0)}static One(){return new l(1,1,1)}static Up(){return new l(0,1,0)}static get UpReadOnly(){return l._UpReadOnly}static get DownReadOnly(){return l._DownReadOnly}static get RightReadOnly(){return l._RightReadOnly}static get LeftReadOnly(){return l._LeftReadOnly}static get LeftHandedForwardReadOnly(){return l._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return l._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return l._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return l._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return l._ZeroReadOnly}static get OneReadOnly(){return l._OneReadOnly}static Down(){return new l(0,-1,0)}static Forward(){return new l(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new l(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new l(1,0,0)}static Left(){return new l(-1,0,0)}static Random(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new l(s.R.RandomRange(t,e),s.R.RandomRange(t,e),s.R.RandomRange(t,e))}static TransformCoordinates(t,e){const r=l.Zero();return l.TransformCoordinatesToRef(t,e,r),r}static TransformCoordinatesToRef(t,e,r){return l.TransformCoordinatesFromFloatsToRef(t._x,t._y,t._z,e,r),r}static TransformCoordinatesFromFloatsToRef(t,e,r,s,i){const o=s.m,n=t*o[0]+e*o[4]+r*o[8]+o[12],a=t*o[1]+e*o[5]+r*o[9]+o[13],h=t*o[2]+e*o[6]+r*o[10]+o[14],c=1/(t*o[3]+e*o[7]+r*o[11]+o[15]);return i._x=n*c,i._y=a*c,i._z=h*c,i._isDirty=!0,i}static TransformNormal(t,e){const r=l.Zero();return l.TransformNormalToRef(t,e,r),r}static TransformNormalToRef(t,e,r){return this.TransformNormalFromFloatsToRef(t._x,t._y,t._z,e,r),r}static TransformNormalFromFloatsToRef(t,e,r,s,i){const o=s.m;return i._x=t*o[0]+e*o[4]+r*o[8],i._y=t*o[1]+e*o[5]+r*o[9],i._z=t*o[2]+e*o[6]+r*o[10],i._isDirty=!0,i}static CatmullRom(t,e,r,s,i){const o=i*i,n=i*o,a=.5*(2*e._x+(-t._x+r._x)*i+(2*t._x-5*e._x+4*r._x-s._x)*o+(-t._x+3*e._x-3*r._x+s._x)*n),h=.5*(2*e._y+(-t._y+r._y)*i+(2*t._y-5*e._y+4*r._y-s._y)*o+(-t._y+3*e._y-3*r._y+s._y)*n),c=.5*(2*e._z+(-t._z+r._z)*i+(2*t._z-5*e._z+4*r._z-s._z)*o+(-t._z+3*e._z-3*r._z+s._z)*n);return new t.constructor(a,h,c)}static Clamp(t,e,r){const s=new t.constructor;return l.ClampToRef(t,e,r,s),s}static ClampToRef(t,e,r,s){let i=t._x;i=i>r._x?r._x:i,i=i<e._x?e._x:i;let o=t._y;o=o>r._y?r._y:o,o=o<e._y?e._y:o;let n=t._z;return n=n>r._z?r._z:n,n=n<e._z?e._z:n,s.copyFromFloats(i,o,n),s}static CheckExtends(t,e,r){e.minimizeInPlace(t),r.maximizeInPlace(t)}static Hermite(t,e,r,s,i){const o=i*i,n=i*o,a=2*n-3*o+1,h=-2*n+3*o,c=n-2*o+i,_=n-o,l=t._x*a+r._x*h+e._x*c+s._x*_,u=t._y*a+r._y*h+e._y*c+s._y*_,y=t._z*a+r._z*h+e._z*c+s._z*_;return new t.constructor(l,u,y)}static Hermite1stDerivative(t,e,r,s,i){const o=new t.constructor;return this.Hermite1stDerivativeToRef(t,e,r,s,i,o),o}static Hermite1stDerivativeToRef(t,e,r,s,i,o){const n=i*i;return o._x=6*(n-i)*t._x+(3*n-4*i+1)*e._x+6*(-n+i)*r._x+(3*n-2*i)*s._x,o._y=6*(n-i)*t._y+(3*n-4*i+1)*e._y+6*(-n+i)*r._y+(3*n-2*i)*s._y,o._z=6*(n-i)*t._z+(3*n-4*i+1)*e._z+6*(-n+i)*r._z+(3*n-2*i)*s._z,o._isDirty=!0,o}static Lerp(t,e,r){const s=new t.constructor(0,0,0);return l.LerpToRef(t,e,r,s),s}static LerpToRef(t,e,r,s){return s._x=t._x+(e._x-t._x)*r,s._y=t._y+(e._y-t._y)*r,s._z=t._z+(e._z-t._z)*r,s._isDirty=!0,s}static Dot(t,e){return t._x*e._x+t._y*e._y+t._z*e._z}static Cross(t,e){const r=new t.constructor;return l.CrossToRef(t,e,r),r}static CrossToRef(t,e,r){const s=t._y*e._z-t._z*e._y,i=t._z*e._x-t._x*e._z,o=t._x*e._y-t._y*e._x;return r.copyFromFloats(s,i,o),r}static Normalize(t){const e=l.Zero();return l.NormalizeToRef(t,e),e}static NormalizeToRef(t,e){return t.normalizeToRef(e),e}static Project(t,e,r,s){const i=new t.constructor;return l.ProjectToRef(t,e,r,s,i),i}static ProjectToRef(t,e,r,s,i){const o=s.width,n=s.height,a=s.x,h=s.y,c=x.Matrix[1];m.FromValuesToRef(o/2,0,0,0,0,-n/2,0,0,0,0,.5,0,a+o/2,n/2+h,.5,1,c);const _=x.Matrix[0];return e.multiplyToRef(r,_),_.multiplyToRef(c,_),l.TransformCoordinatesToRef(t,_,i),i}static Reflect(t,e){return this.ReflectToRef(t,e,new l)}static ReflectToRef(t,e,r){const s=R.Vector3[0];return s.copyFrom(e).scaleInPlace(2*l.Dot(t,e)),r.copyFrom(t).subtractInPlace(s)}static _UnprojectFromInvertedMatrixToRef(t,e,r){l.TransformCoordinatesToRef(t,e,r);const i=e.m,o=t._x*i[3]+t._y*i[7]+t._z*i[11]+i[15];return s.R.WithinEpsilon(o,1)&&r.scaleInPlace(1/o),r}static UnprojectFromTransform(t,e,r,s,i){return this.Unproject(t,e,r,s,i,m.IdentityReadOnly)}static Unproject(t,e,r,s,i,o){const n=new t.constructor;return l.UnprojectToRef(t,e,r,s,i,o,n),n}static UnprojectToRef(t,e,r,s,i,o,n){return l.UnprojectFloatsToRef(t._x,t._y,t._z,e,r,s,i,o,n),n}static UnprojectFloatsToRef(t,e,r,s,i,o,n,a,c){var _;const u=x.Matrix[0];o.multiplyToRef(n,u),u.multiplyToRef(a,u),u.invert();const y=x.Vector3[0];return y.x=t/s*2-1,y.y=-(e/i*2-1),(null===(_=h.l.LastCreatedEngine)||void 0===_?void 0:_.isNDCHalfZRange)?y.z=r:y.z=2*r-1,l._UnprojectFromInvertedMatrixToRef(y,u,c),c}static Minimize(t,e){const r=new t.constructor;return r.copyFrom(t),r.minimizeInPlace(e),r}static Maximize(t,e){const r=new t.constructor;return r.copyFrom(t),r.maximizeInPlace(e),r}static Distance(t,e){return Math.sqrt(l.DistanceSquared(t,e))}static DistanceSquared(t,e){const r=t._x-e._x,s=t._y-e._y,i=t._z-e._z;return r*r+s*s+i*i}static ProjectOnTriangleToRef(t,e,r,o,n){const a=x.Vector3[0],h=x.Vector3[1],c=x.Vector3[2],_=x.Vector3[3],u=x.Vector3[4];r.subtractToRef(e,a),o.subtractToRef(e,h),o.subtractToRef(r,c);const y=a.length(),m=h.length(),R=c.length();if(y<i.kn||m<i.kn||R<i.kn)return n.copyFrom(e),l.Distance(t,e);t.subtractToRef(e,u),l.CrossToRef(a,h,_);const d=_.length();if(d<i.kn)return n.copyFrom(e),l.Distance(t,e);_.normalizeFromLength(d);let f=u.length();if(f<i.kn)return n.copyFrom(e),0;u.normalizeFromLength(f);const z=l.Dot(_,u),T=x.Vector3[5],w=x.Vector3[6];T.copyFrom(_).scaleInPlace(-f*z),w.copyFrom(t).addInPlace(T);const p=x.Vector3[4],F=x.Vector3[5],g=x.Vector3[7],M=x.Vector3[8];p.copyFrom(a).scaleInPlace(1/y),M.copyFrom(h).scaleInPlace(1/m),p.addInPlace(M).scaleInPlace(-1),F.copyFrom(a).scaleInPlace(-1/y),M.copyFrom(c).scaleInPlace(1/R),F.addInPlace(M).scaleInPlace(-1),g.copyFrom(c).scaleInPlace(-1/R),M.copyFrom(h).scaleInPlace(-1/m),g.addInPlace(M).scaleInPlace(-1);const I=x.Vector3[9];let D;I.copyFrom(w).subtractInPlace(e),l.CrossToRef(p,I,M),D=l.Dot(M,_);const v=D;I.copyFrom(w).subtractInPlace(r),l.CrossToRef(F,I,M),D=l.Dot(M,_);const A=D;I.copyFrom(w).subtractInPlace(o),l.CrossToRef(g,I,M),D=l.Dot(M,_);const P=D,V=x.Vector3[10];let C,L;v>0&&A<0?(V.copyFrom(a),C=e,L=r):A>0&&P<0?(V.copyFrom(c),C=r,L=o):(V.copyFrom(h).scaleInPlace(-1),C=o,L=e);const O=x.Vector3[9],H=x.Vector3[4];C.subtractToRef(w,M),L.subtractToRef(w,O),l.CrossToRef(M,O,H);if(!(l.Dot(H,_)<0))return n.copyFrom(w),Math.abs(f*z);const k=x.Vector3[5];l.CrossToRef(V,H,k),k.normalize();const S=x.Vector3[9];S.copyFrom(C).subtractInPlace(w);const b=S.length();if(b<i.kn)return n.copyFrom(C),l.Distance(t,C);S.normalizeFromLength(b);const B=l.Dot(k,S),U=x.Vector3[7];U.copyFrom(w).addInPlace(k.scaleInPlace(b*B)),M.copyFrom(U).subtractInPlace(C),f=V.length(),V.normalizeFromLength(f);let Z=l.Dot(M,V)/Math.max(f,i.kn);return Z=s.R.Clamp(Z,0,1),U.copyFrom(C).addInPlace(V.scaleInPlace(Z*f)),n.copyFrom(U),l.Distance(t,U)}static Center(t,e){return l.CenterToRef(t,e,l.Zero())}static CenterToRef(t,e,r){return r.copyFromFloats((t._x+e._x)/2,(t._y+e._y)/2,(t._z+e._z)/2)}static RotationFromAxis(t,e,r){const s=new t.constructor;return l.RotationFromAxisToRef(t,e,r,s),s}static RotationFromAxisToRef(t,e,r,s){const i=x.Quaternion[0];return y.RotationQuaternionFromAxisToRef(t,e,r,i),i.toEulerAnglesToRef(s),s}}l._UpReadOnly=l.Up(),l._DownReadOnly=l.Down(),l._LeftHandedForwardReadOnly=l.Forward(!1),l._RightHandedForwardReadOnly=l.Forward(!0),l._LeftHandedBackwardReadOnly=l.Backward(!1),l._RightHandedBackwardReadOnly=l.Backward(!0),l._RightReadOnly=l.Right(),l._LeftReadOnly=l.Left(),l._ZeroReadOnly=l.Zero(),l._OneReadOnly=l.One();class u{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.x=t,this.y=e,this.z=r,this.w=s}toString(){return`{X: ${this.x} Y: ${this.y} Z: ${this.z} W: ${this.w}}`}getClassName(){return"Vector4"}getHashCode(){let t=c(this.x);return t=397*t^c(this.y),t=397*t^c(this.z),t=397*t^c(this.w),t}asArray(){const t=new Array;return this.toArray(t,0),t}toArray(t,e){return void 0===e&&(e=0),t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,this}fromArray(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u.FromArrayToRef(t,e,this),this}addInPlace(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}add(t){return new this.constructor(this.x+t.x,this.y+t.y,this.z+t.z,this.w+t.w)}addToRef(t,e){return e.x=this.x+t.x,e.y=this.y+t.y,e.z=this.z+t.z,e.w=this.w+t.w,e}subtractInPlace(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subtract(t){return new this.constructor(this.x-t.x,this.y-t.y,this.z-t.z,this.w-t.w)}subtractToRef(t,e){return e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z,e.w=this.w-t.w,e}subtractFromFloats(t,e,r,s){return new this.constructor(this.x-t,this.y-e,this.z-r,this.w-s)}subtractFromFloatsToRef(t,e,r,s,i){return i.x=this.x-t,i.y=this.y-e,i.z=this.z-r,i.w=this.w-s,i}negate(){return new this.constructor(-this.x,-this.y,-this.z,-this.w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(t){return t.copyFromFloats(-1*this.x,-1*this.y,-1*this.z,-1*this.w)}scaleInPlace(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}scale(t){return new this.constructor(this.x*t,this.y*t,this.z*t,this.w*t)}scaleToRef(t,e){return e.x=this.x*t,e.y=this.y*t,e.z=this.z*t,e.w=this.w*t,e}scaleAndAddToRef(t,e){return e.x+=this.x*t,e.y+=this.y*t,e.z+=this.z*t,e.w+=this.w*t,e}equals(t){return t&&this.x===t.x&&this.y===t.y&&this.z===t.z&&this.w===t.w}equalsWithEpsilon(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:i.kn;return t&&s.R.WithinEpsilon(this.x,t.x,e)&&s.R.WithinEpsilon(this.y,t.y,e)&&s.R.WithinEpsilon(this.z,t.z,e)&&s.R.WithinEpsilon(this.w,t.w,e)}equalsToFloats(t,e,r,s){return this.x===t&&this.y===e&&this.z===r&&this.w===s}multiplyInPlace(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiply(t){return new this.constructor(this.x*t.x,this.y*t.y,this.z*t.z,this.w*t.w)}multiplyToRef(t,e){return e.x=this.x*t.x,e.y=this.y*t.y,e.z=this.z*t.z,e.w=this.w*t.w,e}multiplyByFloats(t,e,r,s){return new this.constructor(this.x*t,this.y*e,this.z*r,this.w*s)}divide(t){return new this.constructor(this.x/t.x,this.y/t.y,this.z/t.z,this.w/t.w)}divideToRef(t,e){return e.x=this.x/t.x,e.y=this.y/t.y,e.z=this.z/t.z,e.w=this.w/t.w,e}divideInPlace(t){return this.divideToRef(t,this)}minimizeInPlace(t){return t.x<this.x&&(this.x=t.x),t.y<this.y&&(this.y=t.y),t.z<this.z&&(this.z=t.z),t.w<this.w&&(this.w=t.w),this}maximizeInPlace(t){return t.x>this.x&&(this.x=t.x),t.y>this.y&&(this.y=t.y),t.z>this.z&&(this.z=t.z),t.w>this.w&&(this.w=t.w),this}floor(){return new this.constructor(Math.floor(this.x),Math.floor(this.y),Math.floor(this.z),Math.floor(this.w))}fract(){return new this.constructor(this.x-Math.floor(this.x),this.y-Math.floor(this.y),this.z-Math.floor(this.z),this.w-Math.floor(this.w))}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}normalize(){const t=this.length();return 0===t?this:this.scaleInPlace(1/t)}toVector3(){return new l(this.x,this.y,this.z)}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copyFrom(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}copyFromFloats(t,e,r,s){return this.x=t,this.y=e,this.z=r,this.w=s,this}set(t,e,r,s){return this.copyFromFloats(t,e,r,s)}setAll(t){return this.x=this.y=this.z=this.w=t,this}static FromArray(t,e){return e||(e=0),new u(t[e],t[e+1],t[e+2],t[e+3])}static FromArrayToRef(t,e,r){return r.x=t[e],r.y=t[e+1],r.z=t[e+2],r.w=t[e+3],r}static FromFloatArrayToRef(t,e,r){return u.FromArrayToRef(t,e,r),r}static FromFloatsToRef(t,e,r,s,i){return i.x=t,i.y=e,i.z=r,i.w=s,i}static Zero(){return new u(0,0,0,0)}static One(){return new u(1,1,1,1)}static Random(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new u(s.R.RandomRange(t,e),s.R.RandomRange(t,e),s.R.RandomRange(t,e),s.R.RandomRange(t,e))}static get ZeroReadOnly(){return u._ZeroReadOnly}static Normalize(t){const e=u.Zero();return u.NormalizeToRef(t,e),e}static NormalizeToRef(t,e){return e.copyFrom(t),e.normalize(),e}static Minimize(t,e){const r=new t.constructor;return r.copyFrom(t),r.minimizeInPlace(e),r}static Maximize(t,e){const r=new t.constructor;return r.copyFrom(t),r.maximizeInPlace(e),r}static Distance(t,e){return Math.sqrt(u.DistanceSquared(t,e))}static DistanceSquared(t,e){const r=t.x-e.x,s=t.y-e.y,i=t.z-e.z,o=t.w-e.w;return r*r+s*s+i*i+o*o}static Center(t,e){return u.CenterToRef(t,e,u.Zero())}static CenterToRef(t,e,r){return r.copyFromFloats((t.x+e.x)/2,(t.y+e.y)/2,(t.z+e.z)/2,(t.w+e.w)/2)}static TransformCoordinates(t,e){const r=u.Zero();return u.TransformCoordinatesToRef(t,e,r),r}static TransformCoordinatesToRef(t,e,r){return u.TransformCoordinatesFromFloatsToRef(t._x,t._y,t._z,e,r),r}static TransformCoordinatesFromFloatsToRef(t,e,r,s,i){const o=s.m,n=t*o[0]+e*o[4]+r*o[8]+o[12],a=t*o[1]+e*o[5]+r*o[9]+o[13],h=t*o[2]+e*o[6]+r*o[10]+o[14],c=t*o[3]+e*o[7]+r*o[11]+o[15];return i.x=n,i.y=a,i.z=h,i.w=c,i}static TransformNormal(t,e){const r=new t.constructor;return u.TransformNormalToRef(t,e,r),r}static TransformNormalToRef(t,e,r){const s=e.m,i=t.x*s[0]+t.y*s[4]+t.z*s[8],o=t.x*s[1]+t.y*s[5]+t.z*s[9],n=t.x*s[2]+t.y*s[6]+t.z*s[10];return r.x=i,r.y=o,r.z=n,r.w=t.w,r}static TransformNormalFromFloatsToRef(t,e,r,s,i,o){const n=i.m;return o.x=t*n[0]+e*n[4]+r*n[8],o.y=t*n[1]+e*n[5]+r*n[9],o.z=t*n[2]+e*n[6]+r*n[10],o.w=s,o}static FromVector3(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new u(t._x,t._y,t._z,e)}}u._ZeroReadOnly=u.Zero();class y{get x(){return this._x}set x(t){this._x=t,this._isDirty=!0}get y(){return this._y}set y(t){this._y=t,this._isDirty=!0}get z(){return this._z}set z(t){this._z=t,this._isDirty=!0}get w(){return this._w}set w(t){this._w=t,this._isDirty=!0}constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=t,this._y=e,this._z=r,this._w=s}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let t=c(this._x);return t=397*t^c(this._y),t=397*t^c(this._z),t=397*t^c(this._w),t}asArray(){return[this._x,this._y,this._z,this._w]}toArray(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,this}equals(t){return t&&this._x===t._x&&this._y===t._y&&this._z===t._z&&this._w===t._w}equalsWithEpsilon(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:i.kn;return t&&s.R.WithinEpsilon(this._x,t._x,e)&&s.R.WithinEpsilon(this._y,t._y,e)&&s.R.WithinEpsilon(this._z,t._z,e)&&s.R.WithinEpsilon(this._w,t._w,e)}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copyFrom(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._w=t._w,this._isDirty=!0,this}copyFromFloats(t,e,r,s){return this._x=t,this._y=e,this._z=r,this._w=s,this._isDirty=!0,this}set(t,e,r,s){return this.copyFromFloats(t,e,r,s)}add(t){return new this.constructor(this._x+t._x,this._y+t._y,this._z+t._z,this._w+t._w)}addInPlace(t){return this._x+=t._x,this._y+=t._y,this._z+=t._z,this._w+=t._w,this._isDirty=!0,this}subtract(t){return new this.constructor(this._x-t._x,this._y-t._y,this._z-t._z,this._w-t._w)}subtractInPlace(t){return this._x-=t._x,this._y-=t._y,this._z-=t._z,this._w-=t._w,this._isDirty=!0,this}scale(t){return new this.constructor(this._x*t,this._y*t,this._z*t,this._w*t)}scaleToRef(t,e){return e._x=this._x*t,e._y=this._y*t,e._z=this._z*t,e._w=this._w*t,e._isDirty=!0,e}scaleInPlace(t){return this._x*=t,this._y*=t,this._z*=t,this._w*=t,this._isDirty=!0,this}scaleAndAddToRef(t,e){return e._x+=this._x*t,e._y+=this._y*t,e._z+=this._z*t,e._w+=this._w*t,e._isDirty=!0,e}multiply(t){const e=new this.constructor(0,0,0,1);return this.multiplyToRef(t,e),e}multiplyToRef(t,e){const r=this._x*t._w+this._y*t._z-this._z*t._y+this._w*t._x,s=-this._x*t._z+this._y*t._w+this._z*t._x+this._w*t._y,i=this._x*t._y-this._y*t._x+this._z*t._w+this._w*t._z,o=-this._x*t._x-this._y*t._y-this._z*t._z+this._w*t._w;return e.copyFromFloats(r,s,i,o),e}multiplyInPlace(t){return this.multiplyToRef(t,this),this}conjugateToRef(t){return t.copyFromFloats(-this._x,-this._y,-this._z,this._w),t}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new this.constructor(-this._x,-this._y,-this._z,this._w)}invert(){const t=this.conjugate(),e=this.lengthSquared();return 0==e||1==e||t.scaleInPlace(1/e),t}invertInPlace(){this.conjugateInPlace();const t=this.lengthSquared();return 0==t||1==t||this.scaleInPlace(1/t),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){const t=this.length();if(0===t)return this;const e=1/t;return this.scaleInPlace(e),this}normalizeToNew(){const t=this.length();if(0===t)return this.clone();const e=1/t;return this.scale(e)}toEulerAngles(){const t=l.Zero();return this.toEulerAnglesToRef(t),t}toEulerAnglesToRef(t){const e=this._z,r=this._x,s=this._y,i=this._w,o=s*e-r*i,n=.4999999;if(o<-n)t._y=2*Math.atan2(s,i),t._x=Math.PI/2,t._z=0,t._isDirty=!0;else if(o>n)t._y=2*Math.atan2(s,i),t._x=-Math.PI/2,t._z=0,t._isDirty=!0;else{const n=i*i,a=e*e,h=r*r,c=s*s;t._z=Math.atan2(2*(r*s+e*i),-a-h+c+n),t._x=Math.asin(-2*o),t._y=Math.atan2(2*(e*r+s*i),a-h-c+n),t._isDirty=!0}return t}toRotationMatrix(t){return m.FromQuaternionToRef(this,t),t}fromRotationMatrix(t){return y.FromRotationMatrixToRef(t,this),this}static FromRotationMatrix(t){const e=new y;return y.FromRotationMatrixToRef(t,e),e}static FromRotationMatrixToRef(t,e){const r=t.m,s=r[0],i=r[4],o=r[8],n=r[1],a=r[5],h=r[9],c=r[2],_=r[6],l=r[10],u=s+a+l;let y;return u>0?(y=.5/Math.sqrt(u+1),e._w=.25/y,e._x=(_-h)*y,e._y=(o-c)*y,e._z=(n-i)*y,e._isDirty=!0):s>a&&s>l?(y=2*Math.sqrt(1+s-a-l),e._w=(_-h)/y,e._x=.25*y,e._y=(i+n)/y,e._z=(o+c)/y,e._isDirty=!0):a>l?(y=2*Math.sqrt(1+a-s-l),e._w=(o-c)/y,e._x=(i+n)/y,e._y=.25*y,e._z=(h+_)/y,e._isDirty=!0):(y=2*Math.sqrt(1+l-s-a),e._w=(n-i)/y,e._x=(o+c)/y,e._y=(h+_)/y,e._z=.25*y,e._isDirty=!0),e}static Dot(t,e){return t._x*e._x+t._y*e._y+t._z*e._z+t._w*e._w}static AreClose(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const s=y.Dot(t,e);return 1-s*s<=r}static SmoothToRef(t,e,r,i,o){let n=0===i?1:r/i;return n=s.R.Clamp(n,0,1),y.SlerpToRef(t,e,n,o),o}static Zero(){return new y(0,0,0,0)}static Inverse(t){return new t.constructor(-t._x,-t._y,-t._z,t._w)}static InverseToRef(t,e){return e.set(-t._x,-t._y,-t._z,t._w),e}static Identity(){return new y(0,0,0,1)}static IsIdentity(t){return t&&0===t._x&&0===t._y&&0===t._z&&1===t._w}static RotationAxis(t,e){return y.RotationAxisToRef(t,e,new y)}static RotationAxisToRef(t,e,r){const s=Math.sin(e/2);return t.normalize(),r._w=Math.cos(e/2),r._x=t._x*s,r._y=t._y*s,r._z=t._z*s,r._isDirty=!0,r}static FromArray(t,e){return e||(e=0),new y(t[e],t[e+1],t[e+2],t[e+3])}static FromArrayToRef(t,e,r){return r._x=t[e],r._y=t[e+1],r._z=t[e+2],r._w=t[e+3],r._isDirty=!0,r}static FromEulerAngles(t,e,r){const s=new y;return y.RotationYawPitchRollToRef(e,t,r,s),s}static FromEulerAnglesToRef(t,e,r,s){return y.RotationYawPitchRollToRef(e,t,r,s),s}static FromEulerVector(t){const e=new y;return y.RotationYawPitchRollToRef(t._y,t._x,t._z,e),e}static FromEulerVectorToRef(t,e){return y.RotationYawPitchRollToRef(t._y,t._x,t._z,e),e}static FromUnitVectorsToRef(t,e,r){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:i.kn;const o=l.Dot(t,e)+1;return o<s?Math.abs(t.x)>Math.abs(t.z)?r.set(-t.y,t.x,0,0):r.set(0,-t.z,t.y,0):(l.CrossToRef(t,e,R.Vector3[0]),r.set(R.Vector3[0].x,R.Vector3[0].y,R.Vector3[0].z,o)),r.normalize()}static RotationYawPitchRoll(t,e,r){const s=new y;return y.RotationYawPitchRollToRef(t,e,r,s),s}static RotationYawPitchRollToRef(t,e,r,s){const i=.5*r,o=.5*e,n=.5*t,a=Math.sin(i),h=Math.cos(i),c=Math.sin(o),_=Math.cos(o),l=Math.sin(n),u=Math.cos(n);return s._x=u*c*h+l*_*a,s._y=l*_*h-u*c*a,s._z=u*_*a-l*c*h,s._w=u*_*h+l*c*a,s._isDirty=!0,s}static RotationAlphaBetaGamma(t,e,r){const s=new y;return y.RotationAlphaBetaGammaToRef(t,e,r,s),s}static RotationAlphaBetaGammaToRef(t,e,r,s){const i=.5*(r+t),o=.5*(r-t),n=.5*e;return s._x=Math.cos(o)*Math.sin(n),s._y=Math.sin(o)*Math.sin(n),s._z=Math.sin(i)*Math.cos(n),s._w=Math.cos(i)*Math.cos(n),s._isDirty=!0,s}static RotationQuaternionFromAxis(t,e,r){const s=new y(0,0,0,0);return y.RotationQuaternionFromAxisToRef(t,e,r,s),s}static RotationQuaternionFromAxisToRef(t,e,r,s){const i=x.Matrix[0];return m.FromXYZAxesToRef(t.normalize(),e.normalize(),r.normalize(),i),y.FromRotationMatrixToRef(i,s),s}static FromLookDirectionLH(t,e){const r=new y;return y.FromLookDirectionLHToRef(t,e,r),r}static FromLookDirectionLHToRef(t,e,r){const s=x.Matrix[0];return m.LookDirectionLHToRef(t,e,s),y.FromRotationMatrixToRef(s,r),r}static FromLookDirectionRH(t,e){const r=new y;return y.FromLookDirectionRHToRef(t,e,r),r}static FromLookDirectionRHToRef(t,e,r){const s=x.Matrix[0];return m.LookDirectionRHToRef(t,e,s),y.FromRotationMatrixToRef(s,r)}static Slerp(t,e,r){const s=y.Identity();return y.SlerpToRef(t,e,r,s),s}static SlerpToRef(t,e,r,s){let i,o,n=t._x*e._x+t._y*e._y+t._z*e._z+t._w*e._w,a=!1;if(n<0&&(a=!0,n=-n),n>.999999)o=1-r,i=a?-r:r;else{const t=Math.acos(n),e=1/Math.sin(t);o=Math.sin((1-r)*t)*e,i=a?-Math.sin(r*t)*e:Math.sin(r*t)*e}return s._x=o*t._x+i*e._x,s._y=o*t._y+i*e._y,s._z=o*t._z+i*e._z,s._w=o*t._w+i*e._w,s._isDirty=!0,s}static Hermite(t,e,r,s,i){const o=i*i,n=i*o,a=2*n-3*o+1,h=-2*n+3*o,c=n-2*o+i,_=n-o,l=t._x*a+r._x*h+e._x*c+s._x*_,u=t._y*a+r._y*h+e._y*c+s._y*_,y=t._z*a+r._z*h+e._z*c+s._z*_,m=t._w*a+r._w*h+e._w*c+s._w*_;return new t.constructor(l,u,y,m)}static Hermite1stDerivative(t,e,r,s,i){const o=new t.constructor;return this.Hermite1stDerivativeToRef(t,e,r,s,i,o),o}static Hermite1stDerivativeToRef(t,e,r,s,i,o){const n=i*i;return o._x=6*(n-i)*t._x+(3*n-4*i+1)*e._x+6*(-n+i)*r._x+(3*n-2*i)*s._x,o._y=6*(n-i)*t._y+(3*n-4*i+1)*e._y+6*(-n+i)*r._y+(3*n-2*i)*s._y,o._z=6*(n-i)*t._z+(3*n-4*i+1)*e._z+6*(-n+i)*r._z+(3*n-2*i)*s._z,o._w=6*(n-i)*t._w+(3*n-4*i+1)*e._w+6*(-n+i)*r._w+(3*n-2*i)*s._w,o._isDirty=!0,o}}class m{static get Use64Bits(){return a.Z.MatrixUse64Bits}get m(){return this._m}markAsUpdated(){this.updateFlag=m._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=t,this._isIdentity3x2=t||r,this._isIdentityDirty=!this._isIdentity&&e,this._isIdentity3x2Dirty=!this._isIdentity3x2&&s}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,a.Z.MatrixTrackPrecisionChange&&a.Z.MatrixTrackedMatrices.push(this),this._m=new a.Z.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const t=this._m;this._isIdentity=1===t[0]&&0===t[1]&&0===t[2]&&0===t[3]&&0===t[4]&&1===t[5]&&0===t[6]&&0===t[7]&&0===t[8]&&0===t[9]&&1===t[10]&&0===t[11]&&0===t[12]&&0===t[13]&&0===t[14]&&1===t[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this._m[0]||1!==this._m[5]||1!==this._m[15]||0!==this._m[1]||0!==this._m[2]||0!==this._m[3]||0!==this._m[4]||0!==this._m[6]||0!==this._m[7]||0!==this._m[8]||0!==this._m[9]||0!==this._m[10]||0!==this._m[11]||0!==this._m[12]||0!==this._m[13]||0!==this._m[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const t=this._m,e=t[0],r=t[1],s=t[2],i=t[3],o=t[4],n=t[5],a=t[6],h=t[7],c=t[8],_=t[9],l=t[10],u=t[11],y=t[12],m=t[13],x=t[14],R=t[15],d=l*R-x*u,f=_*R-m*u,z=_*x-m*l,T=c*R-y*u,w=c*x-l*y,p=c*m-y*_;return e*+(n*d-a*f+h*z)+r*-(o*d-a*T+h*w)+s*+(o*f-n*T+h*p)+i*-(o*z-n*w+a*p)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){return this._m}asArray(){return this._m}invert(){return this.invertToRef(this),this}reset(){return m.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(t){const e=new this.constructor;return this.addToRef(t,e),e}addToRef(t,e){const r=this._m,s=e._m,i=t.m;for(let o=0;o<16;o++)s[o]=r[o]+i[o];return e.markAsUpdated(),e}addToSelf(t){const e=this._m,r=t.m;for(let s=0;s<16;s++)e[s]+=r[s];return this.markAsUpdated(),this}invertToRef(t){if(!0===this._isIdentity)return m.IdentityToRef(t),t;const e=this._m,r=e[0],s=e[1],i=e[2],o=e[3],n=e[4],a=e[5],h=e[6],c=e[7],_=e[8],l=e[9],u=e[10],y=e[11],x=e[12],R=e[13],d=e[14],f=e[15],z=u*f-d*y,T=l*f-R*y,w=l*d-R*u,p=_*f-x*y,F=_*d-u*x,g=_*R-x*l,M=+(a*z-h*T+c*w),I=-(n*z-h*p+c*F),D=+(n*T-a*p+c*g),v=-(n*w-a*F+h*g),A=r*M+s*I+i*D+o*v;if(0===A)return t.copyFrom(this),t;const P=1/A,V=h*f-d*c,C=a*f-R*c,L=a*d-R*h,O=n*f-x*c,H=n*d-x*h,k=n*R-x*a,S=h*y-u*c,b=a*y-l*c,B=a*u-l*h,U=n*y-_*c,Z=n*u-_*h,q=n*l-_*a,N=-(s*z-i*T+o*w),E=+(r*z-i*p+o*F),$=-(r*T-s*p+o*g),Y=+(r*w-s*F+i*g),Q=+(s*V-i*C+o*L),j=-(r*V-i*O+o*H),W=+(r*C-s*O+o*k),G=-(r*L-s*H+i*k),X=-(s*S-i*b+o*B),J=+(r*S-i*U+o*Z),K=-(r*b-s*U+o*q),tt=+(r*B-s*Z+i*q);return m.FromValuesToRef(M*P,N*P,Q*P,X*P,I*P,E*P,j*P,J*P,D*P,$*P,W*P,K*P,v*P,Y*P,G*P,tt*P,t),t}addAtIndex(t,e){return this._m[t]+=e,this.markAsUpdated(),this}multiplyAtIndex(t,e){return this._m[t]*=e,this.markAsUpdated(),this}setTranslationFromFloats(t,e,r){return this._m[12]=t,this._m[13]=e,this._m[14]=r,this.markAsUpdated(),this}addTranslationFromFloats(t,e,r){return this._m[12]+=t,this._m[13]+=e,this._m[14]+=r,this.markAsUpdated(),this}setTranslation(t){return this.setTranslationFromFloats(t._x,t._y,t._z)}getTranslation(){return new l(this._m[12],this._m[13],this._m[14])}getTranslationToRef(t){return t.x=this._m[12],t.y=this._m[13],t.z=this._m[14],t}removeRotationAndScaling(){const t=this.m;return m.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,t[12],t[13],t[14],t[15],this),this._updateIdentityStatus(0===t[12]&&0===t[13]&&0===t[14]&&1===t[15]),this}multiply(t){const e=new this.constructor;return this.multiplyToRef(t,e),e}copyFrom(t){t.copyToArray(this._m);const e=t;return this.updateFlag=e.updateFlag,this._updateIdentityStatus(e._isIdentity,e._isIdentityDirty,e._isIdentity3x2,e._isIdentity3x2Dirty),this}copyToArray(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=this._m;return t[e]=r[0],t[e+1]=r[1],t[e+2]=r[2],t[e+3]=r[3],t[e+4]=r[4],t[e+5]=r[5],t[e+6]=r[6],t[e+7]=r[7],t[e+8]=r[8],t[e+9]=r[9],t[e+10]=r[10],t[e+11]=r[11],t[e+12]=r[12],t[e+13]=r[13],t[e+14]=r[14],t[e+15]=r[15],this}multiplyToRef(t,e){return this._isIdentity?(e.copyFrom(t),e):t._isIdentity?(e.copyFrom(this),e):(this.multiplyToArray(t,e._m,0),e.markAsUpdated(),e)}multiplyToArray(t,e,r){const s=this._m,i=t.m,o=s[0],n=s[1],a=s[2],h=s[3],c=s[4],_=s[5],l=s[6],u=s[7],y=s[8],m=s[9],x=s[10],R=s[11],d=s[12],f=s[13],z=s[14],T=s[15],w=i[0],p=i[1],F=i[2],g=i[3],M=i[4],I=i[5],D=i[6],v=i[7],A=i[8],P=i[9],V=i[10],C=i[11],L=i[12],O=i[13],H=i[14],k=i[15];return e[r]=o*w+n*M+a*A+h*L,e[r+1]=o*p+n*I+a*P+h*O,e[r+2]=o*F+n*D+a*V+h*H,e[r+3]=o*g+n*v+a*C+h*k,e[r+4]=c*w+_*M+l*A+u*L,e[r+5]=c*p+_*I+l*P+u*O,e[r+6]=c*F+_*D+l*V+u*H,e[r+7]=c*g+_*v+l*C+u*k,e[r+8]=y*w+m*M+x*A+R*L,e[r+9]=y*p+m*I+x*P+R*O,e[r+10]=y*F+m*D+x*V+R*H,e[r+11]=y*g+m*v+x*C+R*k,e[r+12]=d*w+f*M+z*A+T*L,e[r+13]=d*p+f*I+z*P+T*O,e[r+14]=d*F+f*D+z*V+T*H,e[r+15]=d*g+f*v+z*C+T*k,this}equals(t){const e=t;if(!e)return!1;if((this._isIdentity||e._isIdentity)&&!this._isIdentityDirty&&!e._isIdentityDirty)return this._isIdentity&&e._isIdentity;const r=this.m,s=e.m;return r[0]===s[0]&&r[1]===s[1]&&r[2]===s[2]&&r[3]===s[3]&&r[4]===s[4]&&r[5]===s[5]&&r[6]===s[6]&&r[7]===s[7]&&r[8]===s[8]&&r[9]===s[9]&&r[10]===s[10]&&r[11]===s[11]&&r[12]===s[12]&&r[13]===s[13]&&r[14]===s[14]&&r[15]===s[15]}clone(){const t=new this.constructor;return t.copyFrom(this),t}getClassName(){return"Matrix"}getHashCode(){let t=c(this._m[0]);for(let e=1;e<16;e++)t=397*t^c(this._m[e]);return t}decomposeToTransformNode(t){return t.rotationQuaternion=t.rotationQuaternion||new y,this.decompose(t.scaling,t.rotationQuaternion,t.position)}decompose(t,e,r,s){if(this._isIdentity)return r&&r.setAll(0),t&&t.setAll(1),e&&e.copyFromFloats(0,0,0,1),!0;const i=this._m;if(r&&r.copyFromFloats(i[12],i[13],i[14]),(t=t||x.Vector3[0]).x=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]),t.y=Math.sqrt(i[4]*i[4]+i[5]*i[5]+i[6]*i[6]),t.z=Math.sqrt(i[8]*i[8]+i[9]*i[9]+i[10]*i[10]),s){const e=s.absoluteScaling.x<0?-1:1,r=s.absoluteScaling.y<0?-1:1,i=s.absoluteScaling.z<0?-1:1;t.x*=e,t.y*=r,t.z*=i}else this.determinant()<=0&&(t.y*=-1);if(0===t._x||0===t._y||0===t._z)return e&&e.copyFromFloats(0,0,0,1),!1;if(e){const r=1/t._x,s=1/t._y,o=1/t._z;m.FromValuesToRef(i[0]*r,i[1]*r,i[2]*r,0,i[4]*s,i[5]*s,i[6]*s,0,i[8]*o,i[9]*o,i[10]*o,0,0,0,0,1,x.Matrix[0]),y.FromRotationMatrixToRef(x.Matrix[0],e)}return!0}getRow(t){if(t<0||t>3)return null;const e=4*t;return new u(this._m[e+0],this._m[e+1],this._m[e+2],this._m[e+3])}getRowToRef(t,e){if(t>=0&&t<3){const r=4*t;e.x=this._m[r+0],e.y=this._m[r+1],e.z=this._m[r+2],e.w=this._m[r+3]}return e}setRow(t,e){return this.setRowFromFloats(t,e.x,e.y,e.z,e.w)}transpose(){const t=new this.constructor;return m.TransposeToRef(this,t),t}transposeToRef(t){return m.TransposeToRef(this,t),t}setRowFromFloats(t,e,r,s,i){if(t<0||t>3)return this;const o=4*t;return this._m[o+0]=e,this._m[o+1]=r,this._m[o+2]=s,this._m[o+3]=i,this.markAsUpdated(),this}scale(t){const e=new this.constructor;return this.scaleToRef(t,e),e}scaleToRef(t,e){for(let r=0;r<16;r++)e._m[r]=this._m[r]*t;return e.markAsUpdated(),e}scaleAndAddToRef(t,e){for(let r=0;r<16;r++)e._m[r]+=this._m[r]*t;return e.markAsUpdated(),e}toNormalMatrix(t){const e=x.Matrix[0];this.invertToRef(e),e.transposeToRef(t);const r=t._m;return m.FromValuesToRef(r[0],r[1],r[2],0,r[4],r[5],r[6],0,r[8],r[9],r[10],0,0,0,0,1,t),t}getRotationMatrix(){const t=new this.constructor;return this.getRotationMatrixToRef(t),t}getRotationMatrixToRef(t){const e=x.Vector3[0];if(!this.decompose(e))return m.IdentityToRef(t),t;const r=this._m,s=1/e._x,i=1/e._y,o=1/e._z;return m.FromValuesToRef(r[0]*s,r[1]*s,r[2]*s,0,r[4]*i,r[5]*i,r[6]*i,0,r[8]*o,r[9]*o,r[10]*o,0,0,0,0,1,t),t}toggleModelMatrixHandInPlace(){const t=this._m;return t[2]*=-1,t[6]*=-1,t[8]*=-1,t[9]*=-1,t[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const t=this._m;return t[8]*=-1,t[9]*=-1,t[10]*=-1,t[11]*=-1,this.markAsUpdated(),this}static FromArray(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=new m;return m.FromArrayToRef(t,e,r),r}static FromArrayToRef(t,e,r){for(let s=0;s<16;s++)r._m[s]=t[s+e];return r.markAsUpdated(),r}static FromFloat32ArrayToRefScaled(t,e,r,s){for(let i=0;i<16;i++)s._m[i]=t[i+e]*r;return s.markAsUpdated(),s}static get IdentityReadOnly(){return m._IdentityReadOnly}static FromValuesToRef(t,e,r,s,i,o,n,a,h,c,_,l,u,y,m,x,R){const d=R._m;d[0]=t,d[1]=e,d[2]=r,d[3]=s,d[4]=i,d[5]=o,d[6]=n,d[7]=a,d[8]=h,d[9]=c,d[10]=_,d[11]=l,d[12]=u,d[13]=y,d[14]=m,d[15]=x,R.markAsUpdated()}static FromValues(t,e,r,s,i,o,n,a,h,c,_,l,u,y,x,R){const d=new m,f=d._m;return f[0]=t,f[1]=e,f[2]=r,f[3]=s,f[4]=i,f[5]=o,f[6]=n,f[7]=a,f[8]=h,f[9]=c,f[10]=_,f[11]=l,f[12]=u,f[13]=y,f[14]=x,f[15]=R,d.markAsUpdated(),d}static Compose(t,e,r){const s=new m;return m.ComposeToRef(t,e,r,s),s}static ComposeToRef(t,e,r,s){const i=s._m,o=e._x,n=e._y,a=e._z,h=e._w,c=o+o,_=n+n,l=a+a,u=o*c,y=o*_,m=o*l,x=n*_,R=n*l,d=a*l,f=h*c,z=h*_,T=h*l,w=t._x,p=t._y,F=t._z;return i[0]=(1-(x+d))*w,i[1]=(y+T)*w,i[2]=(m-z)*w,i[3]=0,i[4]=(y-T)*p,i[5]=(1-(u+d))*p,i[6]=(R+f)*p,i[7]=0,i[8]=(m+z)*F,i[9]=(R-f)*F,i[10]=(1-(u+x))*F,i[11]=0,i[12]=r._x,i[13]=r._y,i[14]=r._z,i[15]=1,s.markAsUpdated(),s}static Identity(){const t=m.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return t._updateIdentityStatus(!0),t}static IdentityToRef(t){return m.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,t),t._updateIdentityStatus(!0),t}static Zero(){const t=m.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return t._updateIdentityStatus(!1),t}static RotationX(t){const e=new m;return m.RotationXToRef(t,e),e}static Invert(t){const e=new t.constructor;return t.invertToRef(e),e}static RotationXToRef(t,e){const r=Math.sin(t),s=Math.cos(t);return m.FromValuesToRef(1,0,0,0,0,s,r,0,0,-r,s,0,0,0,0,1,e),e._updateIdentityStatus(1===s&&0===r),e}static RotationY(t){const e=new m;return m.RotationYToRef(t,e),e}static RotationYToRef(t,e){const r=Math.sin(t),s=Math.cos(t);return m.FromValuesToRef(s,0,-r,0,0,1,0,0,r,0,s,0,0,0,0,1,e),e._updateIdentityStatus(1===s&&0===r),e}static RotationZ(t){const e=new m;return m.RotationZToRef(t,e),e}static RotationZToRef(t,e){const r=Math.sin(t),s=Math.cos(t);return m.FromValuesToRef(s,r,0,0,-r,s,0,0,0,0,1,0,0,0,0,1,e),e._updateIdentityStatus(1===s&&0===r),e}static RotationAxis(t,e){const r=new m;return m.RotationAxisToRef(t,e,r),r}static RotationAxisToRef(t,e,r){const s=Math.sin(-e),i=Math.cos(-e),o=1-i;t.normalize();const n=r._m;return n[0]=t._x*t._x*o+i,n[1]=t._x*t._y*o-t._z*s,n[2]=t._x*t._z*o+t._y*s,n[3]=0,n[4]=t._y*t._x*o+t._z*s,n[5]=t._y*t._y*o+i,n[6]=t._y*t._z*o-t._x*s,n[7]=0,n[8]=t._z*t._x*o-t._y*s,n[9]=t._z*t._y*o+t._x*s,n[10]=t._z*t._z*o+i,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,r.markAsUpdated(),r}static RotationAlignToRef(t,e,r){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const o=l.Dot(e,t),n=r._m;if(o<-1+i.kn)n[0]=-1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=s?1:-1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=s?-1:1,n[11]=0;else{const r=l.Cross(e,t),s=1/(1+o);n[0]=r._x*r._x*s+o,n[1]=r._y*r._x*s-r._z,n[2]=r._z*r._x*s+r._y,n[3]=0,n[4]=r._x*r._y*s+r._z,n[5]=r._y*r._y*s+o,n[6]=r._z*r._y*s-r._x,n[7]=0,n[8]=r._x*r._z*s-r._y,n[9]=r._y*r._z*s+r._x,n[10]=r._z*r._z*s+o,n[11]=0}return n[12]=0,n[13]=0,n[14]=0,n[15]=1,r.markAsUpdated(),r}static RotationYawPitchRoll(t,e,r){const s=new m;return m.RotationYawPitchRollToRef(t,e,r,s),s}static RotationYawPitchRollToRef(t,e,r,s){return y.RotationYawPitchRollToRef(t,e,r,x.Quaternion[0]),x.Quaternion[0].toRotationMatrix(s),s}static Scaling(t,e,r){const s=new m;return m.ScalingToRef(t,e,r,s),s}static ScalingToRef(t,e,r,s){return m.FromValuesToRef(t,0,0,0,0,e,0,0,0,0,r,0,0,0,0,1,s),s._updateIdentityStatus(1===t&&1===e&&1===r),s}static Translation(t,e,r){const s=new m;return m.TranslationToRef(t,e,r,s),s}static TranslationToRef(t,e,r,s){return m.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,t,e,r,1,s),s._updateIdentityStatus(0===t&&0===e&&0===r),s}static Lerp(t,e,r){const s=new t.constructor;return m.LerpToRef(t,e,r,s),s}static LerpToRef(t,e,r,s){const i=s._m,o=t.m,n=e.m;for(let a=0;a<16;a++)i[a]=o[a]*(1-r)+n[a]*r;return s.markAsUpdated(),s}static DecomposeLerp(t,e,r){const s=new t.constructor;return m.DecomposeLerpToRef(t,e,r,s),s}static DecomposeLerpToRef(t,e,r,s){const i=x.Vector3[0],o=x.Quaternion[0],n=x.Vector3[1];t.decompose(i,o,n);const a=x.Vector3[2],h=x.Quaternion[1],c=x.Vector3[3];e.decompose(a,h,c);const _=x.Vector3[4];l.LerpToRef(i,a,r,_);const u=x.Quaternion[2];y.SlerpToRef(o,h,r,u);const R=x.Vector3[5];return l.LerpToRef(n,c,r,R),m.ComposeToRef(_,u,R,s),s}static LookAtLH(t,e,r){const s=new m;return m.LookAtLHToRef(t,e,r,s),s}static LookAtLHToRef(t,e,r,s){const i=x.Vector3[0],o=x.Vector3[1],n=x.Vector3[2];e.subtractToRef(t,n),n.normalize(),l.CrossToRef(r,n,i);const a=i.lengthSquared();0===a?i.x=1:i.normalizeFromLength(Math.sqrt(a)),l.CrossToRef(n,i,o),o.normalize();const h=-l.Dot(i,t),c=-l.Dot(o,t),_=-l.Dot(n,t);m.FromValuesToRef(i._x,o._x,n._x,0,i._y,o._y,n._y,0,i._z,o._z,n._z,0,h,c,_,1,s)}static LookAtRH(t,e,r){const s=new m;return m.LookAtRHToRef(t,e,r,s),s}static LookAtRHToRef(t,e,r,s){const i=x.Vector3[0],o=x.Vector3[1],n=x.Vector3[2];t.subtractToRef(e,n),n.normalize(),l.CrossToRef(r,n,i);const a=i.lengthSquared();0===a?i.x=1:i.normalizeFromLength(Math.sqrt(a)),l.CrossToRef(n,i,o),o.normalize();const h=-l.Dot(i,t),c=-l.Dot(o,t),_=-l.Dot(n,t);return m.FromValuesToRef(i._x,o._x,n._x,0,i._y,o._y,n._y,0,i._z,o._z,n._z,0,h,c,_,1,s),s}static LookDirectionLH(t,e){const r=new m;return m.LookDirectionLHToRef(t,e,r),r}static LookDirectionLHToRef(t,e,r){const s=x.Vector3[0];s.copyFrom(t),s.scaleInPlace(-1);const i=x.Vector3[1];return l.CrossToRef(e,s,i),m.FromValuesToRef(i._x,i._y,i._z,0,e._x,e._y,e._z,0,s._x,s._y,s._z,0,0,0,0,1,r),r}static LookDirectionRH(t,e){const r=new m;return m.LookDirectionRHToRef(t,e,r),r}static LookDirectionRHToRef(t,e,r){const s=x.Vector3[2];return l.CrossToRef(e,t,s),m.FromValuesToRef(s._x,s._y,s._z,0,e._x,e._y,e._z,0,t._x,t._y,t._z,0,0,0,0,1,r),r}static OrthoLH(t,e,r,s,i){const o=new m;return m.OrthoLHToRef(t,e,r,s,o,i),o}static OrthoLHToRef(t,e,r,s,i,o){const n=2/t,a=2/e,h=2/(s-r),c=-(s+r)/(s-r);return m.FromValuesToRef(n,0,0,0,0,a,0,0,0,0,h,0,0,0,c,1,i),o&&i.multiplyToRef(d,i),i._updateIdentityStatus(1===n&&1===a&&1===h&&0===c),i}static OrthoOffCenterLH(t,e,r,s,i,o,n){const a=new m;return m.OrthoOffCenterLHToRef(t,e,r,s,i,o,a,n),a}static OrthoOffCenterLHToRef(t,e,r,s,i,o,n,a){const h=2/(e-t),c=2/(s-r),_=2/(o-i),l=-(o+i)/(o-i),u=(t+e)/(t-e),y=(s+r)/(r-s);return m.FromValuesToRef(h,0,0,0,0,c,0,0,0,0,_,0,u,y,l,1,n),a&&n.multiplyToRef(d,n),n.markAsUpdated(),n}static ObliqueOffCenterLHToRef(t,e,r,s,i,o,n,a,h,c,_){const l=-n*Math.cos(a),u=-n*Math.sin(a);return m.TranslationToRef(0,0,-h,x.Matrix[1]),m.FromValuesToRef(1,0,0,0,0,1,0,0,l,u,1,0,0,0,0,1,x.Matrix[0]),x.Matrix[1].multiplyToRef(x.Matrix[0],x.Matrix[0]),m.TranslationToRef(0,0,h,x.Matrix[1]),x.Matrix[0].multiplyToRef(x.Matrix[1],x.Matrix[0]),m.OrthoOffCenterLHToRef(t,e,r,s,i,o,c,_),x.Matrix[0].multiplyToRef(c,c),c}static OrthoOffCenterRH(t,e,r,s,i,o,n){const a=new m;return m.OrthoOffCenterRHToRef(t,e,r,s,i,o,a,n),a}static OrthoOffCenterRHToRef(t,e,r,s,i,o,n,a){return m.OrthoOffCenterLHToRef(t,e,r,s,i,o,n,a),n._m[10]*=-1,n}static ObliqueOffCenterRHToRef(t,e,r,s,i,o,n,a,h,c,_){const l=n*Math.cos(a),u=n*Math.sin(a);return m.TranslationToRef(0,0,h,x.Matrix[1]),m.FromValuesToRef(1,0,0,0,0,1,0,0,l,u,1,0,0,0,0,1,x.Matrix[0]),x.Matrix[1].multiplyToRef(x.Matrix[0],x.Matrix[0]),m.TranslationToRef(0,0,-h,x.Matrix[1]),x.Matrix[0].multiplyToRef(x.Matrix[1],x.Matrix[0]),m.OrthoOffCenterRHToRef(t,e,r,s,i,o,c,_),x.Matrix[0].multiplyToRef(c,c),c}static PerspectiveLH(t,e,r,s,i){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const n=new m,a=2*r/t,h=2*r/e,c=(s+r)/(s-r),_=-2*s*r/(s-r),l=Math.tan(o);return m.FromValuesToRef(a,0,0,0,0,h,0,l,0,0,c,1,0,0,_,0,n),i&&n.multiplyToRef(d,n),n._updateIdentityStatus(!1),n}static PerspectiveFovLH(t,e,r,s,i){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,n=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const a=new m;return m.PerspectiveFovLHToRef(t,e,r,s,a,!0,i,o,n),a}static PerspectiveFovLHToRef(t,e,r,s,i){let o=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],n=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,h=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const c=r,_=s,l=1/Math.tan(.5*t),u=o?l/e:l,y=o?l:l*e,x=h&&0===c?-1:0!==_?(_+c)/(_-c):1,R=h&&0===c?2*_:0!==_?-2*_*c/(_-c):-2*c,f=Math.tan(a);return m.FromValuesToRef(u,0,0,0,0,y,0,f,0,0,x,1,0,0,R,0,i),n&&i.multiplyToRef(d,i),i._updateIdentityStatus(!1),i}static PerspectiveFovReverseLHToRef(t,e,r,s,i){let o=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],n=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const h=1/Math.tan(.5*t),c=o?h/e:h,_=o?h:h*e,l=Math.tan(a);return m.FromValuesToRef(c,0,0,0,0,_,0,l,0,0,-r,1,0,0,1,0,i),n&&i.multiplyToRef(d,i),i._updateIdentityStatus(!1),i}static PerspectiveFovRH(t,e,r,s,i){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,n=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const a=new m;return m.PerspectiveFovRHToRef(t,e,r,s,a,!0,i,o,n),a}static PerspectiveFovRHToRef(t,e,r,s,i){let o=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],n=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,h=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const c=r,_=s,l=1/Math.tan(.5*t),u=o?l/e:l,y=o?l:l*e,x=h&&0===c?1:0!==_?-(_+c)/(_-c):-1,R=h&&0===c?2*_:0!==_?-2*_*c/(_-c):-2*c,f=Math.tan(a);return m.FromValuesToRef(u,0,0,0,0,y,0,f,0,0,x,-1,0,0,R,0,i),n&&i.multiplyToRef(d,i),i._updateIdentityStatus(!1),i}static PerspectiveFovReverseRHToRef(t,e,r,s,i){let o=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],n=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const h=1/Math.tan(.5*t),c=o?h/e:h,_=o?h:h*e,l=Math.tan(a);return m.FromValuesToRef(c,0,0,0,0,_,0,l,0,0,-r,-1,0,0,-1,0,i),n&&i.multiplyToRef(d,i),i._updateIdentityStatus(!1),i}static GetFinalMatrix(t,e,r,s,i,o){const n=t.width,a=t.height,h=t.x,c=t.y,_=m.FromValues(n/2,0,0,0,0,-a/2,0,0,0,0,o-i,0,h+n/2,a/2+c,i,1),l=new e.constructor;return e.multiplyToRef(r,l),l.multiplyToRef(s,l),l.multiplyToRef(_,l)}static GetAsMatrix2x2(t){const e=t.m,r=[e[0],e[1],e[4],e[5]];return a.Z.MatrixUse64Bits?r:new Float32Array(r)}static GetAsMatrix3x3(t){const e=t.m,r=[e[0],e[1],e[2],e[4],e[5],e[6],e[8],e[9],e[10]];return a.Z.MatrixUse64Bits?r:new Float32Array(r)}static Transpose(t){const e=new t.constructor;return m.TransposeToRef(t,e),e}static TransposeToRef(t,e){const r=e._m,s=t.m;return r[0]=s[0],r[1]=s[4],r[2]=s[8],r[3]=s[12],r[4]=s[1],r[5]=s[5],r[6]=s[9],r[7]=s[13],r[8]=s[2],r[9]=s[6],r[10]=s[10],r[11]=s[14],r[12]=s[3],r[13]=s[7],r[14]=s[11],r[15]=s[15],e.markAsUpdated(),e._updateIdentityStatus(t._isIdentity,t._isIdentityDirty),e}static Reflection(t){const e=new m;return m.ReflectionToRef(t,e),e}static ReflectionToRef(t,e){t.normalize();const r=t.normal.x,s=t.normal.y,i=t.normal.z,o=-2*r,n=-2*s,a=-2*i;return m.FromValuesToRef(o*r+1,n*r,a*r,0,o*s,n*s+1,a*s,0,o*i,n*i,a*i+1,0,o*t.d,n*t.d,a*t.d,1,e),e}static FromXYZAxesToRef(t,e,r,s){return m.FromValuesToRef(t._x,t._y,t._z,0,e._x,e._y,e._z,0,r._x,r._y,r._z,0,0,0,0,1,s),s}static FromQuaternionToRef(t,e){const r=t._x*t._x,s=t._y*t._y,i=t._z*t._z,o=t._x*t._y,n=t._z*t._w,a=t._z*t._x,h=t._y*t._w,c=t._y*t._z,_=t._x*t._w;return e._m[0]=1-2*(s+i),e._m[1]=2*(o+n),e._m[2]=2*(a-h),e._m[3]=0,e._m[4]=2*(o-n),e._m[5]=1-2*(i+r),e._m[6]=2*(c+_),e._m[7]=0,e._m[8]=2*(a+h),e._m[9]=2*(c-_),e._m[10]=1-2*(s+r),e._m[11]=0,e._m[12]=0,e._m[13]=0,e._m[14]=0,e._m[15]=1,e.markAsUpdated(),e}}m._UpdateFlagSeed=0,m._IdentityReadOnly=m.Identity();class x{}x.Vector3=o.B.BuildTuple(11,l.Zero),x.Matrix=o.B.BuildTuple(2,m.Identity),x.Quaternion=o.B.BuildTuple(3,y.Zero);class R{}R.Vector2=o.B.BuildTuple(3,_.Zero),R.Vector3=o.B.BuildTuple(13,l.Zero),R.Vector4=o.B.BuildTuple(3,u.Zero),R.Quaternion=o.B.BuildTuple(2,y.Zero),R.Matrix=o.B.BuildTuple(8,m.Identity),(0,n.H)("BABYLON.Vector2",_),(0,n.H)("BABYLON.Vector3",l),(0,n.H)("BABYLON.Vector4",u),(0,n.H)("BABYLON.Matrix",m);const d=m.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)}}]);
//# sourceMappingURL=bf235017-6907444e45d963816fb2.js.map