"use strict";(self.webpackChunk_react_babylonjs_docs=self.webpackChunk_react_babylonjs_docs||[]).push([[312],{1441:function(e,t,s){s.d(t,{Kj:function(){return F},gW:function(){return A}});var i=s(94991),n=s(97894),r=s(15412),a=s(99349),o=s(27817),h=s(50422),l=s(56732),c=s(93947),d=s(63747),u=s(19874),f=s(17423),g=s(94516),_=s(57705),m=s(56354),I=s(52234),M=s(26467),v=s(97431),p=s(21628),y=s(50564),D=s(81774),b=s(24237),S=s(55589),x=s(39032),B=s(6346);class A{}class P{constructor(){this.visibleInstances={},this.batchCache=new w,this.batchCacheReplacementModeInFrozenMode=new w,this.instancesBufferSize=2048}}class w{constructor(){this.mustReturn=!1,this.visibleInstances=new Array,this.renderSelf=new Array,this.hardwareInstancedRendering=new Array}}class O{constructor(){this.instancesCount=0,this.matrixBuffer=null,this.previousMatrixBuffer=null,this.matrixBufferSize=512,this.matrixData=null,this.boundingVectors=[],this.worldMatrices=null}}class C{constructor(){this._areNormalsFrozen=!1,this._source=null,this.meshMap=null,this._preActivateId=-1,this._LODLevels=new Array,this._useLODScreenCoverage=!1,this._effectiveMaterial=null,this._forcedInstanceCount=0,this._overrideRenderingFillMode=null}}class F extends m.x{static _GetDefaultSideOrientation(e){return e||F.FRONTSIDE}get useLODScreenCoverage(){return this._internalMeshDataInfo._useLODScreenCoverage}set useLODScreenCoverage(e){this._internalMeshDataInfo._useLODScreenCoverage=e,this._sortLODLevels()}get computeBonesUsingShaders(){return this._internalAbstractMeshDataInfo._computeBonesUsingShaders}set computeBonesUsingShaders(e){this._internalAbstractMeshDataInfo._computeBonesUsingShaders!==e&&(e&&this._internalMeshDataInfo._sourcePositions&&(this.setVerticesData(f.o.PositionKind,this._internalMeshDataInfo._sourcePositions,!0),this._internalMeshDataInfo._sourceNormals&&this.setVerticesData(f.o.NormalKind,this._internalMeshDataInfo._sourceNormals,!0),this._internalMeshDataInfo._sourcePositions=null,this._internalMeshDataInfo._sourceNormals=null),this._internalAbstractMeshDataInfo._computeBonesUsingShaders=e,this._markSubMeshesAsAttributesDirty())}get onBeforeRenderObservable(){return this._internalMeshDataInfo._onBeforeRenderObservable||(this._internalMeshDataInfo._onBeforeRenderObservable=new i.y$),this._internalMeshDataInfo._onBeforeRenderObservable}get onBeforeBindObservable(){return this._internalMeshDataInfo._onBeforeBindObservable||(this._internalMeshDataInfo._onBeforeBindObservable=new i.y$),this._internalMeshDataInfo._onBeforeBindObservable}get onAfterRenderObservable(){return this._internalMeshDataInfo._onAfterRenderObservable||(this._internalMeshDataInfo._onAfterRenderObservable=new i.y$),this._internalMeshDataInfo._onAfterRenderObservable}get onBetweenPassObservable(){return this._internalMeshDataInfo._onBetweenPassObservable||(this._internalMeshDataInfo._onBetweenPassObservable=new i.y$),this._internalMeshDataInfo._onBetweenPassObservable}get onBeforeDrawObservable(){return this._internalMeshDataInfo._onBeforeDrawObservable||(this._internalMeshDataInfo._onBeforeDrawObservable=new i.y$),this._internalMeshDataInfo._onBeforeDrawObservable}set onBeforeDraw(e){this._onBeforeDrawObserver&&this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver),this._onBeforeDrawObserver=this.onBeforeDrawObservable.add(e)}get hasInstances(){return this.instances.length>0}get hasThinInstances(){var e;return(null!==(e=this._thinInstanceDataStorage.instancesCount)&&void 0!==e?e:0)>0}get forcedInstanceCount(){return this._internalMeshDataInfo._forcedInstanceCount}set forcedInstanceCount(e){this._internalMeshDataInfo._forcedInstanceCount=e}get overrideRenderingFillMode(){return this._internalMeshDataInfo._overrideRenderingFillMode}set overrideRenderingFillMode(e){this._internalMeshDataInfo._overrideRenderingFillMode=e}get source(){return this._internalMeshDataInfo._source}get cloneMeshMap(){return this._internalMeshDataInfo.meshMap}get isUnIndexed(){return this._unIndexed}set isUnIndexed(e){this._unIndexed!==e&&(this._unIndexed=e,this._markSubMeshesAsAttributesDirty())}get worldMatrixInstancedBuffer(){return this._instanceDataStorage.instancesData}get previousWorldMatrixInstancedBuffer(){return this._instanceDataStorage.instancesPreviousData}get manualUpdateOfWorldMatrixInstancedBuffer(){return this._instanceDataStorage.manualUpdate}set manualUpdateOfWorldMatrixInstancedBuffer(e){this._instanceDataStorage.manualUpdate=e}get manualUpdateOfPreviousWorldMatrixInstancedBuffer(){return this._instanceDataStorage.previousManualUpdate}set manualUpdateOfPreviousWorldMatrixInstancedBuffer(e){this._instanceDataStorage.previousManualUpdate=e}get forceWorldMatrixInstancedBufferUpdate(){return this._instanceDataStorage.forceMatrixUpdates}set forceWorldMatrixInstancedBufferUpdate(e){this._instanceDataStorage.forceMatrixUpdates=e}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,o=arguments.length>4?arguments[4]:void 0,h=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];if(super(e,t),this._internalMeshDataInfo=new C,this.delayLoadState=0,this.instances=new Array,this._creationDataStorage=null,this._geometry=null,this._instanceDataStorage=new P,this._thinInstanceDataStorage=new O,this._shouldGenerateFlatShading=!1,this._originalBuilderSideOrientation=F.DEFAULTSIDE,this.overrideMaterialSideOrientation=null,this.ignoreCameraMaxZ=!1,t=this.getScene(),this._onBeforeDraw=(e,t,s)=>{e&&s&&(this._uniformBuffer?this.transferToEffect(t):s.bindOnlyWorldMatrix(t))},n){if(n._geometry&&n._geometry.applyToMesh(this),r.j.DeepCopy(n,this,["name","material","skeleton","instances","parent","uniqueId","source","metadata","morphTargetManager","hasInstances","worldMatrixInstancedBuffer","previousWorldMatrixInstancedBuffer","hasLODLevels","geometry","isBlocked","areNormalsFrozen","facetNb","isFacetDataEnabled","lightSources","useBones","isAnInstance","collider","edgesRenderer","forward","up","right","absolutePosition","absoluteScaling","absoluteRotationQuaternion","isWorldMatrixFrozen","nonUniformScaling","behaviors","worldMatrixFromCache","hasThinInstances","cloneMeshMap","hasBoundingInfo"],["_poseMatrix"]),this._internalMeshDataInfo._source=n,t.useClonedMeshMap&&(n._internalMeshDataInfo.meshMap||(n._internalMeshDataInfo.meshMap={}),n._internalMeshDataInfo.meshMap[this.uniqueId]=this),this._originalBuilderSideOrientation=n._originalBuilderSideOrientation,this._creationDataStorage=n._creationDataStorage,n._ranges){const e=n._ranges;for(const t in e)Object.prototype.hasOwnProperty.call(e,t)&&e[t]&&this.createAnimationRange(t,e[t].from,e[t].to)}if(n.metadata&&n.metadata.clone?this.metadata=n.metadata.clone():this.metadata=n.metadata,this._internalMetadata=n._internalMetadata,a.$&&a.$.HasTags(n)&&a.$.AddTagsTo(this,a.$.GetTags(n,!0)),this.setEnabled(n.isEnabled(!1)),this.parent=n.parent,this.setPivotMatrix(n.getPivotMatrix()),this.id=e+"."+n.id,this.material=n.material,!o){const t=n.getDescendants(!0);for(let s=0;s<t.length;s++){const i=t[s];i.clone&&i.clone(e+"."+i.name,this)}}if(n.morphTargetManager&&(this.morphTargetManager=n.morphTargetManager),t.getPhysicsEngine){const e=t.getPhysicsEngine();if(h&&e)if(1===e.getPluginVersion()){const t=e.getImpostorForPhysicsObject(n);t&&(this.physicsImpostor=t.clone(this))}else 2===e.getPluginVersion()&&n.physicsBody&&n.physicsBody.clone(this)}for(let e=0;e<t.particleSystems.length;e++){const s=t.particleSystems[e];s.emitter===n&&s.clone(s.name,this)}this.skeleton=n.skeleton,this.refreshBoundingInfo(!0,!0),this.computeWorldMatrix(!0)}null!==s&&(this.parent=s),this._instanceDataStorage.hardwareInstancedRendering=this.getEngine().getCaps().instancedArrays,this._internalMeshDataInfo._onMeshReadyObserverAdded=e=>{e.unregisterOnNextCall=!0,this.isReady(!0)?this.onMeshReadyObservable.notifyObservers(this):this._internalMeshDataInfo._checkReadinessObserver||(this._internalMeshDataInfo._checkReadinessObserver=this._scene.onBeforeRenderObservable.add((()=>{this.isReady(!0)&&(this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver),this._internalMeshDataInfo._checkReadinessObserver=null,this.onMeshReadyObservable.notifyObservers(this))})))},this.onMeshReadyObservable=new i.y$(this._internalMeshDataInfo._onMeshReadyObserverAdded),n&&n.onClonedObservable.notifyObservers(this)}instantiateHierarchy(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1?arguments[1]:void 0,s=arguments.length>2?arguments[2]:void 0;const i=0===this.getTotalVertices()||t&&t.doNotInstantiate&&(!0===t.doNotInstantiate||t.doNotInstantiate(this))?this.clone("Clone of "+(this.name||this.id),e||this.parent,!0):this.createInstance("instance of "+(this.name||this.id));i.parent=e||this.parent,i.position=this.position.clone(),i.scaling=this.scaling.clone(),this.rotationQuaternion?i.rotationQuaternion=this.rotationQuaternion.clone():i.rotation=this.rotation.clone(),s&&s(this,i);for(const n of this.getChildTransformNodes(!0))"InstancedMesh"===n.getClassName()&&"Mesh"===i.getClassName()&&n.sourceMesh===this?n.instantiateHierarchy(i,{doNotInstantiate:t&&t.doNotInstantiate||!1,newSourcedMesh:i},s):n.instantiateHierarchy(i,t,s);return i}getClassName(){return"Mesh"}get _isMesh(){return!0}toString(e){let t=super.toString(e);if(t+=", n vertices: "+this.getTotalVertices(),t+=", parent: "+(this._waitingParentId?this._waitingParentId:this.parent?this.parent.name:"NONE"),this.animations)for(let s=0;s<this.animations.length;s++)t+=", animation[0]: "+this.animations[s].toString(e);if(e)if(this._geometry){const e=this.getIndices(),s=this.getVerticesData(f.o.PositionKind);s&&e&&(t+=", flat shading: "+(s.length/3===e.length?"YES":"NO"))}else t+=", flat shading: UNKNOWN";return t}_unBindEffect(){super._unBindEffect();for(const e of this.instances)e._unBindEffect()}get hasLODLevels(){return this._internalMeshDataInfo._LODLevels.length>0}getLODLevels(){return this._internalMeshDataInfo._LODLevels}_sortLODLevels(){const e=this._internalMeshDataInfo._useLODScreenCoverage?-1:1;this._internalMeshDataInfo._LODLevels.sort(((t,s)=>t.distanceOrScreenCoverage<s.distanceOrScreenCoverage?e:t.distanceOrScreenCoverage>s.distanceOrScreenCoverage?-e:0))}addLODLevel(e,t){if(t&&t._masterMesh)return D.Y.Warn("You cannot use a mesh as LOD level twice"),this;const s=new B.g(e,t);return this._internalMeshDataInfo._LODLevels.push(s),t&&(t._masterMesh=this),this._sortLODLevels(),this}getLODLevelAtDistance(e){const t=this._internalMeshDataInfo;for(let s=0;s<t._LODLevels.length;s++){const i=t._LODLevels[s];if(i.distanceOrScreenCoverage===e)return i.mesh}return null}removeLODLevel(e){const t=this._internalMeshDataInfo;for(let s=0;s<t._LODLevels.length;s++)t._LODLevels[s].mesh===e&&(t._LODLevels.splice(s,1),e&&(e._masterMesh=null));return this._sortLODLevels(),this}getLOD(e,t){const s=this._internalMeshDataInfo;if(!s._LODLevels||0===s._LODLevels.length)return this;const i=t||this.getBoundingInfo().boundingSphere,n=e.mode===h.V.ORTHOGRAPHIC_CAMERA?e.minZ:i.centerWorld.subtract(e.globalPosition).length();let r=n,a=1;if(s._useLODScreenCoverage){const t=e.screenArea;let s=i.radiusWorld*e.minZ/n;s=s*s*Math.PI,r=s/t,a=-1}if(a*s._LODLevels[s._LODLevels.length-1].distanceOrScreenCoverage>a*r)return this.onLODLevelSelection&&this.onLODLevelSelection(r,this,this),this;for(let o=0;o<s._LODLevels.length;o++){const e=s._LODLevels[o];if(a*e.distanceOrScreenCoverage<a*r){if(e.mesh){if(4===e.mesh.delayLoadState)return e.mesh._checkDelayState(),this;if(2===e.mesh.delayLoadState)return this;e.mesh._preActivate(),e.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache)}return this.onLODLevelSelection&&this.onLODLevelSelection(r,this,e.mesh),e.mesh}}return this.onLODLevelSelection&&this.onLODLevelSelection(r,this,this),this}get geometry(){return this._geometry}getTotalVertices(){return null===this._geometry||void 0===this._geometry?0:this._geometry.getTotalVertices()}getVerticesData(e,t,s,i){var n,r;if(!this._geometry)return null;let a=i||null===(r=null===(n=this._userInstancedBuffersStorage)||void 0===n?void 0:n.vertexBuffers[e])||void 0===r?void 0:r.getFloatData(this.instances.length+1,s||t&&1!==this._geometry.meshes.length);return a||(a=this._geometry.getVerticesData(e,t,s)),a}getVertexBuffer(e,t){var s,i;return this._geometry?null!==(i=t||null===(s=this._userInstancedBuffersStorage)||void 0===s?void 0:s.vertexBuffers[e])&&void 0!==i?i:this._geometry.getVertexBuffer(e):null}isVerticesDataPresent(e,t){var s;return this._geometry?!t&&void 0!==(null===(s=this._userInstancedBuffersStorage)||void 0===s?void 0:s.vertexBuffers[e])||this._geometry.isVerticesDataPresent(e):!!this._delayInfo&&-1!==this._delayInfo.indexOf(e)}isVertexBufferUpdatable(e,t){var s;if(!this._geometry)return!!this._delayInfo&&-1!==this._delayInfo.indexOf(e);if(!t){const t=null===(s=this._userInstancedBuffersStorage)||void 0===s?void 0:s.vertexBuffers[e];if(t)return t.isUpdatable()}return this._geometry.isVertexBufferUpdatable(e)}getVerticesDataKinds(e){if(!this._geometry){const e=new Array;return this._delayInfo&&this._delayInfo.forEach((function(t){e.push(t)})),e}const t=this._geometry.getVerticesDataKinds();if(!e&&this._userInstancedBuffersStorage)for(const s in this._userInstancedBuffersStorage.vertexBuffers)-1===t.indexOf(s)&&t.push(s);return t}getTotalIndices(){return this._geometry?this._geometry.getTotalIndices():0}getIndices(e,t){return this._geometry?this._geometry.getIndices(e,t):[]}get isBlocked(){return null!==this._masterMesh&&void 0!==this._masterMesh}isReady(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];var s,i,n,r,a,o;if(2===this.delayLoadState)return!1;if(!super.isReady(e))return!1;if(!this.subMeshes||0===this.subMeshes.length)return!0;if(!e)return!0;const h=this.getEngine(),l=this.getScene(),c=t||h.getCaps().instancedArrays&&(this.instances.length>0||this.hasThinInstances);this.computeWorldMatrix();const d=this.material||l.defaultMaterial;if(d)if(d._storeEffectOnSubMeshes)for(const f of this.subMeshes){const e=f.getMaterial();if(e)if(e._storeEffectOnSubMeshes){if(!e.isReadyForSubMesh(this,f,c))return!1}else if(!e.isReady(this,c))return!1}else if(!d.isReady(this,c))return!1;const u=h.currentRenderPassId;for(const f of this.lightSources){const e=f.getShadowGenerators();if(!e)continue;const t=e.values();for(let l=t.next();!0!==l.done;l=t.next()){const e=l.value;if(e&&(!(null===(s=e.getShadowMap())||void 0===s?void 0:s.renderList)||(null===(i=e.getShadowMap())||void 0===i?void 0:i.renderList)&&-1!==(null===(r=null===(n=e.getShadowMap())||void 0===n?void 0:n.renderList)||void 0===r?void 0:r.indexOf(this)))){e.getShadowMap()&&(h.currentRenderPassId=e.getShadowMap().renderPassId);for(const t of this.subMeshes)if(!e.isReady(t,c,null!==(o=null===(a=t.getMaterial())||void 0===a?void 0:a.needAlphaBlendingForMesh(this))&&void 0!==o&&o))return h.currentRenderPassId=u,!1;h.currentRenderPassId=u}}}for(const f of this._internalMeshDataInfo._LODLevels)if(f.mesh&&!f.mesh.isReady(c))return!1;return!0}get areNormalsFrozen(){return this._internalMeshDataInfo._areNormalsFrozen}freezeNormals(){return this._internalMeshDataInfo._areNormalsFrozen=!0,this}unfreezeNormals(){return this._internalMeshDataInfo._areNormalsFrozen=!1,this}set overridenInstanceCount(e){this._instanceDataStorage.overridenInstanceCount=e}_preActivate(){const e=this._internalMeshDataInfo,t=this.getScene().getRenderId();return e._preActivateId===t||(e._preActivateId=t,this._instanceDataStorage.visibleInstances=null),this}_preActivateForIntermediateRendering(e){return this._instanceDataStorage.visibleInstances&&(this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId=e),this}_registerInstanceForRenderId(e,t){return this._instanceDataStorage.visibleInstances||(this._instanceDataStorage.visibleInstances={defaultRenderId:t,selfDefaultRenderId:this._renderId}),this._instanceDataStorage.visibleInstances[t]||(void 0!==this._instanceDataStorage.previousRenderId&&this._instanceDataStorage.isFrozen&&(this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId]=null),this._instanceDataStorage.previousRenderId=t,this._instanceDataStorage.visibleInstances[t]=new Array),this._instanceDataStorage.visibleInstances[t].push(e),this}_afterComputeWorldMatrix(){super._afterComputeWorldMatrix(),this.hasThinInstances&&(this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1))}_postActivate(){this.edgesShareWithInstances&&this.edgesRenderer&&this.edgesRenderer.isEnabled&&this._renderingGroup&&(this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer),this.edgesRenderer.customInstances.push(this.getWorldMatrix()))}refreshBoundingInfo(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.hasBoundingInfo&&this.getBoundingInfo().isLocked)return this;const s=this.geometry?this.geometry.boundingBias:null;return this._refreshBoundingInfo(this._getPositionData(e,t),s),this}_createGlobalSubMesh(e){const t=this.getTotalVertices();if(!t||!this.getIndices())return null;if(this.subMeshes&&this.subMeshes.length>0){const s=this.getIndices();if(!s)return null;const i=s.length;let n=!1;if(e)n=!0;else for(const e of this.subMeshes){if(e.indexStart+e.indexCount>i){n=!0;break}if(e.verticesStart+e.verticesCount>t){n=!0;break}}if(!n)return this.subMeshes[0]}return this.releaseSubMeshes(),new I.P(0,0,t,0,this.getTotalIndices(),this)}subdivide(e){if(e<1)return;const t=this.getTotalIndices();let s=t/e|0,i=0;for(;s%3!=0;)s++;this.releaseSubMeshes();for(let n=0;n<e&&!(i>=t);n++)I.P.CreateFromIndices(0,i,n===e-1?t-i:s,this),i+=s;this.synchronizeInstances()}setVerticesData(e,t){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=arguments.length>3?arguments[3]:void 0;if(this._geometry)this._geometry.setVerticesData(e,t,s,i);else{const i=new g.x;i.set(t,e);const n=this.getScene();new _.Z(_.Z.RandomId(),n,i,s,this)}return this}removeVerticesData(e){this._geometry&&this._geometry.removeVerticesData(e)}markVerticesDataAsUpdatable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const s=this.getVertexBuffer(e);s&&s.isUpdatable()!==t&&this.setVerticesData(e,this.getVerticesData(e),t)}setVerticesBuffer(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return this._geometry||(this._geometry=_.Z.CreateGeometryForMesh(this)),this._geometry.setVerticesBuffer(e,null,t),this}updateVerticesData(e,t,s,i){return this._geometry?(i?(this.makeGeometryUnique(),this.updateVerticesData(e,t,s,!1)):this._geometry.updateVerticesData(e,t,s),this):this}updateMeshPositions(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const s=this.getVerticesData(f.o.PositionKind);if(!s)return this;if(e(s),this.updateVerticesData(f.o.PositionKind,s,!1,!1),t){const e=this.getIndices(),t=this.getVerticesData(f.o.NormalKind);if(!t)return this;g.x.ComputeNormals(s,e,t),this.updateVerticesData(f.o.NormalKind,t,!1,!1)}return this}makeGeometryUnique(){if(!this._geometry)return this;if(1===this._geometry.meshes.length)return this;const e=this._geometry,t=this._geometry.copy(_.Z.RandomId());return e.releaseForMesh(this,!0),t.applyToMesh(this),this}setIndices(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(this._geometry)this._geometry.setIndices(e,t,s);else{const t=new g.x;t.indices=e;const i=this.getScene();new _.Z(_.Z.RandomId(),i,t,s,this)}return this}updateIndices(e,t){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return this._geometry?(this._geometry.updateIndices(e,t,s),this):this}toLeftHanded(){return this._geometry?(this._geometry.toLeftHanded(),this):this}_bind(e,t,s){let i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];if(!this._geometry)return this;const n=this.getScene().getEngine();let r;if(this.morphTargetManager&&this.morphTargetManager.isUsingTextureForTargets&&this.morphTargetManager._bind(t),this._unIndexed)r=null;else switch(this._getRenderingFillMode(s)){case M.F.PointFillMode:r=null;break;case M.F.WireFrameFillMode:r=e._getLinesIndexBuffer(this.getIndices(),n);break;default:case M.F.TriangleFillMode:r=this._geometry.getIndexBuffer()}return i&&this._userInstancedBuffersStorage&&!this.hasThinInstances?this._geometry._bind(t,r,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects):this._geometry._bind(t,r),this}_draw(e,t,s){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;this._internalMeshDataInfo._onBeforeDrawObservable&&this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);const i=this.getScene().getEngine();return this._unIndexed||t==M.F.PointFillMode?i.drawArraysType(t,e.verticesStart,e.verticesCount,this.forcedInstanceCount||s):t==M.F.WireFrameFillMode?i.drawElementsType(t,0,e._linesIndexCount,this.forcedInstanceCount||s):i.drawElementsType(t,e.indexStart,e.indexCount,this.forcedInstanceCount||s),this}registerBeforeRender(e){return this.onBeforeRenderObservable.add(e),this}unregisterBeforeRender(e){return this.onBeforeRenderObservable.removeCallback(e),this}registerAfterRender(e){return this.onAfterRenderObservable.add(e),this}unregisterAfterRender(e){return this.onAfterRenderObservable.removeCallback(e),this}_getInstancesRenderList(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this._instanceDataStorage.isFrozen){if(t)return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[e]=!1,this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[e]=!0,this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;if(this._instanceDataStorage.previousBatch)return this._instanceDataStorage.previousBatch}const s=this.getScene(),i=s._isInIntermediateRendering(),n=i?this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate:this._internalAbstractMeshDataInfo._onlyForInstances,r=this._instanceDataStorage.batchCache;if(r.mustReturn=!1,r.renderSelf[e]=t||!n&&this.isEnabled()&&this.isVisible,r.visibleInstances[e]=null,this._instanceDataStorage.visibleInstances&&!t){const t=this._instanceDataStorage.visibleInstances,n=s.getRenderId(),a=i?t.intermediateDefaultRenderId:t.defaultRenderId;r.visibleInstances[e]=t[n],!r.visibleInstances[e]&&a&&(r.visibleInstances[e]=t[a])}return r.hardwareInstancedRendering[e]=!t&&this._instanceDataStorage.hardwareInstancedRendering&&null!==r.visibleInstances[e]&&void 0!==r.visibleInstances[e],this._instanceDataStorage.previousBatch=r,r}_renderWithInstances(e,t,s,i,n){var r;const a=s.visibleInstances[e._id],o=a?a.length:0,h=this._instanceDataStorage,l=h.instancesBufferSize;let d=h.instancesBuffer,u=h.instancesPreviousBuffer;const g=16*(o+1)*4;for(;h.instancesBufferSize<g;)h.instancesBufferSize*=2;h.instancesData&&l==h.instancesBufferSize||(h.instancesData=new Float32Array(h.instancesBufferSize/4)),(this._scene.needsPreviousWorldMatrices&&!h.instancesPreviousData||l!=h.instancesBufferSize)&&(h.instancesPreviousData=new Float32Array(h.instancesBufferSize/4));let _=0,m=0;const I=s.renderSelf[e._id],M=!d||l!==h.instancesBufferSize||this._scene.needsPreviousWorldMatrices&&!h.instancesPreviousBuffer;if(this._instanceDataStorage.manualUpdate||h.isFrozen&&!M)m=(I?1:0)+o;else{const t=this.getWorldMatrix();if(I&&(this._scene.needsPreviousWorldMatrices&&(h.masterMeshPreviousWorldMatrix?(h.masterMeshPreviousWorldMatrix.copyToArray(h.instancesPreviousData,_),h.masterMeshPreviousWorldMatrix.copyFrom(t)):(h.masterMeshPreviousWorldMatrix=t.clone(),h.masterMeshPreviousWorldMatrix.copyToArray(h.instancesPreviousData,_))),t.copyToArray(h.instancesData,_),_+=16,m++),a){if(F.INSTANCEDMESH_SORT_TRANSPARENT&&this._scene.activeCamera&&(null===(r=e.getMaterial())||void 0===r?void 0:r.needAlphaBlendingForMesh(e.getRenderingMesh()))){const e=this._scene.activeCamera.globalPosition;for(let t=0;t<a.length;t++){const s=a[t];s._distanceToCamera=c.P.Distance(s.getBoundingInfo().boundingSphere.centerWorld,e)}a.sort(((e,t)=>e._distanceToCamera>t._distanceToCamera?-1:e._distanceToCamera<t._distanceToCamera?1:0))}for(let e=0;e<a.length;e++){const t=a[e],s=t.getWorldMatrix();s.copyToArray(h.instancesData,_),this._scene.needsPreviousWorldMatrices&&(t._previousWorldMatrix?(t._previousWorldMatrix.copyToArray(h.instancesPreviousData,_),t._previousWorldMatrix.copyFrom(s)):(t._previousWorldMatrix=s.clone(),t._previousWorldMatrix.copyToArray(h.instancesPreviousData,_))),_+=16,m++}}}return M?(d&&d.dispose(),u&&u.dispose(),d=new f.l(n,h.instancesData,!0,16,!1,!0),h.instancesBuffer=d,this._userInstancedBuffersStorage||(this._userInstancedBuffersStorage={data:{},vertexBuffers:{},strides:{},sizes:{},vertexArrayObjects:this.getEngine().getCaps().vertexArrayObject?{}:void 0}),this._userInstancedBuffersStorage.vertexBuffers.world0=d.createVertexBuffer("world0",0,4),this._userInstancedBuffersStorage.vertexBuffers.world1=d.createVertexBuffer("world1",4,4),this._userInstancedBuffersStorage.vertexBuffers.world2=d.createVertexBuffer("world2",8,4),this._userInstancedBuffersStorage.vertexBuffers.world3=d.createVertexBuffer("world3",12,4),this._scene.needsPreviousWorldMatrices&&(u=new f.l(n,h.instancesPreviousData,!0,16,!1,!0),h.instancesPreviousBuffer=u,this._userInstancedBuffersStorage.vertexBuffers.previousWorld0=u.createVertexBuffer("previousWorld0",0,4),this._userInstancedBuffersStorage.vertexBuffers.previousWorld1=u.createVertexBuffer("previousWorld1",4,4),this._userInstancedBuffersStorage.vertexBuffers.previousWorld2=u.createVertexBuffer("previousWorld2",8,4),this._userInstancedBuffersStorage.vertexBuffers.previousWorld3=u.createVertexBuffer("previousWorld3",12,4)),this._invalidateInstanceVertexArrayObject()):this._instanceDataStorage.isFrozen&&!this._instanceDataStorage.forceMatrixUpdates||(d.updateDirectly(h.instancesData,0,m),!this._scene.needsPreviousWorldMatrices||this._instanceDataStorage.manualUpdate&&!this._instanceDataStorage.previousManualUpdate||u.updateDirectly(h.instancesPreviousData,0,m)),this._processInstancedBuffers(a,I),this.getScene()._activeIndices.addCount(e.indexCount*m,!1),n._currentDrawContext&&(n._currentDrawContext.useInstancing=!0),this._bind(e,i,t),this._draw(e,t,m),!this._scene.needsPreviousWorldMatrices||M||!this._instanceDataStorage.manualUpdate||this._instanceDataStorage.isFrozen&&!this._instanceDataStorage.forceMatrixUpdates||this._instanceDataStorage.previousManualUpdate||u.updateDirectly(h.instancesData,0,m),n.unbindInstanceAttributes(),this}_renderWithThinInstances(e,t,s,i){var n,r;const a=null!==(r=null===(n=this._thinInstanceDataStorage)||void 0===n?void 0:n.instancesCount)&&void 0!==r?r:0;this.getScene()._activeIndices.addCount(e.indexCount*a,!1),i._currentDrawContext&&(i._currentDrawContext.useInstancing=!0),this._bind(e,s,t),this._draw(e,t,a),this._scene.needsPreviousWorldMatrices&&!this._thinInstanceDataStorage.previousMatrixData&&this._thinInstanceDataStorage.matrixData&&(this._thinInstanceDataStorage.previousMatrixBuffer?this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData,0,a):this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",this._thinInstanceDataStorage.matrixData,!1)),i.unbindInstanceAttributes()}_processInstancedBuffers(e,t){}_processRendering(e,t,s,i,n,r,a,o){const h=this.getScene(),l=h.getEngine();if(i=this._getRenderingFillMode(i),r&&t.getRenderingMesh().hasThinInstances)return this._renderWithThinInstances(t,i,s,l),this;if(r)this._renderWithInstances(t,i,n,s,l);else{l._currentDrawContext&&(l._currentDrawContext.useInstancing=!1);let s=0;n.renderSelf[t._id]&&(a&&a(!1,e.getWorldMatrix(),o),s++,this._draw(t,i,this._instanceDataStorage.overridenInstanceCount));const r=n.visibleInstances[t._id];if(r){const e=r.length;s+=e;for(let s=0;s<e;s++){const e=r[s].getWorldMatrix();a&&a(!0,e,o),this._draw(t,i)}}h._activeIndices.addCount(t.indexCount*s,!1)}return this}_rebuild(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this._instanceDataStorage.instancesBuffer&&(e&&this._instanceDataStorage.instancesBuffer.dispose(),this._instanceDataStorage.instancesBuffer=null),this._userInstancedBuffersStorage){for(const t in this._userInstancedBuffersStorage.vertexBuffers){const s=this._userInstancedBuffersStorage.vertexBuffers[t];s&&(e&&s.dispose(),this._userInstancedBuffersStorage.vertexBuffers[t]=null)}this._userInstancedBuffersStorage.vertexArrayObjects&&(this._userInstancedBuffersStorage.vertexArrayObjects={})}this._internalMeshDataInfo._effectiveMaterial=null,super._rebuild(e)}_freeze(){if(this.subMeshes){for(let e=0;e<this.subMeshes.length;e++)this._getInstancesRenderList(e);this._internalMeshDataInfo._effectiveMaterial=null,this._instanceDataStorage.isFrozen=!0}}_unFreeze(){this._instanceDataStorage.isFrozen=!1,this._instanceDataStorage.previousBatch=null}render(e,t,s){var i,n,r;const a=this.getScene();if(this._internalAbstractMeshDataInfo._isActiveIntermediate?this._internalAbstractMeshDataInfo._isActiveIntermediate=!1:this._internalAbstractMeshDataInfo._isActive=!1,this._checkOcclusionQuery()&&!this._occlusionDataStorage.forceRenderingWhenOccluded)return this;const o=this._getInstancesRenderList(e._id,!!s);if(o.mustReturn)return this;if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const h=a.getEngine();let c=0,d=null;this.ignoreCameraMaxZ&&a.activeCamera&&!a._isInIntermediateRendering()&&(c=a.activeCamera.maxZ,d=a.activeCamera,a.activeCamera.maxZ=0,a.updateTransformMatrix(!0)),this._internalMeshDataInfo._onBeforeRenderObservable&&this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);const u=e.getRenderingMesh(),f=o.hardwareInstancedRendering[e._id]||u.hasThinInstances||!!this._userInstancedBuffersStorage&&!e.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh,g=this._instanceDataStorage,_=e.getMaterial();if(!_)return d&&(d.maxZ=c,a.updateTransformMatrix(!0)),this;if(g.isFrozen&&this._internalMeshDataInfo._effectiveMaterial&&this._internalMeshDataInfo._effectiveMaterial===_){if(_._storeEffectOnSubMeshes&&!(null===(i=e.effect)||void 0===i?void 0:i._wasPreviouslyReady)||!_._storeEffectOnSubMeshes&&!(null===(n=_.getEffect())||void 0===n?void 0:n._wasPreviouslyReady))return d&&(d.maxZ=c,a.updateTransformMatrix(!0)),this}else{if(_._storeEffectOnSubMeshes){if(!_.isReadyForSubMesh(this,e,f))return d&&(d.maxZ=c,a.updateTransformMatrix(!0)),this}else if(!_.isReady(this,f))return d&&(d.maxZ=c,a.updateTransformMatrix(!0)),this;this._internalMeshDataInfo._effectiveMaterial=_}let m;t&&h.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode),m=this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes?e._drawWrapper:this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();const I=null!==(r=null==m?void 0:m.effect)&&void 0!==r?r:null;for(const l of a._beforeRenderingMeshStage)l.action(this,e,o,I);if(!m||!I)return d&&(d.maxZ=c,a.updateTransformMatrix(!0)),this;const v=s||this;let p;if(g.isFrozen||!this._internalMeshDataInfo._effectiveMaterial.backFaceCulling&&null===this.overrideMaterialSideOrientation)p=g.sideOrientation;else{const e=v._getWorldMatrixDeterminant();p=this.overrideMaterialSideOrientation,null==p&&(p=this._internalMeshDataInfo._effectiveMaterial.sideOrientation),e<0&&(p=p===M.F.ClockWiseSideOrientation?M.F.CounterClockWiseSideOrientation:M.F.ClockWiseSideOrientation),g.sideOrientation=p}const y=this._internalMeshDataInfo._effectiveMaterial._preBind(m,p);this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite&&h.setDepthWrite(!0);const D=this._internalMeshDataInfo._effectiveMaterial,b=D.fillMode;this._internalMeshDataInfo._onBeforeBindObservable&&this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this),f||this._bind(e,I,b,!1);const S=v.getWorldMatrix();D._storeEffectOnSubMeshes?D.bindForSubMesh(S,this,e):D.bind(S,this),!D.backFaceCulling&&D.separateCullingPass&&(h.setState(!0,D.zOffset,!1,!y,D.cullBackFaces,D.stencil,D.zOffsetUnits),this._processRendering(this,e,I,b,o,f,this._onBeforeDraw,this._internalMeshDataInfo._effectiveMaterial),h.setState(!0,D.zOffset,!1,y,D.cullBackFaces,D.stencil,D.zOffsetUnits),this._internalMeshDataInfo._onBetweenPassObservable&&this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(e)),this._processRendering(this,e,I,b,o,f,this._onBeforeDraw,this._internalMeshDataInfo._effectiveMaterial),this._internalMeshDataInfo._effectiveMaterial.unbind();for(const l of a._afterRenderingMeshStage)l.action(this,e,o,I);return this._internalMeshDataInfo._onAfterRenderObservable&&this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this),d&&(d.maxZ=c,a.updateTransformMatrix(!0)),a.performancePriority!==l.a.Aggressive||g.isFrozen||this._freeze(),this}cleanMatrixWeights(){this.isVerticesDataPresent(f.o.MatricesWeightsKind)&&(this.isVerticesDataPresent(f.o.MatricesWeightsExtraKind)?this._normalizeSkinWeightsAndExtra():this._normalizeSkinFourWeights())}_normalizeSkinFourWeights(){const e=this.getVerticesData(f.o.MatricesWeightsKind),t=e.length;for(let s=0;s<t;s+=4){const t=e[s]+e[s+1]+e[s+2]+e[s+3];if(0===t)e[s]=1;else{const i=1/t;e[s]*=i,e[s+1]*=i,e[s+2]*=i,e[s+3]*=i}}this.setVerticesData(f.o.MatricesWeightsKind,e)}_normalizeSkinWeightsAndExtra(){const e=this.getVerticesData(f.o.MatricesWeightsExtraKind),t=this.getVerticesData(f.o.MatricesWeightsKind),s=t.length;for(let i=0;i<s;i+=4){let s=t[i]+t[i+1]+t[i+2]+t[i+3];if(s+=e[i]+e[i+1]+e[i+2]+e[i+3],0===s)t[i]=1;else{const n=1/s;t[i]*=n,t[i+1]*=n,t[i+2]*=n,t[i+3]*=n,e[i]*=n,e[i+1]*=n,e[i+2]*=n,e[i+3]*=n}}this.setVerticesData(f.o.MatricesWeightsKind,t),this.setVerticesData(f.o.MatricesWeightsKind,e)}validateSkinning(){const e=this.getVerticesData(f.o.MatricesWeightsExtraKind),t=this.getVerticesData(f.o.MatricesWeightsKind);if(null===t||null==this.skeleton)return{skinned:!1,valid:!0,report:"not skinned"};const s=t.length;let i=0,n=0,r=0,a=0;const o=null===e?4:8,h=new Array;for(let f=0;f<=o;f++)h[f]=0;for(let f=0;f<s;f+=4){let s=t[f],l=s,c=0===l?0:1;for(let n=1;n<o;n++){const r=n<4?t[f+n]:e[f+n-4];r>s&&i++,0!==r&&c++,l+=r,s=r}if(h[c]++,c>r&&(r=c),0===l)n++;else{const s=1/l;let i=0;for(let n=0;n<o;n++)i+=n<4?Math.abs(t[f+n]-t[f+n]*s):Math.abs(e[f+n-4]-e[f+n-4]*s);i>.001&&a++}}const l=this.skeleton.bones.length,c=this.getVerticesData(f.o.MatricesIndicesKind),d=this.getVerticesData(f.o.MatricesIndicesExtraKind);let u=0;for(let f=0;f<s;f+=4)for(let e=0;e<o;e++){const t=e<4?c[f+e]:d[f+e-4];(t>=l||t<0)&&u++}return{skinned:!0,valid:0===n&&0===a&&0===u,report:"Number of Weights = "+s/4+"\nMaximum influences = "+r+"\nMissing Weights = "+n+"\nNot Sorted = "+i+"\nNot Normalized = "+a+"\nWeightCounts = ["+h+"]\nNumber of bones = "+l+"\nBad Bone Indices = "+u}}_checkDelayState(){const e=this.getScene();return this._geometry?this._geometry.load(e):4===this.delayLoadState&&(this.delayLoadState=2,this._queueLoad(e)),this}_queueLoad(e){e.addPendingData(this);const t=-1!==this.delayLoadingFile.indexOf(".babylonbinarymeshdata");return n.w1.LoadFile(this.delayLoadingFile,(t=>{t instanceof ArrayBuffer?this._delayLoadingFunction(t,this):this._delayLoadingFunction(JSON.parse(t),this),this.instances.forEach((e=>{e.refreshBoundingInfo(),e._syncSubMeshes()})),this.delayLoadState=1,e.removePendingData(this)}),(()=>{}),e.offlineProvider,t),this}isInFrustum(e){return 2!==this.delayLoadState&&(!!super.isInFrustum(e)&&(this._checkDelayState(),!0))}setMaterialById(e){const t=this.getScene().materials;let s;for(s=t.length-1;s>-1;s--)if(t[s].id===e)return this.material=t[s],this;const i=this.getScene().multiMaterials;for(s=i.length-1;s>-1;s--)if(i[s].id===e)return this.material=i[s],this;return this}getAnimatables(){const e=new Array;return this.material&&e.push(this.material),this.skeleton&&e.push(this.skeleton),e}bakeTransformIntoVertices(e){if(!this.isVerticesDataPresent(f.o.PositionKind))return this;const t=this.subMeshes.splice(0);this._resetPointsArrayCache();let s=this.getVerticesData(f.o.PositionKind);const i=c.P.Zero();let n;for(n=0;n<s.length;n+=3)c.P.TransformCoordinatesFromFloatsToRef(s[n],s[n+1],s[n+2],e,i).toArray(s,n);if(this.setVerticesData(f.o.PositionKind,s,this.getVertexBuffer(f.o.PositionKind).isUpdatable()),this.isVerticesDataPresent(f.o.NormalKind)){for(s=this.getVerticesData(f.o.NormalKind),n=0;n<s.length;n+=3)c.P.TransformNormalFromFloatsToRef(s[n],s[n+1],s[n+2],e,i).normalize().toArray(s,n);this.setVerticesData(f.o.NormalKind,s,this.getVertexBuffer(f.o.NormalKind).isUpdatable())}return e.determinant()<0&&this.flipFaces(),this.releaseSubMeshes(),this.subMeshes=t,this}bakeCurrentTransformIntoVertices(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return this.bakeTransformIntoVertices(this.computeWorldMatrix(!0)),this.resetLocalMatrix(e),this}get _positions(){return this._internalAbstractMeshDataInfo._positions?this._internalAbstractMeshDataInfo._positions:this._geometry?this._geometry._positions:null}_resetPointsArrayCache(){return this._geometry&&this._geometry._resetPointsArrayCache(),this}_generatePointsArray(){return!!this._geometry&&this._geometry._generatePointsArray()}clone(){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,t=arguments.length>2?arguments[2]:void 0,s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];return new F(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",this.getScene(),e,this,t,s)}dispose(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.morphTargetManager=null,this._geometry&&this._geometry.releaseForMesh(this,!0);const s=this._internalMeshDataInfo;if(s._onBeforeDrawObservable&&s._onBeforeDrawObservable.clear(),s._onBeforeBindObservable&&s._onBeforeBindObservable.clear(),s._onBeforeRenderObservable&&s._onBeforeRenderObservable.clear(),s._onAfterRenderObservable&&s._onAfterRenderObservable.clear(),s._onBetweenPassObservable&&s._onBetweenPassObservable.clear(),this._scene.useClonedMeshMap){if(s.meshMap)for(const e in s.meshMap){const t=s.meshMap[e];t&&(t._internalMeshDataInfo._source=null,s.meshMap[e]=void 0)}s._source&&s._source._internalMeshDataInfo.meshMap&&(s._source._internalMeshDataInfo.meshMap[this.uniqueId]=void 0)}else{const e=this.getScene().meshes;for(const t of e){const e=t;e._internalMeshDataInfo&&e._internalMeshDataInfo._source&&e._internalMeshDataInfo._source===this&&(e._internalMeshDataInfo._source=null)}}s._source=null,this._instanceDataStorage.visibleInstances={},this._disposeInstanceSpecificData(),this._disposeThinInstanceSpecificData(),this._internalMeshDataInfo._checkReadinessObserver&&this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver),super.dispose(e,t)}_disposeInstanceSpecificData(){}_disposeThinInstanceSpecificData(){}_invalidateInstanceVertexArrayObject(){}applyDisplacementMap(e,t,s,i,r,a){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const h=this.getScene();return n.w1.LoadImage(e,(e=>{const n=e.width,h=e.height,l=this.getEngine().createCanvas(n,h).getContext("2d");l.drawImage(e,0,0);const c=l.getImageData(0,0,n,h).data;this.applyDisplacementMapFromBuffer(c,n,h,t,s,r,a,o),i&&i(this)}),(()=>{}),h.offlineProvider),this}applyDisplacementMapFromBuffer(e,t,s,i,n,r,a){let o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];if(!this.isVerticesDataPresent(f.o.PositionKind)||!this.isVerticesDataPresent(f.o.NormalKind)||!this.isVerticesDataPresent(f.o.UVKind))return D.Y.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing"),this;const h=this.getVerticesData(f.o.PositionKind,!0,!0),l=this.getVerticesData(f.o.NormalKind),d=this.getVerticesData(f.o.UVKind);let u=c.P.Zero();const _=c.P.Zero(),m=c.FM.Zero();r=r||c.FM.Zero(),a=a||new c.FM(1,1);for(let f=0;f<h.length;f+=3){c.P.FromArrayToRef(h,f,u),c.P.FromArrayToRef(l,f,_),c.FM.FromArrayToRef(d,f/3*2,m);const o=4*((Math.abs(m.x*a.x+r.x%1)*(t-1)%t|0)+(Math.abs(m.y*a.y+r.y%1)*(s-1)%s|0)*t),g=.3*(e[o]/255)+.59*(e[o+1]/255)+.11*(e[o+2]/255);_.normalize(),_.scaleInPlace(i+(n-i)*g),u=u.add(_),u.toArray(h,f)}return g.x.ComputeNormals(h,this.getIndices(),l),o?(this.setVerticesData(f.o.PositionKind,h),this.setVerticesData(f.o.NormalKind,l),this.setVerticesData(f.o.UVKind,d)):(this.updateVerticesData(f.o.PositionKind,h),this.updateVerticesData(f.o.NormalKind,l)),this}convertToFlatShadedMesh(){const e=this.getVerticesDataKinds(),t={},s={},i={};let n,r,a=!1;for(n=0;n<e.length;n++){r=e[n];const o=this.getVertexBuffer(r),h=o.getData();(h instanceof Array||h instanceof Float32Array)&&0===h.length||(r!==f.o.NormalKind?(t[r]=o,s[r]=this.getVerticesData(r),i[r]=[]):(a=o.isUpdatable(),e.splice(n,1),n--))}const o=this.subMeshes.slice(0),h=this.getIndices(),l=this.getTotalIndices();let d;for(d=0;d<l;d++){const a=h[d];for(n=0;n<e.length;n++){if(r=e[n],!t[r])continue;const o=t[r].getStrideSize();for(let e=0;e<o;e++)i[r].push(s[r][a*o+e])}}const u=[],g=i[f.o.PositionKind];let _;for(_=this.getScene().useRightHandedSystem?1===this.overrideMaterialSideOrientation:0===this.overrideMaterialSideOrientation,d=0;d<l;d+=3){h[d]=d,h[d+1]=d+1,h[d+2]=d+2;const e=c.P.FromArray(g,3*d),t=c.P.FromArray(g,3*(d+1)),s=c.P.FromArray(g,3*(d+2)),i=e.subtract(t),n=s.subtract(t),r=c.P.Normalize(c.P.Cross(i,n));_&&r.scaleInPlace(-1);for(let a=0;a<3;a++)u.push(r.x),u.push(r.y),u.push(r.z)}for(this.setIndices(h),this.setVerticesData(f.o.NormalKind,u,a),n=0;n<e.length;n++)r=e[n],i[r]&&this.setVerticesData(r,i[r],t[r].isUpdatable());this.releaseSubMeshes();for(let c=0;c<o.length;c++){const e=o[c];I.P.AddToMesh(e.materialIndex,e.indexStart,e.indexCount,e.indexStart,e.indexCount,this)}return this.synchronizeInstances(),this}convertToUnIndexedMesh(){const e=this.getVerticesDataKinds(),t={},s={},i={};let n,r;for(n=0;n<e.length;n++){r=e[n];const a=this.getVertexBuffer(r);t[r]=a,s[r]=t[r].getData(),i[r]=[]}const a=this.subMeshes.slice(0),o=this.getIndices(),h=this.getTotalIndices();let l;for(l=0;l<h;l++){const a=o[l];for(n=0;n<e.length;n++){r=e[n];const o=t[r].getStrideSize();for(let e=0;e<o;e++)i[r].push(s[r][a*o+e])}}for(l=0;l<h;l+=3)o[l]=l,o[l+1]=l+1,o[l+2]=l+2;for(this.setIndices(o),n=0;n<e.length;n++)r=e[n],this.setVerticesData(r,i[r],t[r].isUpdatable(),t[r].getStrideSize());this.releaseSubMeshes();for(let c=0;c<a.length;c++){const e=a[c];I.P.AddToMesh(e.materialIndex,e.indexStart,e.indexCount,e.indexStart,e.indexCount,this)}return this._unIndexed=!0,this.synchronizeInstances(),this}flipFaces(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const t=g.x.ExtractFromMesh(this);let s;if(e&&this.isVerticesDataPresent(f.o.NormalKind)&&t.normals)for(s=0;s<t.normals.length;s++)t.normals[s]*=-1;if(t.indices){let e;for(s=0;s<t.indices.length;s+=3)e=t.indices[s+1],t.indices[s+1]=t.indices[s+2],t.indices[s+2]=e}return t.applyToMesh(this,this.isVertexBufferUpdatable(f.o.PositionKind)),this}increaseVertices(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;const t=g.x.ExtractFromMesh(this),s=t.indices&&!Array.isArray(t.indices)&&Array.from?Array.from(t.indices):t.indices,i=t.positions&&!Array.isArray(t.positions)&&Array.from?Array.from(t.positions):t.positions,n=t.uvs&&!Array.isArray(t.uvs)&&Array.from?Array.from(t.uvs):t.uvs,r=t.normals&&!Array.isArray(t.normals)&&Array.from?Array.from(t.normals):t.normals;if(s&&i){t.indices=s,t.positions=i,n&&(t.uvs=n),r&&(t.normals=r);const a=e+1,o=new Array;for(let e=0;e<a+1;e++)o[e]=new Array;let h,l;const d=new c.P(0,0,0),u=new c.P(0,0,0),g=new c.FM(0,0),_=new Array,m=new Array,I=new Array;let M,v,p,y=i.length;n&&(v=n.length),r&&(p=r.length);for(let e=0;e<s.length;e+=3){m[0]=s[e],m[1]=s[e+1],m[2]=s[e+2];for(let e=0;e<3;e++)if(h=m[e],l=m[(e+1)%3],void 0===I[h]&&void 0===I[l]?(I[h]=new Array,I[l]=new Array):(void 0===I[h]&&(I[h]=new Array),void 0===I[l]&&(I[l]=new Array)),void 0===I[h][l]&&void 0===I[l][h]){I[h][l]=[],d.x=(i[3*l]-i[3*h])/a,d.y=(i[3*l+1]-i[3*h+1])/a,d.z=(i[3*l+2]-i[3*h+2])/a,r&&(u.x=(r[3*l]-r[3*h])/a,u.y=(r[3*l+1]-r[3*h+1])/a,u.z=(r[3*l+2]-r[3*h+2])/a),n&&(g.x=(n[2*l]-n[2*h])/a,g.y=(n[2*l+1]-n[2*h+1])/a),I[h][l].push(h);for(let e=1;e<a;e++)I[h][l].push(i.length/3),i[y++]=i[3*h]+e*d.x,i[y++]=i[3*h+1]+e*d.y,i[y++]=i[3*h+2]+e*d.z,r&&(r[p++]=r[3*h]+e*u.x,r[p++]=r[3*h+1]+e*u.y,r[p++]=r[3*h+2]+e*u.z),n&&(n[v++]=n[2*h]+e*g.x,n[v++]=n[2*h+1]+e*g.y);I[h][l].push(l),I[l][h]=new Array,M=I[h][l].length;for(let e=0;e<M;e++)I[l][h][e]=I[h][l][M-1-e]}o[0][0]=s[e],o[1][0]=I[s[e]][s[e+1]][1],o[1][1]=I[s[e]][s[e+2]][1];for(let t=2;t<a;t++){o[t][0]=I[s[e]][s[e+1]][t],o[t][t]=I[s[e]][s[e+2]][t],d.x=(i[3*o[t][t]]-i[3*o[t][0]])/t,d.y=(i[3*o[t][t]+1]-i[3*o[t][0]+1])/t,d.z=(i[3*o[t][t]+2]-i[3*o[t][0]+2])/t,r&&(u.x=(r[3*o[t][t]]-r[3*o[t][0]])/t,u.y=(r[3*o[t][t]+1]-r[3*o[t][0]+1])/t,u.z=(r[3*o[t][t]+2]-r[3*o[t][0]+2])/t),n&&(g.x=(n[2*o[t][t]]-n[2*o[t][0]])/t,g.y=(n[2*o[t][t]+1]-n[2*o[t][0]+1])/t);for(let e=1;e<t;e++)o[t][e]=i.length/3,i[y++]=i[3*o[t][0]]+e*d.x,i[y++]=i[3*o[t][0]+1]+e*d.y,i[y++]=i[3*o[t][0]+2]+e*d.z,r&&(r[p++]=r[3*o[t][0]]+e*u.x,r[p++]=r[3*o[t][0]+1]+e*u.y,r[p++]=r[3*o[t][0]+2]+e*u.z),n&&(n[v++]=n[2*o[t][0]]+e*g.x,n[v++]=n[2*o[t][0]+1]+e*g.y)}o[a]=I[s[e+1]][s[e+2]],_.push(o[0][0],o[1][0],o[1][1]);for(let e=1;e<a;e++){let t;for(t=0;t<e;t++)_.push(o[e][t],o[e+1][t],o[e+1][t+1]),_.push(o[e][t],o[e+1][t+1],o[e][t+1]);_.push(o[e][t],o[e+1][t],o[e+1][t+1])}}t.indices=_,t.applyToMesh(this,this.isVertexBufferUpdatable(f.o.PositionKind))}else D.Y.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions")}forceSharedVertices(){const e=g.x.ExtractFromMesh(this),t=e.uvs,s=e.indices,i=e.positions,n=e.colors,r=e.matricesIndices,a=e.matricesWeights,o=e.matricesIndicesExtra,h=e.matricesWeightsExtra;if(void 0===s||void 0===i||null===s||null===i)D.Y.Warn("VertexData contains empty entries");else{const l=new Array,c=new Array,d=new Array,u=new Array,_=new Array,m=new Array,I=new Array,M=new Array;let v=new Array,p=0;const y={};let D,b;for(let e=0;e<s.length;e+=3){b=[s[e],s[e+1],s[e+2]],v=new Array;for(let e=0;e<3;e++){v[e]="";for(let t=0;t<3;t++)Math.abs(i[3*b[e]+t])<1e-8&&(i[3*b[e]+t]=0),v[e]+=i[3*b[e]+t]+"|"}if(v[0]!=v[1]&&v[0]!=v[2]&&v[1]!=v[2])for(let e=0;e<3;e++){if(D=y[v[e]],void 0===D){y[v[e]]=p,D=p++;for(let t=0;t<3;t++)l.push(i[3*b[e]+t]);if(null!=n)for(let t=0;t<4;t++)u.push(n[4*b[e]+t]);if(null!=t)for(let s=0;s<2;s++)d.push(t[2*b[e]+s]);if(null!=r)for(let t=0;t<4;t++)_.push(r[4*b[e]+t]);if(null!=a)for(let t=0;t<4;t++)m.push(a[4*b[e]+t]);if(null!=o)for(let t=0;t<4;t++)I.push(o[4*b[e]+t]);if(null!=h)for(let t=0;t<4;t++)M.push(h[4*b[e]+t])}c.push(D)}}const S=new Array;g.x.ComputeNormals(l,c,S),e.positions=l,e.indices=c,e.normals=S,null!=t&&(e.uvs=d),null!=n&&(e.colors=u),null!=r&&(e.matricesIndices=_),null!=a&&(e.matricesWeights=m),null!=o&&(e.matricesIndicesExtra=I),null!=a&&(e.matricesWeightsExtra=M),e.applyToMesh(this,this.isVertexBufferUpdatable(f.o.PositionKind))}}static _instancedMeshFactory(e,t){throw(0,S.S)("InstancedMesh")}static _PhysicsImpostorParser(e,t,s){throw(0,S.S)("PhysicsImpostor")}createInstance(e){return F._instancedMeshFactory(e,this)}synchronizeInstances(){for(let e=0;e<this.instances.length;e++){this.instances[e]._syncSubMeshes()}return this}optimizeIndices(e){const t=this.getIndices(),s=this.getVerticesData(f.o.PositionKind);if(!s||!t)return this;const i=new Array;for(let n=0;n<s.length;n+=3)i.push(c.P.FromArray(s,n));const r=new Array;return n.$g.SyncAsyncForLoop(i.length,40,(e=>{const t=i.length-1-e,s=i[t];for(let n=0;n<t;++n){const e=i[n];if(s.equals(e)){r[t]=n;break}}}),(()=>{for(let e=0;e<t.length;++e)t[e]=r[t[e]]||t[e];const s=this.subMeshes.slice(0);this.setIndices(t),this.subMeshes=s,e&&e(this)})),this}serialize(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};e.name=this.name,e.id=this.id,e.uniqueId=this.uniqueId,e.type=this.getClassName(),a.$&&a.$.HasTags(this)&&(e.tags=a.$.GetTags(this)),e.position=this.position.asArray(),this.rotationQuaternion?e.rotationQuaternion=this.rotationQuaternion.asArray():this.rotation&&(e.rotation=this.rotation.asArray()),e.scaling=this.scaling.asArray(),this._postMultiplyPivotMatrix?e.pivotMatrix=this.getPivotMatrix().asArray():e.localMatrix=this.getPivotMatrix().asArray(),e.isEnabled=this.isEnabled(!1),e.isVisible=this.isVisible,e.infiniteDistance=this.infiniteDistance,e.pickable=this.isPickable,e.receiveShadows=this.receiveShadows,e.billboardMode=this.billboardMode,e.visibility=this.visibility,e.checkCollisions=this.checkCollisions,e.isBlocker=this.isBlocker,e.overrideMaterialSideOrientation=this.overrideMaterialSideOrientation,this.parent&&this.parent._serializeAsParent(e),e.isUnIndexed=this.isUnIndexed;const t=this._geometry;if(t&&this.subMeshes){e.geometryUniqueId=t.uniqueId,e.geometryId=t.id,e.subMeshes=[];for(let t=0;t<this.subMeshes.length;t++){const s=this.subMeshes[t];e.subMeshes.push({materialIndex:s.materialIndex,verticesStart:s.verticesStart,verticesCount:s.verticesCount,indexStart:s.indexStart,indexCount:s.indexCount})}}if(this.material?this.material.doNotSerialize||(e.materialUniqueId=this.material.uniqueId,e.materialId=this.material.id):(this.material=null,e.materialUniqueId=this._scene.defaultMaterial.uniqueId,e.materialId=this._scene.defaultMaterial.id),this.morphTargetManager&&(e.morphTargetManagerId=this.morphTargetManager.uniqueId),this.skeleton&&(e.skeletonId=this.skeleton.id,e.numBoneInfluencers=this.numBoneInfluencers),this.getScene()._getComponent(x.l.NAME_PHYSICSENGINE)){const t=this.getPhysicsImpostor();t&&(e.physicsMass=t.getParam("mass"),e.physicsFriction=t.getParam("friction"),e.physicsRestitution=t.getParam("mass"),e.physicsImpostor=t.type)}this.metadata&&(e.metadata=this.metadata),e.instances=[];for(let s=0;s<this.instances.length;s++){const t=this.instances[s];if(t.doNotSerialize)continue;const i={name:t.name,id:t.id,isEnabled:t.isEnabled(!1),isVisible:t.isVisible,isPickable:t.isPickable,checkCollisions:t.checkCollisions,position:t.position.asArray(),scaling:t.scaling.asArray()};if(t.parent&&t.parent._serializeAsParent(i),t.rotationQuaternion?i.rotationQuaternion=t.rotationQuaternion.asArray():t.rotation&&(i.rotation=t.rotation.asArray()),this.getScene()._getComponent(x.l.NAME_PHYSICSENGINE)){const e=t.getPhysicsImpostor();e&&(i.physicsMass=e.getParam("mass"),i.physicsFriction=e.getParam("friction"),i.physicsRestitution=e.getParam("mass"),i.physicsImpostor=e.type)}t.metadata&&(i.metadata=t.metadata),t.actionManager&&(i.actions=t.actionManager.serialize(t.name)),e.instances.push(i),y.p4.AppendSerializedAnimations(t,i),i.ranges=t.serializeAnimationRanges()}if(this._thinInstanceDataStorage.instancesCount&&this._thinInstanceDataStorage.matrixData&&(e.thinInstances={instancesCount:this._thinInstanceDataStorage.instancesCount,matrixData:Array.from(this._thinInstanceDataStorage.matrixData),matrixBufferSize:this._thinInstanceDataStorage.matrixBufferSize,enablePicking:this.thinInstanceEnablePicking},this._userThinInstanceBuffersStorage)){const t={data:{},sizes:{},strides:{}};for(const e in this._userThinInstanceBuffersStorage.data)t.data[e]=Array.from(this._userThinInstanceBuffersStorage.data[e]),t.sizes[e]=this._userThinInstanceBuffersStorage.sizes[e],t.strides[e]=this._userThinInstanceBuffersStorage.strides[e];e.thinInstances.userThinInstance=t}return y.p4.AppendSerializedAnimations(this,e),e.ranges=this.serializeAnimationRanges(),e.layerMask=this.layerMask,e.alphaIndex=this.alphaIndex,e.hasVertexAlpha=this.hasVertexAlpha,e.overlayAlpha=this.overlayAlpha,e.overlayColor=this.overlayColor.asArray(),e.renderOverlay=this.renderOverlay,e.applyFog=this.applyFog,this.actionManager&&(e.actions=this.actionManager.serialize(this.name)),e}_syncGeometryWithMorphTargetManager(){if(!this.geometry)return;this._markSubMeshesAsAttributesDirty();const e=this._internalAbstractMeshDataInfo._morphTargetManager;if(e&&e.vertexCount){if(e.vertexCount!==this.getTotalVertices())return D.Y.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count."),void(this.morphTargetManager=null);if(e.isUsingTextureForTargets)return;for(let t=0;t<e.numInfluencers;t++){const s=e.getActiveTarget(t),i=s.getPositions();if(!i)return void D.Y.Error("Invalid morph target. Target must have positions.");this.geometry.setVerticesData(f.o.PositionKind+t,i,!1,3);const n=s.getNormals();n&&this.geometry.setVerticesData(f.o.NormalKind+t,n,!1,3);const r=s.getTangents();r&&this.geometry.setVerticesData(f.o.TangentKind+t,r,!1,3);const a=s.getUVs();a&&this.geometry.setVerticesData(f.o.UVKind+"_"+t,a,!1,2)}}else{let e=0;for(;this.geometry.isVerticesDataPresent(f.o.PositionKind+e);)this.geometry.removeVerticesData(f.o.PositionKind+e),this.geometry.isVerticesDataPresent(f.o.NormalKind+e)&&this.geometry.removeVerticesData(f.o.NormalKind+e),this.geometry.isVerticesDataPresent(f.o.TangentKind+e)&&this.geometry.removeVerticesData(f.o.TangentKind+e),this.geometry.isVerticesDataPresent(f.o.UVKind+e)&&this.geometry.removeVerticesData(f.o.UVKind+"_"+e),e++}}static Parse(e,t,s){let i;if(i=e.type&&"LinesMesh"===e.type?F._LinesMeshParser(e,t):e.type&&"GroundMesh"===e.type?F._GroundMeshParser(e,t):e.type&&"GoldbergMesh"===e.type?F._GoldbergMeshParser(e,t):new F(e.name,t),i.id=e.id,i._waitingParsedUniqueId=e.uniqueId,a.$&&a.$.AddTagsTo(i,e.tags),i.position=c.P.FromArray(e.position),void 0!==e.metadata&&(i.metadata=e.metadata),e.rotationQuaternion?i.rotationQuaternion=c._f.FromArray(e.rotationQuaternion):e.rotation&&(i.rotation=c.P.FromArray(e.rotation)),i.scaling=c.P.FromArray(e.scaling),e.localMatrix?i.setPreTransformMatrix(c.y3.FromArray(e.localMatrix)):e.pivotMatrix&&i.setPivotMatrix(c.y3.FromArray(e.pivotMatrix)),i.setEnabled(e.isEnabled),i.isVisible=e.isVisible,i.infiniteDistance=e.infiniteDistance,i.showBoundingBox=e.showBoundingBox,i.showSubMeshesBoundingBox=e.showSubMeshesBoundingBox,void 0!==e.applyFog&&(i.applyFog=e.applyFog),void 0!==e.pickable&&(i.isPickable=e.pickable),void 0!==e.alphaIndex&&(i.alphaIndex=e.alphaIndex),i.receiveShadows=e.receiveShadows,void 0!==e.billboardMode&&(i.billboardMode=e.billboardMode),void 0!==e.visibility&&(i.visibility=e.visibility),i.checkCollisions=e.checkCollisions,i.overrideMaterialSideOrientation=e.overrideMaterialSideOrientation,void 0!==e.isBlocker&&(i.isBlocker=e.isBlocker),i._shouldGenerateFlatShading=e.useFlatShading,e.freezeWorldMatrix&&(i._waitingData.freezeWorldMatrix=e.freezeWorldMatrix),void 0!==e.parentId&&(i._waitingParentId=e.parentId),void 0!==e.parentInstanceIndex&&(i._waitingParentInstanceIndex=e.parentInstanceIndex),void 0!==e.actions&&(i._waitingData.actions=e.actions),void 0!==e.overlayAlpha&&(i.overlayAlpha=e.overlayAlpha),void 0!==e.overlayColor&&(i.overlayColor=d.Wo.FromArray(e.overlayColor)),void 0!==e.renderOverlay&&(i.renderOverlay=e.renderOverlay),i.isUnIndexed=!!e.isUnIndexed,i.hasVertexAlpha=e.hasVertexAlpha,e.delayLoadingFile?(i.delayLoadState=4,i.delayLoadingFile=s+e.delayLoadingFile,i.buildBoundingInfo(c.P.FromArray(e.boundingBoxMinimum),c.P.FromArray(e.boundingBoxMaximum)),e._binaryInfo&&(i._binaryInfo=e._binaryInfo),i._delayInfo=[],e.hasUVs&&i._delayInfo.push(f.o.UVKind),e.hasUVs2&&i._delayInfo.push(f.o.UV2Kind),e.hasUVs3&&i._delayInfo.push(f.o.UV3Kind),e.hasUVs4&&i._delayInfo.push(f.o.UV4Kind),e.hasUVs5&&i._delayInfo.push(f.o.UV5Kind),e.hasUVs6&&i._delayInfo.push(f.o.UV6Kind),e.hasColors&&i._delayInfo.push(f.o.ColorKind),e.hasMatricesIndices&&i._delayInfo.push(f.o.MatricesIndicesKind),e.hasMatricesWeights&&i._delayInfo.push(f.o.MatricesWeightsKind),i._delayLoadingFunction=_.Z._ImportGeometry,p.Z.ForceFullSceneLoadingForIncremental&&i._checkDelayState()):_.Z._ImportGeometry(e,i),e.materialUniqueId?i._waitingMaterialId=e.materialUniqueId:e.materialId&&(i._waitingMaterialId=e.materialId),e.morphTargetManagerId>-1&&(i.morphTargetManager=t.getMorphTargetManagerById(e.morphTargetManagerId)),void 0!==e.skeletonId&&null!==e.skeletonId&&(i.skeleton=t.getLastSkeletonById(e.skeletonId),e.numBoneInfluencers&&(i.numBoneInfluencers=e.numBoneInfluencers)),e.animations){for(let t=0;t<e.animations.length;t++){const s=e.animations[t],n=(0,b.q)("BABYLON.Animation");n&&i.animations.push(n.Parse(s))}u.N.ParseAnimationRanges(i,e,t)}if(e.autoAnimate&&t.beginAnimation(i,e.autoAnimateFrom,e.autoAnimateTo,e.autoAnimateLoop,e.autoAnimateSpeed||1),e.layerMask&&!isNaN(e.layerMask)?i.layerMask=Math.abs(parseInt(e.layerMask)):i.layerMask=268435455,e.physicsImpostor&&F._PhysicsImpostorParser(t,i,e),e.lodMeshIds&&(i._waitingData.lods={ids:e.lodMeshIds,distances:e.lodDistances?e.lodDistances:null,coverages:e.lodCoverages?e.lodCoverages:null}),e.instances)for(let n=0;n<e.instances.length;n++){const s=e.instances[n],r=i.createInstance(s.name);if(s.id&&(r.id=s.id),a.$&&(s.tags?a.$.AddTagsTo(r,s.tags):a.$.AddTagsTo(r,e.tags)),r.position=c.P.FromArray(s.position),void 0!==s.metadata&&(r.metadata=s.metadata),void 0!==s.parentId&&(r._waitingParentId=s.parentId),void 0!==s.parentInstanceIndex&&(r._waitingParentInstanceIndex=s.parentInstanceIndex),void 0!==s.isEnabled&&null!==s.isEnabled&&r.setEnabled(s.isEnabled),void 0!==s.isVisible&&null!==s.isVisible&&(r.isVisible=s.isVisible),void 0!==s.isPickable&&null!==s.isPickable&&(r.isPickable=s.isPickable),s.rotationQuaternion?r.rotationQuaternion=c._f.FromArray(s.rotationQuaternion):s.rotation&&(r.rotation=c.P.FromArray(s.rotation)),r.scaling=c.P.FromArray(s.scaling),null!=s.checkCollisions&&null!=s.checkCollisions&&(r.checkCollisions=s.checkCollisions),null!=s.pickable&&null!=s.pickable&&(r.isPickable=s.pickable),null!=s.showBoundingBox&&null!=s.showBoundingBox&&(r.showBoundingBox=s.showBoundingBox),null!=s.showSubMeshesBoundingBox&&null!=s.showSubMeshesBoundingBox&&(r.showSubMeshesBoundingBox=s.showSubMeshesBoundingBox),null!=s.alphaIndex&&null!=s.showSubMeshesBoundingBox&&(r.alphaIndex=s.alphaIndex),s.physicsImpostor&&F._PhysicsImpostorParser(t,r,s),void 0!==s.actions&&(r._waitingData.actions=s.actions),s.animations){for(let e=0;e<s.animations.length;e++){const t=s.animations[e],i=(0,b.q)("BABYLON.Animation");i&&r.animations.push(i.Parse(t))}u.N.ParseAnimationRanges(r,s,t),s.autoAnimate&&t.beginAnimation(r,s.autoAnimateFrom,s.autoAnimateTo,s.autoAnimateLoop,s.autoAnimateSpeed||1)}}if(e.thinInstances){const t=e.thinInstances;if(i.thinInstanceEnablePicking=!!t.enablePicking,t.matrixData?(i.thinInstanceSetBuffer("matrix",new Float32Array(t.matrixData),16,!1),i._thinInstanceDataStorage.matrixBufferSize=t.matrixBufferSize,i._thinInstanceDataStorage.instancesCount=t.instancesCount):i._thinInstanceDataStorage.matrixBufferSize=t.matrixBufferSize,e.thinInstances.userThinInstance){const t=e.thinInstances.userThinInstance;for(const e in t.data)i.thinInstanceSetBuffer(e,new Float32Array(t.data[e]),t.strides[e],!1),i._userThinInstanceBuffersStorage.sizes[e]=t.sizes[e]}}return i}setPositionsForCPUSkinning(){const e=this._internalMeshDataInfo;if(!e._sourcePositions){const t=this.getVerticesData(f.o.PositionKind);if(!t)return e._sourcePositions;e._sourcePositions=new Float32Array(t),this.isVertexBufferUpdatable(f.o.PositionKind)||this.setVerticesData(f.o.PositionKind,t,!0)}return e._sourcePositions}setNormalsForCPUSkinning(){const e=this._internalMeshDataInfo;if(!e._sourceNormals){const t=this.getVerticesData(f.o.NormalKind);if(!t)return e._sourceNormals;e._sourceNormals=new Float32Array(t),this.isVertexBufferUpdatable(f.o.NormalKind)||this.setVerticesData(f.o.NormalKind,t,!0)}return e._sourceNormals}applySkeleton(e){if(!this.geometry)return this;if(this.geometry._softwareSkinningFrameId==this.getScene().getFrameId())return this;if(this.geometry._softwareSkinningFrameId=this.getScene().getFrameId(),!this.isVerticesDataPresent(f.o.PositionKind))return this;if(!this.isVerticesDataPresent(f.o.MatricesIndicesKind))return this;if(!this.isVerticesDataPresent(f.o.MatricesWeightsKind))return this;const t=this.isVerticesDataPresent(f.o.NormalKind),s=this._internalMeshDataInfo;if(!s._sourcePositions){const e=this.subMeshes.slice();this.setPositionsForCPUSkinning(),this.subMeshes=e}t&&!s._sourceNormals&&this.setNormalsForCPUSkinning();let i=this.getVerticesData(f.o.PositionKind);if(!i)return this;i instanceof Float32Array||(i=new Float32Array(i));let n=this.getVerticesData(f.o.NormalKind);if(t){if(!n)return this;n instanceof Float32Array||(n=new Float32Array(n))}const r=this.getVerticesData(f.o.MatricesIndicesKind),a=this.getVerticesData(f.o.MatricesWeightsKind);if(!a||!r)return this;const o=this.numBoneInfluencers>4,h=o?this.getVerticesData(f.o.MatricesIndicesExtraKind):null,l=o?this.getVerticesData(f.o.MatricesWeightsExtraKind):null,d=e.getTransformMatrices(this),u=c.P.Zero(),g=new c.y3,_=new c.y3;let m,I=0;for(let f=0;f<i.length;f+=3,I+=4){let e;for(m=0;m<4;m++)e=a[I+m],e>0&&(c.y3.FromFloat32ArrayToRefScaled(d,Math.floor(16*r[I+m]),e,_),g.addToSelf(_));if(o)for(m=0;m<4;m++)e=l[I+m],e>0&&(c.y3.FromFloat32ArrayToRefScaled(d,Math.floor(16*h[I+m]),e,_),g.addToSelf(_));c.P.TransformCoordinatesFromFloatsToRef(s._sourcePositions[f],s._sourcePositions[f+1],s._sourcePositions[f+2],g,u),u.toArray(i,f),t&&(c.P.TransformNormalFromFloatsToRef(s._sourceNormals[f],s._sourceNormals[f+1],s._sourceNormals[f+2],g,u),u.toArray(n,f)),g.reset()}return this.updateVerticesData(f.o.PositionKind,i),t&&this.updateVerticesData(f.o.NormalKind,n),this}static MinMax(e){let t=null,s=null;return e.forEach((function(e){const i=e.getBoundingInfo().boundingBox;t&&s?(t.minimizeInPlace(i.minimumWorld),s.maximizeInPlace(i.maximumWorld)):(t=i.minimumWorld,s=i.maximumWorld)})),t&&s?{min:t,max:s}:{min:c.P.Zero(),max:c.P.Zero()}}static Center(e){const t=e instanceof Array?F.MinMax(e):e;return c.P.Center(t.min,t.max)}static MergeMeshes(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],s=arguments.length>2?arguments[2]:void 0,i=arguments.length>3?arguments[3]:void 0,n=arguments.length>4?arguments[4]:void 0,r=arguments.length>5?arguments[5]:void 0;return(0,o.s3)(F._MergeMeshesCoroutine(e,t,s,i,n,r,!1))}static MergeMeshesAsync(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],s=arguments.length>2?arguments[2]:void 0,i=arguments.length>3?arguments[3]:void 0,n=arguments.length>4?arguments[4]:void 0,r=arguments.length>5?arguments[5]:void 0;return(0,o.sM)(F._MergeMeshesCoroutine(e,t,s,i,n,r,!0),(0,o.KO)())}static _MergeMeshesCoroutine(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],s=arguments.length>2?arguments[2]:void 0,i=arguments.length>3?arguments[3]:void 0,n=arguments.length>4?arguments[4]:void 0,r=arguments.length>5?arguments[5]:void 0,a=arguments.length>6?arguments[6]:void 0;return function*(){if(0===(e=e.filter(Boolean)).length)return null;let o;if(!s){let t=0;for(o=0;o<e.length;o++)if(t+=e[o].getTotalVertices(),t>=65536)return D.Y.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices"),null}r&&(n=!1);const h=new Array,l=new Array,c=new Array,d=e[0].overrideMaterialSideOrientation;for(o=0;o<e.length;o++){const t=e[o];if(t.isAnInstance)return D.Y.Warn("Cannot merge instance meshes."),null;if(d!==t.overrideMaterialSideOrientation)return D.Y.Warn("Cannot merge meshes with different overrideMaterialSideOrientation values."),null;if(n&&c.push(t.getTotalIndices()),r)if(t.material){const e=t.material;if(e instanceof v.G){for(let t=0;t<e.subMaterials.length;t++)h.indexOf(e.subMaterials[t])<0&&h.push(e.subMaterials[t]);for(let s=0;s<t.subMeshes.length;s++)l.push(h.indexOf(e.subMaterials[t.subMeshes[s].materialIndex])),c.push(t.subMeshes[s].indexCount)}else{h.indexOf(e)<0&&h.push(e);for(let s=0;s<t.subMeshes.length;s++)l.push(h.indexOf(e)),c.push(t.subMeshes[s].indexCount)}}else for(let e=0;e<t.subMeshes.length;e++)l.push(0),c.push(t.subMeshes[e].indexCount)}const u=e[0],f=e=>{const t=e.computeWorldMatrix(!0);return{vertexData:g.x.ExtractFromMesh(e,!1,!1),transform:t}},{vertexData:_,transform:m}=f(u);a&&(yield);const M=new Array(e.length-1);for(let t=1;t<e.length;t++)M[t-1]=f(e[t]),a&&(yield);const p=_._mergeCoroutine(m,M,s,a,!t);let y=p.next();for(;!y.done;)a&&(yield),y=p.next();const b=y.value;i||(i=new F(u.name+"_merged",u.getScene()));const S=b._applyToCoroutine(i,void 0,a);let x=S.next();for(;!x.done;)a&&(yield),x=S.next();if(i.checkCollisions=u.checkCollisions,i.overrideMaterialSideOrientation=u.overrideMaterialSideOrientation,t)for(o=0;o<e.length;o++)e[o].dispose();if(n||r){i.releaseSubMeshes(),o=0;let e=0;for(;o<c.length;)I.P.CreateFromIndices(0,e,c[o],i,void 0,!1),e+=c[o],o++;for(const t of i.subMeshes)t.refreshBoundingInfo();i.computeWorldMatrix(!0)}if(r){const e=new v.G(u.name+"_merged",u.getScene());e.subMaterials=h;for(let t=0;t<i.subMeshes.length;t++)i.subMeshes[t].materialIndex=l[t];i.material=e}else i.material=u.material;return i}()}addInstance(e){e._indexInSourceMeshInstanceArray=this.instances.length,this.instances.push(e)}removeInstance(e){const t=e._indexInSourceMeshInstanceArray;if(-1!=t){if(t!==this.instances.length-1){const e=this.instances[this.instances.length-1];this.instances[t]=e,e._indexInSourceMeshInstanceArray=t}e._indexInSourceMeshInstanceArray=-1,this.instances.pop()}}_shouldConvertRHS(){return this.overrideMaterialSideOrientation===M.F.CounterClockWiseSideOrientation}_getRenderingFillMode(e){var t;const s=this.getScene();return s.forcePointsCloud?M.F.PointFillMode:s.forceWireframe?M.F.WireFrameFillMode:null!==(t=this.overrideRenderingFillMode)&&void 0!==t?t:e}}F.FRONTSIDE=g.x.FRONTSIDE,F.BACKSIDE=g.x.BACKSIDE,F.DOUBLESIDE=g.x.DOUBLESIDE,F.DEFAULTSIDE=g.x.DEFAULTSIDE,F.NO_CAP=0,F.CAP_START=1,F.CAP_END=2,F.CAP_ALL=3,F.NO_FLIP=0,F.FLIP_TILE=1,F.ROTATE_TILE=2,F.FLIP_ROW=3,F.ROTATE_ROW=4,F.FLIP_N_ROTATE_TILE=5,F.FLIP_N_ROTATE_ROW=6,F.CENTER=0,F.LEFT=1,F.RIGHT=2,F.TOP=3,F.BOTTOM=4,F.INSTANCEDMESH_SORT_TRANSPARENT=!1,F._GroundMeshParser=(e,t)=>{throw(0,S.S)("GroundMesh")},F._GoldbergMeshParser=(e,t)=>{throw(0,S.S)("GoldbergMesh")},F._LinesMeshParser=(e,t)=>{throw(0,S.S)("LinesMesh")},(0,b.H)("BABYLON.Mesh",F),F.prototype.setMaterialByID=function(e){return this.setMaterialById(e)},F.CreateDisc=F.CreateDisc||(()=>{throw new Error("Import MeshBuilder to populate this function")}),F.CreateBox=F.CreateBox||(()=>{throw new Error("Import MeshBuilder to populate this function")}),F.CreateSphere=F.CreateSphere||(()=>{throw new Error("Import MeshBuilder to populate this function")}),F.CreateCylinder=F.CreateCylinder||(()=>{throw new Error("Import MeshBuilder to populate this function")}),F.CreateTorusKnot=F.CreateTorusKnot||(()=>{throw new Error("Import MeshBuilder to populate this function")}),F.CreateTorus=F.CreateTorus||(()=>{throw new Error("Import MeshBuilder to populate this function")}),F.CreatePlane=F.CreatePlane||(()=>{throw new Error("Import MeshBuilder to populate this function")}),F.CreateGround=F.CreateGround||(()=>{throw new Error("Import MeshBuilder to populate this function")}),F.CreateTiledGround=F.CreateTiledGround||(()=>{throw new Error("Import MeshBuilder to populate this function")}),F.CreateGroundFromHeightMap=F.CreateGroundFromHeightMap||(()=>{throw new Error("Import MeshBuilder to populate this function")}),F.CreateTube=F.CreateTube||(()=>{throw new Error("Import MeshBuilder to populate this function")}),F.CreatePolyhedron=F.CreatePolyhedron||(()=>{throw new Error("Import MeshBuilder to populate this function")}),F.CreateIcoSphere=F.CreateIcoSphere||(()=>{throw new Error("Import MeshBuilder to populate this function")}),F.CreateDecal=F.CreateDecal||(()=>{throw new Error("Import MeshBuilder to populate this function")}),F.CreateCapsule=F.CreateCapsule||(()=>{throw new Error("Import MeshBuilder to populate this function")}),F.ExtendToGoldberg=F.ExtendToGoldberg||(()=>{throw new Error("Import MeshBuilder to populate this function")})}}]);
//# sourceMappingURL=5138549d-be0d6a61f2dcef2a4739.js.map